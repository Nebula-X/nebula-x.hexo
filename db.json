{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/img/avatar.jpg","path":"img/avatar.jpg","modified":0,"renderable":0},{"_id":"source/img/icon_wechat.png","path":"img/icon_wechat.png","modified":0,"renderable":0},{"_id":"source/img/404-bg.jpg","path":"img/404-bg.jpg","modified":0,"renderable":0},{"_id":"source/img/signature/nebula-black.png","path":"img/signature/nebula-black.png","modified":0,"renderable":0},{"_id":"source/img/signature/nebula-white.png","path":"img/signature/nebula-white.png","modified":0,"renderable":0},{"_id":"themes/beantech/source/css/archive.styl","path":"css/archive.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/beantech.css","path":"css/beantech.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/beantech.min.css","path":"css/beantech.min.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/hux-blog.min.css","path":"css/hux-blog.min.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/signature.styl","path":"css/signature.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/rocket.styl","path":"css/rocket.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/toc.styl","path":"css/toc.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/widget.styl","path":"css/widget.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/hux-blog.js","path":"js/hux-blog.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/hux-blog.min.js","path":"js/hux-blog.min.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/jquery.nav.js","path":"js/jquery.nav.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/toc.js","path":"js/toc.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"source/img/header_img/Iron-Man-3.jpg","path":"img/header_img/Iron-Man-3.jpg","modified":0,"renderable":0},{"_id":"themes/beantech/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/bootstrap.js","path":"js/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"source/img/contact-bg.jpg","path":"img/contact-bg.jpg","modified":0,"renderable":0},{"_id":"themes/beantech/source/css/bootstrap.css","path":"css/bootstrap.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/images/ironman.png","path":"css/images/ironman.png","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/images/rocket.png","path":"css/images/rocket.png","modified":0,"renderable":1},{"_id":"source/img/header_img/tf-logo-dark.png","path":"img/header_img/tf-logo-dark.png","modified":0,"renderable":0},{"_id":"themes/beantech/source/js/jquery.js","path":"js/jquery.js","modified":0,"renderable":1},{"_id":"source/img/beantech-desktop.png","path":"img/beantech-desktop.png","modified":0,"renderable":0},{"_id":"source/img/header_img/tag-bg.png","path":"img/header_img/tag-bg.png","modified":0,"renderable":0},{"_id":"source/img/header_img/home-bg-o.png","path":"img/header_img/home-bg-o.png","modified":0,"renderable":0},{"_id":"source/img/header_img/home-bg-2-dark.png","path":"img/header_img/home-bg-2-dark.png","modified":0,"renderable":0},{"_id":"source/img/header_img/archive-bg.png","path":"img/header_img/archive-bg.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/404.md","hash":"8d0d831a77fe92a9e1530366ed90dec6d73d3aef","modified":1541580566620},{"_id":"source/CNAME","hash":"c9e7a36a848473962a7689ab37caf5b9347af655","modified":1541671811512},{"_id":"themes/beantech/_config.yml","hash":"f0796b8e85fe6b3154a5fa442420003fe18dff0a","modified":1545276087260},{"_id":"themes/beantech/LICENSE","hash":"c48eaae47a703282e0ffe7b91d69366452046214","modified":1541580566723},{"_id":"source/_posts/RabbitMQ学习-1-概念与认识.md","hash":"548033a77e893122ebf44d08f44375ce59295e23","modified":1542780967799},{"_id":"source/_posts/RabbitMQ学习-2-队列模型.md","hash":"7fe3250c6cb123a47088a9fc53200861dbca1620","modified":1543106057568},{"_id":"source/_posts/hexo-theme-beantech.md","hash":"d7b8618bbd1a4897781c9a75309c02e097d4d74e","modified":1541807596362},{"_id":"source/_posts/基于Golang的gRPC使用笔记1.md","hash":"c2686645ab891e09e60d2651dca34e60d6be542e","modified":1542725365945},{"_id":"source/_posts/微服务API网关框架-1.md","hash":"0dcff76be4e45b4e7adabb7008210485614b146a","modified":1545209139151},{"_id":"source/_posts/微服务API网关框架-2.md","hash":"c6ccbbddcb336bb807a159b8778602392b545722","modified":1545275204188},{"_id":"source/_posts/微服务API网关框架-3.md","hash":"73ad78b943d7239de1b0110a360a798c96c850c7","modified":1545287173532},{"_id":"source/_posts/微服务API网关框架-4.md","hash":"a8c43570990203c1c78bbe435c5d6bb228ee33fb","modified":1545287214503},{"_id":"source/_posts/微服务API网关框架-5.md","hash":"f598e38b5f157490057f5f8d7fc680b247b2cdd6","modified":1545287268927},{"_id":"source/about/index.md","hash":"28611a9a0b9074734fce81b4f6669bf652a1b4c3","modified":1541726221596},{"_id":"source/_posts/微服务API网关框架-6.md","hash":"1664bacbc56a3fef63b3ae803932b157d9f53c94","modified":1545286232976},{"_id":"source/archive/index.md","hash":"971fdb6d0fc384fe1301dc82a68568d5ab29d332","modified":1541726039442},{"_id":"source/img/avatar.jpg","hash":"77c450e6ef9c5c243fdd212a87fedda945718382","modified":1541691053456},{"_id":"source/img/icon_wechat.png","hash":"4188058026609de06c6cac88b349a2da831a1783","modified":1541580566711},{"_id":"source/tags/index.md","hash":"d8fbfb47afcf8bbf75c4b1244d5727e20a01cd99","modified":1541726588994},{"_id":"themes/beantech/languages_to_be_added/de.yml","hash":"02a98ba2b93e30a00ae7979fbe90b767a27290f0","modified":1541580566725},{"_id":"themes/beantech/languages_to_be_added/default.yml","hash":"3cd0873b310cbf2fe022ee18d55a6113b347ea09","modified":1541580566726},{"_id":"themes/beantech/languages_to_be_added/en.yml","hash":"3cd0873b310cbf2fe022ee18d55a6113b347ea09","modified":1541580566726},{"_id":"themes/beantech/languages_to_be_added/no.yml","hash":"5ce3a1043ff85cecf83f3b5b0cdad2df44fa0192","modified":1541580566728},{"_id":"themes/beantech/languages_to_be_added/es.yml","hash":"fb089145368422ac47da9eb00fed05b15c904aa2","modified":1541580566727},{"_id":"themes/beantech/languages_to_be_added/pl.yml","hash":"6dc5d1b2aa75ae4c527089a770f43bafb91d80f4","modified":1541580566729},{"_id":"themes/beantech/languages_to_be_added/ru.yml","hash":"2cfaf93704ea4ac3f374c69bab89ca31916faa33","modified":1541580566730},{"_id":"themes/beantech/languages_to_be_added/zh-CN.yml","hash":"6d712d9eb6ba12213dcd76b532cd86e9da83cfa3","modified":1541580566730},{"_id":"themes/beantech/layout/404.ejs","hash":"c9b488d74c21fe9f35f642a5d19a138099ddf8a8","modified":1541580566732},{"_id":"themes/beantech/languages_to_be_added/zh-TW.yml","hash":"45c84384a05fdb7e32a3e2d498ea180be7dccfa9","modified":1541580566731},{"_id":"themes/beantech/layout/about.ejs","hash":"96c08fc3580b842ad9d8f37f2cdf02e6fa57d7bc","modified":1541580566742},{"_id":"themes/beantech/layout/archive.ejs","hash":"62781e8b0ce4de9c3db6042fedeaf13c26d138f8","modified":1541580566742},{"_id":"themes/beantech/layout/index.ejs","hash":"f293cefe4bf9f9c6848dff08b6dac4aeb7948892","modified":1541580566743},{"_id":"themes/beantech/layout/keynote.ejs","hash":"e177b9e4a159f40b512f4ae1bfd928be4ab60840","modified":1541580566744},{"_id":"themes/beantech/layout/layout.ejs","hash":"389fc11a45676f94b77ebd2cb0d658a0358979c8","modified":1541580566745},{"_id":"themes/beantech/layout/page.ejs","hash":"b6d161e11168c73122cbf2a41b7307bef4ab5dbd","modified":1541692415317},{"_id":"themes/beantech/layout/tags.ejs","hash":"63911a99e6daf9968bfdd7d69f0d3d697039902e","modified":1541580566749},{"_id":"themes/beantech/layout/post.ejs","hash":"8aef246a0a5c7bc24b47db836ec07b37bc6f5ad6","modified":1541692199751},{"_id":"source/_posts/RabbitMQ学习-1-概念与认识/v-host授权2.png","hash":"faac5113e412f275712979750ed753d42696373c","modified":1542780223246},{"_id":"source/_posts/RabbitMQ学习-1-概念与认识/v-host授权后.png","hash":"de55545d7621d45a61471f09f163e1ca4cc1415f","modified":1542780247065},{"_id":"source/_posts/RabbitMQ学习-1-概念与认识/日志收集与处理.png","hash":"19aebd9fd04bb76cbd64edfd2a7b63c8426315cd","modified":1542766790132},{"_id":"source/_posts/RabbitMQ学习-1-概念与认识/异步处理.png","hash":"666bb259fc180c35ce51e090d6dfabfbda5a08ef","modified":1542767722125},{"_id":"source/_posts/RabbitMQ学习-1-概念与认识/秒杀抢购.png","hash":"1065b2ba7a9593c5879a2039b16fe157158d3455","modified":1542768240639},{"_id":"source/_posts/RabbitMQ学习-1-概念与认识/系统解耦.png","hash":"2c9ac9d22338ab6926704730cb28ed775b24b128","modified":1542767885748},{"_id":"source/_posts/RabbitMQ学习-2-队列模型/工作队列.png","hash":"059875c4bc4e3e79bb873acfc4f7f222ad885898","modified":1543104666114},{"_id":"source/_posts/RabbitMQ学习-2-队列模型/简单队列.png","hash":"be0611cd80bb4ca21b65f9c28edb329a18475ab0","modified":1542782248986},{"_id":"source/_posts/基于Golang的gRPC使用笔记1/gRPC特点.png","hash":"1ff8aa50c81a7560bc3571af57848ec98d8e10f3","modified":1542004381200},{"_id":"source/_posts/基于Golang的gRPC使用笔记1/gRPC调用示例.png","hash":"0bd9f2344416c46b2d99612d47db8aafd734c7fa","modified":1542004252689},{"_id":"source/_posts/基于Golang的gRPC使用笔记1/rpc原理图.png","hash":"04ccbcfe8ff0734f2175bcaf7bbd3a3889f14a49","modified":1542003658824},{"_id":"source/img/404-bg.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1541580566645},{"_id":"source/img/signature/nebula-black.png","hash":"faf235e18821463843caefc127c750a227b3ed69","modified":1541728036564},{"_id":"source/img/signature/nebula-white.png","hash":"a3c2e03ae0a23beb01a15f37424835c001d93cfd","modified":1541728030087},{"_id":"themes/beantech/layout/_partial/footer.ejs","hash":"447d159e505f5dbd56b79f5994e038d46ddde509","modified":1541679641600},{"_id":"themes/beantech/layout/_partial/head.ejs","hash":"258af22c0c8d5dce3f218f4cc8b2220f38a841b9","modified":1541580566734},{"_id":"themes/beantech/layout/_partial/nav.ejs","hash":"e65bfec3d14a9eb9f1e09b592bb34023e6bf6e83","modified":1541580566735},{"_id":"themes/beantech/layout/_partial/pagination.ejs","hash":"cd61e4dbbf6020ad094c8e66ec06e8c38ebcd122","modified":1541580566736},{"_id":"themes/beantech/layout/_partial/sidebar.ejs","hash":"bc7834dd769eeac94a76ffd9cfbb13a622861b62","modified":1541580566736},{"_id":"themes/beantech/layout/_partial/header.ejs","hash":"9aea336d3907735eedabcfb21c286cd54a01f45f","modified":1541580566734},{"_id":"themes/beantech/layout/_partial/toc.ejs","hash":"a765433a33b3613f4664de2da48d0c58f68f8cd6","modified":1541580566737},{"_id":"themes/beantech/layout/_widget/archive.ejs","hash":"ad9fb0073d40fe90bfe3a1e3246e0b07e12b3ecf","modified":1541580566738},{"_id":"themes/beantech/layout/_widget/category.ejs","hash":"c32e6fb8f3a07c5cbaffcebf93c357237c18b009","modified":1541580566739},{"_id":"themes/beantech/layout/_widget/featured-tags.ejs","hash":"51543d9f7d41abdb4deff7ff949cd5ecad074853","modified":1541692709095},{"_id":"themes/beantech/layout/_widget/friends-blog.ejs","hash":"db2471d05df2ad0b3ec882595550e68163ffbc45","modified":1541692507534},{"_id":"themes/beantech/layout/_widget/recent-posts.ejs","hash":"305bd9feaf2484052ba2925a13ebb8723a885396","modified":1541671090453},{"_id":"themes/beantech/layout/_widget/short-about.ejs","hash":"f3f4fd95fbb98090d6abd94b855d0a39c8bed9f5","modified":1541692753069},{"_id":"themes/beantech/source/css/archive.styl","hash":"bcb216ef65804c97b1a5dbe5f519fc171a13aaf1","modified":1541580566751},{"_id":"themes/beantech/source/css/beantech.css","hash":"5e9bee0a553da83a3efd4e9bc975a0ebd13b1b7d","modified":1541580566752},{"_id":"themes/beantech/source/css/beantech.min.css","hash":"05a06230b1a9eca0b30cece54a397008cb77dc50","modified":1541580566753},{"_id":"themes/beantech/source/css/highlight.styl","hash":"831f8195f3577ba5bea374f2e24b90054d445055","modified":1541580566759},{"_id":"themes/beantech/source/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1541580566760},{"_id":"themes/beantech/source/css/signature.styl","hash":"63ae8051f59d5e69544647cc4173eabc81d99aae","modified":1541580566764},{"_id":"themes/beantech/source/css/rocket.styl","hash":"0abbccdbcd6cce70e8a0bab7152c38adc0b708f1","modified":1541580566764},{"_id":"themes/beantech/source/css/toc.styl","hash":"822aca17c885109452cc75a9aa384d9f3c07ea81","modified":1541580566765},{"_id":"themes/beantech/source/css/widget.styl","hash":"f996466e299c68274145ba5afaca9b6d1dd83114","modified":1541580566766},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1541580566768},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1541580566771},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1541580566773},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1541580566775},{"_id":"themes/beantech/source/js/hux-blog.js","hash":"3d3c93e42a9990b2a2e6df5a08e9816f9a221e0f","modified":1541580566780},{"_id":"themes/beantech/source/js/bootstrap.min.js","hash":"313da686ebbe387064f2d1899c64ea562b81eb40","modified":1541580566779},{"_id":"themes/beantech/source/js/hux-blog.min.js","hash":"ee99af17a1a69ac8d85a695fed0349ba202789ae","modified":1541580566781},{"_id":"themes/beantech/source/js/jquery.nav.js","hash":"bc6383fa2aa8f437978cf044a3b6f10a65114398","modified":1541580566788},{"_id":"themes/beantech/source/js/jquery.tagcloud.js","hash":"448017ff32f75f444ed7985d10a21b3ad92ab100","modified":1541580566788},{"_id":"themes/beantech/source/js/toc.js","hash":"4ffe95b7755b035ee1b41664fa72b0ebea29c3f8","modified":1541580566789},{"_id":"themes/beantech/source/js/totop.js","hash":"f796b09b4f6177c3674a8c1542a8c92e8590cb5c","modified":1541580566790},{"_id":"source/_posts/RabbitMQ学习-1-概念与认识/v-host授权.png","hash":"64bc4522873a247c08fd4f8251ff2b39601675bf","modified":1542780193599},{"_id":"source/_posts/RabbitMQ学习-1-概念与认识/v-host添加.png","hash":"6773b8d9e5de8d9de3cd509108ffd1e1ed888ee9","modified":1542780083770},{"_id":"source/_posts/微服务API网关框架-1/单节点场景网关.png","hash":"aace22510bf66be74488cbd53c0fc55ba66a0dbc","modified":1544165223471},{"_id":"source/_posts/微服务API网关框架-1/反向代理.png","hash":"505070cb7d764184993ddb9f5f22237feee0d366","modified":1544176907851},{"_id":"source/img/header_img/Iron-Man-3.jpg","hash":"62a9a76854503c327990cc8d10de293ab6e9588f","modified":1541580566658},{"_id":"themes/beantech/source/css/bootstrap.min.css","hash":"1818a346630e7133a1f194669f613f613fcfa97c","modified":1541580566758},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.svg","hash":"4dcf0ab896f5417047f881de91bad10dcbda48c6","modified":1541580566770},{"_id":"themes/beantech/source/js/bootstrap.js","hash":"5d69034fb6eded2e5961ea54dd47129a88cd5182","modified":1541580566778},{"_id":"themes/beantech/source/js/jquery.min.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1541580566787},{"_id":"source/_posts/RabbitMQ学习-1-概念与认识/vhost.png","hash":"b2cd3450e3df72495678acf9af9b994a5a461045","modified":1542779994853},{"_id":"source/_posts/hexo-theme-beantech/home_posts_tag-false.png","hash":"86a3a4320012981f2d42eabc6ea172425f2f941a","modified":1541580566636},{"_id":"source/_posts/微服务API网关框架-1/多节点场景网关.png","hash":"3796d6200be78e6b133ec0b6161be559f5f12136","modified":1544165266969},{"_id":"source/_posts/微服务API网关框架-1/架构2.png","hash":"af2ebcc3de50bfbbc99dd9ec1e580a795b7a3e17","modified":1544166572643},{"_id":"source/_posts/微服务API网关框架-1/架构.png","hash":"5ede75fb54a0656e433a75874fbd863f496db8eb","modified":1544166518917},{"_id":"source/_posts/微服务API网关框架-1/正向代理.png","hash":"cf2fd43df3865613c8fbb6b64641a6c2df3ab069","modified":1544176776480},{"_id":"source/_posts/微服务API网关框架-1/架构3.png","hash":"793e70019e84c2773cf0e2cb9f4ad3db749d9f69","modified":1544166622304},{"_id":"source/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1541580566656},{"_id":"themes/beantech/source/css/bootstrap.css","hash":"d1a24afac31222d70b4e001e0361ef045aa42043","modified":1541580566756},{"_id":"themes/beantech/source/css/images/ironman.png","hash":"2f0db0ab15d466c4065d9f6102fdf829726d9e3f","modified":1541580566762},{"_id":"themes/beantech/source/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1541580566763},{"_id":"source/_posts/RabbitMQ学习-1-概念与认识/用户管理-添加用户.png","hash":"48bf176c95fcbf511b37eec2bc66382054a0a844","modified":1542779870912},{"_id":"source/_posts/hexo-theme-beantech/home_posts_tag-true.png","hash":"a704520b43f26b88d650098f60689af3af5eb106","modified":1541580566638},{"_id":"source/img/header_img/tf-logo-dark.png","hash":"5c7bf8ade9de134f8c77a3c59e575abe9fc6cdd4","modified":1541580566710},{"_id":"themes/beantech/source/js/jquery.js","hash":"4bb763dc96da604aed08ac024a1a3f5de73eea39","modified":1541580566785},{"_id":"source/_posts/微服务API网关框架-1/新旧进程同在.png","hash":"d470602ee33a4515534404d0bbe2db93f8b6922a","modified":1544276814244},{"_id":"source/img/beantech-desktop.png","hash":"4a8f8b209c9db8fd5209f15b8e4590525e258b0f","modified":1541580566654},{"_id":"source/img/header_img/tag-bg.png","hash":"e83cd7b04ff85bcbc9bd3ebf5e57a55166e82568","modified":1541580566707},{"_id":"source/_posts/RabbitMQ学习-1-概念与认识/Demo.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1541580566633},{"_id":"source/_posts/RabbitMQ学习-2-队列模型/Demo.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1541580566633},{"_id":"source/_posts/hexo-theme-beantech/Demo.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1541580566633},{"_id":"source/_posts/基于Golang的gRPC使用笔记1/Demo.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1541580566633},{"_id":"source/_posts/微服务API网关框架-1/Demo.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1541580566633},{"_id":"source/_posts/微服务API网关框架-2/Demo.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1541580566633},{"_id":"source/_posts/微服务API网关框架-4/Demo.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1541580566633},{"_id":"source/_posts/微服务API网关框架-3/Demo.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1541580566633},{"_id":"source/_posts/微服务API网关框架-5/Demo.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1541580566633},{"_id":"source/_posts/微服务API网关框架-6/Demo.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1541580566633},{"_id":"source/img/header_img/home-bg-o.png","hash":"134ece4cb4c49c7ca1403a5afe7f46d0e2f9ecbb","modified":1541580566693},{"_id":"source/img/header_img/home-bg-2-dark.png","hash":"da6a3d5ca787bdc25e69655abd879b4f821aeb30","modified":1541580566682},{"_id":"source/img/header_img/archive-bg.png","hash":"6bf9c224543ec54e250309db89cbdf46e0c4b5ba","modified":1541580566669}],"Category":[],"Data":[],"Page":[{"layout":"404","description":"你来到了没有知识的荒原 :(","header-img":"img/404-bg.jpg","_content":"","source":"404.md","raw":"---\nlayout: 404\ndescription: \"你来到了没有知识的荒原 :(\"\nheader-img: \"img/404-bg.jpg\"\n---\n","date":"2018-11-07T08:49:26.620Z","updated":"2018-11-07T08:49:26.620Z","path":"404.html","title":"","comments":1,"_id":"cjpw2eyek0000n0ujvzquf7eu","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"about","title":"关于我","date":"2018-11-08T16:00:00.000Z","description":"勿在浮沙筑高台，不为浮华易匠心","header-img":"img/header_img/Iron-Man-3.jpg","comments":1,"_content":"\n> 光有好奇心而不去實踐，等於自願放棄成功機會\n> 別為自己畫地自限，Just Do It！！\n","source":"about/index.md","raw":"---\nlayout: \"about\"\ntitle: \"关于我\"\ndate: 2018-11-09 00:00:00\ndescription: \"勿在浮沙筑高台，不为浮华易匠心\"\nheader-img: \"img/header_img/Iron-Man-3.jpg\"\ncomments: true\n---\n\n> 光有好奇心而不去實踐，等於自願放棄成功機會\n> 別為自己畫地自限，Just Do It！！\n","updated":"2018-11-09T01:17:01.596Z","path":"about/index.html","_id":"cjpw2eyh5000pn0ujn7gzp6w4","content":"<blockquote>\n<p>光有好奇心而不去實踐，等於自願放棄成功機會<br>\n別為自己畫地自限，Just Do It！！</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>光有好奇心而不去實踐，等於自願放棄成功機會<br>\n別為自己畫地自限，Just Do It！！</p>\n</blockquote>\n"},{"layout":"archive","title":"归档","header-img":"img/header_img/archive-bg.png","comments":0,"date":"2017-03-20T12:49:56.000Z","description":"时光匆匆流逝，记录的却是简单的过去","_content":"","source":"archive/index.md","raw":"---\nlayout: \"archive\"\ntitle: \"归档\"\nheader-img: \"img/header_img/archive-bg.png\"\ncomments: false\ndate: 2017-03-20 20:49:56\ndescription: \"时光匆匆流逝，记录的却是简单的过去\"\n---\n","updated":"2018-11-09T01:13:59.442Z","path":"archive/index.html","_id":"cjpw2eyh7000rn0ujyeidsonn","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"tags","title":"书签","description":"嗯，分类是个好习惯","header-img":"img/header_img/tag-bg.png","_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: \"书签\"\ndescription: \"嗯，分类是个好习惯\"\nheader-img: \"img/header_img/tag-bg.png\"\n---\n","date":"2018-11-09T01:23:09.047Z","updated":"2018-11-09T01:23:08.994Z","path":"tags/index.html","comments":1,"_id":"cjpw2eyhb000un0uj21sml98z","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"RabbitMQ学习(1)--概念与认识","catalog":true,"date":"2018-11-21T02:11:54.000Z","subtitle":null,"header-img":"Demo.png","catagories":["RabbitMQ"],"_content":"# RabbitMQ学习(1)--概念与认识\n\n## 消息队列\n\n### 解决了什么问题\n1.异步处理\n>以前一般写业务是串行模式，发短信是耗费时间的操作，串行有可能断开HTTP连接还没有做完\n\n![异步处理](异步处理.png)\n2.应用解耦\n>即多个子系统有关联，例如库存与订单系统，如果使用串行的模式，有可能在运行的过程中，由于系统间的通讯异常,造成数据丢失，这样会影响整个流程不能正常的走通\n\n![系统解耦](系统解耦.png)\n3.流量削锋\n>使用MQ之后,如果不满足的请求直接丢弃，这样可以把我们大量请求处理进行隔绝，保证业务不会因海量的访问而崩溃\n\n![秒杀抢购](秒杀抢购.png)\n4.日志处理\n>下面例子用于统计UV,PV等日志数据例子,一般来说，日志不会直接写入数据库，而是先写入文件，再由日志收集工具(logstash)进行统一的处理\n\n>流计算：就是实时计算，生成显示数据\n离线计算：对数据进行持久化\n\n![日志收集与处理](日志收集与处理.png)\n\n5. 等等\n\n### RabbitMQ安装 (不做详细的介绍)\n>自行参考网址: https://www.cnblogs.com/zzpblogs/p/8168763.html\n\n### RabbitMQ的简单使用\n\n#### 用户管理\n1.添加用户\n![用户管理-添加用户](用户管理-添加用户.png)\n\n#### virtual hosts管理\nvirtual hosts 相当于mysql的db(即数据库)，一般以\"/\"开头\n创建完数据库后，就要对数据库进行授权，\n![vhost](vhost.png)\n![v-host授权](v-host授权.png)\n![v-host添加](v-host添加.png)\n![v-host授权2](v-host授权2.png)\n![v-host授权后](v-host授权后.png)\n","source":"_posts/RabbitMQ学习-1-概念与认识.md","raw":"---\ntitle: \"RabbitMQ学习(1)--概念与认识\"\ncatalog: true\ndate: 2018-11-21 10:11:54\nsubtitle: \nheader-img: \"Demo.png\"\ntags:\n- RabbitMQ 消息队列\ncatagories:\n- RabbitMQ\n---\n# RabbitMQ学习(1)--概念与认识\n\n## 消息队列\n\n### 解决了什么问题\n1.异步处理\n>以前一般写业务是串行模式，发短信是耗费时间的操作，串行有可能断开HTTP连接还没有做完\n\n![异步处理](异步处理.png)\n2.应用解耦\n>即多个子系统有关联，例如库存与订单系统，如果使用串行的模式，有可能在运行的过程中，由于系统间的通讯异常,造成数据丢失，这样会影响整个流程不能正常的走通\n\n![系统解耦](系统解耦.png)\n3.流量削锋\n>使用MQ之后,如果不满足的请求直接丢弃，这样可以把我们大量请求处理进行隔绝，保证业务不会因海量的访问而崩溃\n\n![秒杀抢购](秒杀抢购.png)\n4.日志处理\n>下面例子用于统计UV,PV等日志数据例子,一般来说，日志不会直接写入数据库，而是先写入文件，再由日志收集工具(logstash)进行统一的处理\n\n>流计算：就是实时计算，生成显示数据\n离线计算：对数据进行持久化\n\n![日志收集与处理](日志收集与处理.png)\n\n5. 等等\n\n### RabbitMQ安装 (不做详细的介绍)\n>自行参考网址: https://www.cnblogs.com/zzpblogs/p/8168763.html\n\n### RabbitMQ的简单使用\n\n#### 用户管理\n1.添加用户\n![用户管理-添加用户](用户管理-添加用户.png)\n\n#### virtual hosts管理\nvirtual hosts 相当于mysql的db(即数据库)，一般以\"/\"开头\n创建完数据库后，就要对数据库进行授权，\n![vhost](vhost.png)\n![v-host授权](v-host授权.png)\n![v-host添加](v-host添加.png)\n![v-host授权2](v-host授权2.png)\n![v-host授权后](v-host授权后.png)\n","slug":"RabbitMQ学习-1-概念与认识","published":1,"updated":"2018-11-21T06:16:07.799Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpw2eyfc0001n0uj6qu6ga4j","content":"<h1><span id=\"rabbitmq学习1概念与认识\">RabbitMQ学习(1)–概念与认识</span></h1>\n<h2><span id=\"消息队列\">消息队列</span></h2>\n<h3><span id=\"解决了什么问题\">解决了什么问题</span></h3>\n<p>1.异步处理</p>\n<blockquote>\n<p>以前一般写业务是串行模式，发短信是耗费时间的操作，串行有可能断开HTTP连接还没有做完</p>\n</blockquote>\n<p><img src=\"%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86.png\" alt=\"异步处理\"><br>\n2.应用解耦</p>\n<blockquote>\n<p>即多个子系统有关联，例如库存与订单系统，如果使用串行的模式，有可能在运行的过程中，由于系统间的通讯异常,造成数据丢失，这样会影响整个流程不能正常的走通</p>\n</blockquote>\n<p><img src=\"%E7%B3%BB%E7%BB%9F%E8%A7%A3%E8%80%A6.png\" alt=\"系统解耦\"><br>\n3.流量削锋</p>\n<blockquote>\n<p>使用MQ之后,如果不满足的请求直接丢弃，这样可以把我们大量请求处理进行隔绝，保证业务不会因海量的访问而崩溃</p>\n</blockquote>\n<p><img src=\"%E7%A7%92%E6%9D%80%E6%8A%A2%E8%B4%AD.png\" alt=\"秒杀抢购\"><br>\n4.日志处理</p>\n<blockquote>\n<p>下面例子用于统计UV,PV等日志数据例子,一般来说，日志不会直接写入数据库，而是先写入文件，再由日志收集工具(logstash)进行统一的处理</p>\n</blockquote>\n<blockquote>\n<p>流计算：就是实时计算，生成显示数据<br>\n离线计算：对数据进行持久化</p>\n</blockquote>\n<p><img src=\"%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86%E4%B8%8E%E5%A4%84%E7%90%86.png\" alt=\"日志收集与处理\"></p>\n<ol start=\"5\">\n<li>等等</li>\n</ol>\n<h3><span id=\"rabbitmq安装-不做详细的介绍\">RabbitMQ安装 (不做详细的介绍)</span></h3>\n<blockquote>\n<p>自行参考网址: <a href=\"https://www.cnblogs.com/zzpblogs/p/8168763.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/zzpblogs/p/8168763.html</a></p>\n</blockquote>\n<h3><span id=\"rabbitmq的简单使用\">RabbitMQ的简单使用</span></h3>\n<h4><span id=\"用户管理\">用户管理</span></h4>\n<p>1.添加用户<br>\n<img src=\"%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86-%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7.png\" alt=\"用户管理-添加用户\"></p>\n<h4><span id=\"virtual-hosts管理\">virtual hosts管理</span></h4>\n<p>virtual hosts 相当于mysql的db(即数据库)，一般以&quot;/&quot;开头<br>\n创建完数据库后，就要对数据库进行授权，<br>\n<img src=\"vhost.png\" alt=\"vhost\"><br>\n<img src=\"v-host%E6%8E%88%E6%9D%83.png\" alt=\"v-host授权\"><br>\n<img src=\"v-host%E6%B7%BB%E5%8A%A0.png\" alt=\"v-host添加\"><br>\n<img src=\"v-host%E6%8E%88%E6%9D%832.png\" alt=\"v-host授权2\"><br>\n<img src=\"v-host%E6%8E%88%E6%9D%83%E5%90%8E.png\" alt=\"v-host授权后\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1>RabbitMQ学习(1)–概念与认识</h1>\n<h2>消息队列</h2>\n<h3>解决了什么问题</h3>\n<p>1.异步处理</p>\n<blockquote>\n<p>以前一般写业务是串行模式，发短信是耗费时间的操作，串行有可能断开HTTP连接还没有做完</p>\n</blockquote>\n<p><img src=\"%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86.png\" alt=\"异步处理\"><br>\n2.应用解耦</p>\n<blockquote>\n<p>即多个子系统有关联，例如库存与订单系统，如果使用串行的模式，有可能在运行的过程中，由于系统间的通讯异常,造成数据丢失，这样会影响整个流程不能正常的走通</p>\n</blockquote>\n<p><img src=\"%E7%B3%BB%E7%BB%9F%E8%A7%A3%E8%80%A6.png\" alt=\"系统解耦\"><br>\n3.流量削锋</p>\n<blockquote>\n<p>使用MQ之后,如果不满足的请求直接丢弃，这样可以把我们大量请求处理进行隔绝，保证业务不会因海量的访问而崩溃</p>\n</blockquote>\n<p><img src=\"%E7%A7%92%E6%9D%80%E6%8A%A2%E8%B4%AD.png\" alt=\"秒杀抢购\"><br>\n4.日志处理</p>\n<blockquote>\n<p>下面例子用于统计UV,PV等日志数据例子,一般来说，日志不会直接写入数据库，而是先写入文件，再由日志收集工具(logstash)进行统一的处理</p>\n</blockquote>\n<blockquote>\n<p>流计算：就是实时计算，生成显示数据<br>\n离线计算：对数据进行持久化</p>\n</blockquote>\n<p><img src=\"%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86%E4%B8%8E%E5%A4%84%E7%90%86.png\" alt=\"日志收集与处理\"></p>\n<ol start=\"5\">\n<li>等等</li>\n</ol>\n<h3>RabbitMQ安装 (不做详细的介绍)</h3>\n<blockquote>\n<p>自行参考网址: <a href=\"https://www.cnblogs.com/zzpblogs/p/8168763.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/zzpblogs/p/8168763.html</a></p>\n</blockquote>\n<h3>RabbitMQ的简单使用</h3>\n<h4>用户管理</h4>\n<p>1.添加用户<br>\n<img src=\"%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86-%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7.png\" alt=\"用户管理-添加用户\"></p>\n<h4>virtual hosts管理</h4>\n<p>virtual hosts 相当于mysql的db(即数据库)，一般以&quot;/&quot;开头<br>\n创建完数据库后，就要对数据库进行授权，<br>\n<img src=\"vhost.png\" alt=\"vhost\"><br>\n<img src=\"v-host%E6%8E%88%E6%9D%83.png\" alt=\"v-host授权\"><br>\n<img src=\"v-host%E6%B7%BB%E5%8A%A0.png\" alt=\"v-host添加\"><br>\n<img src=\"v-host%E6%8E%88%E6%9D%832.png\" alt=\"v-host授权2\"><br>\n<img src=\"v-host%E6%8E%88%E6%9D%83%E5%90%8E.png\" alt=\"v-host授权后\"></p>\n"},{"title":"RabbitMQ学习(2)--队列模型","catalog":true,"date":"2018-11-21T06:11:54.000Z","subtitle":null,"header-img":"Demo.png","catagories":["RabbitMQ"],"_content":"\n# RabbitMQ学习(1)--队列模型\n\n## 概念\nRabbitMQ存在六种模型\n>1.简单队列\n>2.工作队列\n>3.发布订阅\n>4.路由\n>5.Topic\n>6.RPC\n\n## 模型\n### 简单队列\n![简单队列](简单队列.png)\n>模型解析\nP: 消息生产者\n红色方块集合: 消息队列\nC: 消息消费者\n\n#### Golang实现简单队列\n\n官方依赖库: go get github.com/streadway/amqp\n\n向队列发送消息具体流程\n>1.获取MQ的连接\n>2.创建频道,从连接中获取通道\n>3.创建队列声明\n>4.创建消息，并发送消息\n>5.关闭连接\n\n>具体代码:\n```\npackage main\nimport (\n\t\"github.com/streadway/amqp\"\n\t\"log\"\n)\n\n// We also need an helper function to check the return value for each amqp call\nfunc failOnError(err error, msg string) {\n\tif err != nil {\n\t\tlog.Fatalf(\"%s: %s\", msg, err)\n\t}\n}\n\nfunc main() {\n\t// 连接到RabbitMQ Server\n\tconn, err := amqp.Dial(\"amqp://user_mmr:123456@localhost:5672/\")\n\tfailOnError(err, \"Failed to connect to RabbitMQ\")\n\tdefer conn.Close()\n\t// 创建channel，channel为驻留程序\n\tch, err := conn.Channel()\n\tfailOnError(err, \"Failed to Open a channel\")\n\tdefer ch.Close()\n\t// 我们需要声明发送队列，那么我们可以发送消息到这个队列上\n\t// 队列的创建时幂等的，只有当不存在，才会创建队列，且队列名是唯一的\n\tq, err := ch.QueueDeclare(\n\t\t\"hello\", // name\n\t\tfalse,   // durable\n\t\tfalse,   // delete when unused\n\t\tfalse,   // exclusive\n\t\tfalse,   // no-wait\n\t\tnil,     // arguments\n\t)\n\tfailOnError(err, \"Failed to declare a queue\")\n\tbody := \"Hello World222!\"\n\terr = ch.Publish(\n\t\t\"\",     // exchange\n\t\tq.Name, // routing key\n\t\tfalse,  // mandatory\n\t\tfalse,  // immediate\n\t\tamqp.Publishing{\n\t\t\tContentType: \"text/plain\",\n\t\t\tBody:        []byte(body),\n\t\t})\n\tfailOnError(err, \"Failed to publish a message\")\n}\n```\n\n\n从队列接收消息具体流程\n>1.获取MQ的连接\n>2.创建频道,从连接中获取通道\n>3.定义队列的监听者\n>4.监听队列(开一个协程来监听处理)\n\n>具体代码:\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"github.com/streadway/amqp\"\n\t\"log\"\n)\n\n// We also need an helper function to check the return value for each amqp call\nfunc failOnError(err error, msg string) {\n\tif err != nil {\n\t\tlog.Fatalf(\"%s: %s\", msg, err)\n\t}\n}\n\nfunc main() {\n\tconn, err := amqp.Dial(\"amqp://user_mmr:123456@localhost:5672/\")\n\tfailOnError(err, \"Failed to connect to RabbitMQ\")\n\tdefer conn.Close()\n\n\tch, err := conn.Channel()\n\tfailOnError(err, \"Failed to open a channel\")\n\tdefer ch.Close()\n\n\tq, err := ch.QueueDeclare(\n\t\t\"hello\", // name\n\t\tfalse,   // durable\n\t\tfalse,   // delete when usused\n\t\tfalse,   // exclusive\n\t\tfalse,   // no-wait\n\t\tnil,     // arguments\n\t)\n\tfailOnError(err, \"Failed to declare a queue\")\n\tmsgs, err := ch.Consume(\n\t\tq.Name, // queue\n\t\t\"\",     // consumer\n\t\ttrue,   // auto-ack\n\t\tfalse,  // exclusive\n\t\tfalse,  // no-local\n\t\tfalse,  // no-wait\n\t\tnil,    // args\n\t)\n\tfailOnError(err, \"Failed to register a consumer\")\n\tfmt.Println(\"aaaaaa\")\n\tforever := make(chan bool)\n\n\tgo func() {\n\t\tfor d := range msgs {\n\t\t\tlog.Printf(\"Received a message: %s\", d.Body)\n\t\t}\n\t}()\n\n\tlog.Printf(\" [*] Waiting for messages. To exit press CTRL+C\")\n\t<-forever\n}\n\n```\n\n#### 简单队列的不足\n耦合性高，生产者一一对应消费者(如果我想有多个消费者消费队列中的消息，这种情况就不行了)\n队列名变更，这个时候也得同时变更\n\n### 工作队列\n![工作队列](工作队列.png)\n\n####为什么会出现工作队列\nSimple 队列是一一对应的，而且我们实际开发，生产者发送消息是毫不费力的，而消费者一般是要跟业务相结合的，消费者接收到消息之后就需要处理，可能需要花费时间,即耗时操作，由于只有一个消费者，此时队列就会挤压了很多的消息等待处理，所以工作队列能够解决这个问题\n\n从上面的代码中可以发现,消费者1和消费者2处理的消息是一样的,\n消费者1: 偶数\n消费者2：奇数\n这个方式叫做轮训分发(round-robin),结果就是不管谁忙者谁清闲，都不会多给一个消息，消息任务总是你一个我一个\n\n\n\n\n\n\n\n","source":"_posts/RabbitMQ学习-2-队列模型.md","raw":"---\ntitle: \"RabbitMQ学习(2)--队列模型\"\ncatalog: true\ndate: 2018-11-21 14:11:54\nsubtitle: \nheader-img: \"Demo.png\"\ntags:\n- RabbitMQ 消息队列\ncatagories:\n- RabbitMQ\n---\n\n# RabbitMQ学习(1)--队列模型\n\n## 概念\nRabbitMQ存在六种模型\n>1.简单队列\n>2.工作队列\n>3.发布订阅\n>4.路由\n>5.Topic\n>6.RPC\n\n## 模型\n### 简单队列\n![简单队列](简单队列.png)\n>模型解析\nP: 消息生产者\n红色方块集合: 消息队列\nC: 消息消费者\n\n#### Golang实现简单队列\n\n官方依赖库: go get github.com/streadway/amqp\n\n向队列发送消息具体流程\n>1.获取MQ的连接\n>2.创建频道,从连接中获取通道\n>3.创建队列声明\n>4.创建消息，并发送消息\n>5.关闭连接\n\n>具体代码:\n```\npackage main\nimport (\n\t\"github.com/streadway/amqp\"\n\t\"log\"\n)\n\n// We also need an helper function to check the return value for each amqp call\nfunc failOnError(err error, msg string) {\n\tif err != nil {\n\t\tlog.Fatalf(\"%s: %s\", msg, err)\n\t}\n}\n\nfunc main() {\n\t// 连接到RabbitMQ Server\n\tconn, err := amqp.Dial(\"amqp://user_mmr:123456@localhost:5672/\")\n\tfailOnError(err, \"Failed to connect to RabbitMQ\")\n\tdefer conn.Close()\n\t// 创建channel，channel为驻留程序\n\tch, err := conn.Channel()\n\tfailOnError(err, \"Failed to Open a channel\")\n\tdefer ch.Close()\n\t// 我们需要声明发送队列，那么我们可以发送消息到这个队列上\n\t// 队列的创建时幂等的，只有当不存在，才会创建队列，且队列名是唯一的\n\tq, err := ch.QueueDeclare(\n\t\t\"hello\", // name\n\t\tfalse,   // durable\n\t\tfalse,   // delete when unused\n\t\tfalse,   // exclusive\n\t\tfalse,   // no-wait\n\t\tnil,     // arguments\n\t)\n\tfailOnError(err, \"Failed to declare a queue\")\n\tbody := \"Hello World222!\"\n\terr = ch.Publish(\n\t\t\"\",     // exchange\n\t\tq.Name, // routing key\n\t\tfalse,  // mandatory\n\t\tfalse,  // immediate\n\t\tamqp.Publishing{\n\t\t\tContentType: \"text/plain\",\n\t\t\tBody:        []byte(body),\n\t\t})\n\tfailOnError(err, \"Failed to publish a message\")\n}\n```\n\n\n从队列接收消息具体流程\n>1.获取MQ的连接\n>2.创建频道,从连接中获取通道\n>3.定义队列的监听者\n>4.监听队列(开一个协程来监听处理)\n\n>具体代码:\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"github.com/streadway/amqp\"\n\t\"log\"\n)\n\n// We also need an helper function to check the return value for each amqp call\nfunc failOnError(err error, msg string) {\n\tif err != nil {\n\t\tlog.Fatalf(\"%s: %s\", msg, err)\n\t}\n}\n\nfunc main() {\n\tconn, err := amqp.Dial(\"amqp://user_mmr:123456@localhost:5672/\")\n\tfailOnError(err, \"Failed to connect to RabbitMQ\")\n\tdefer conn.Close()\n\n\tch, err := conn.Channel()\n\tfailOnError(err, \"Failed to open a channel\")\n\tdefer ch.Close()\n\n\tq, err := ch.QueueDeclare(\n\t\t\"hello\", // name\n\t\tfalse,   // durable\n\t\tfalse,   // delete when usused\n\t\tfalse,   // exclusive\n\t\tfalse,   // no-wait\n\t\tnil,     // arguments\n\t)\n\tfailOnError(err, \"Failed to declare a queue\")\n\tmsgs, err := ch.Consume(\n\t\tq.Name, // queue\n\t\t\"\",     // consumer\n\t\ttrue,   // auto-ack\n\t\tfalse,  // exclusive\n\t\tfalse,  // no-local\n\t\tfalse,  // no-wait\n\t\tnil,    // args\n\t)\n\tfailOnError(err, \"Failed to register a consumer\")\n\tfmt.Println(\"aaaaaa\")\n\tforever := make(chan bool)\n\n\tgo func() {\n\t\tfor d := range msgs {\n\t\t\tlog.Printf(\"Received a message: %s\", d.Body)\n\t\t}\n\t}()\n\n\tlog.Printf(\" [*] Waiting for messages. To exit press CTRL+C\")\n\t<-forever\n}\n\n```\n\n#### 简单队列的不足\n耦合性高，生产者一一对应消费者(如果我想有多个消费者消费队列中的消息，这种情况就不行了)\n队列名变更，这个时候也得同时变更\n\n### 工作队列\n![工作队列](工作队列.png)\n\n####为什么会出现工作队列\nSimple 队列是一一对应的，而且我们实际开发，生产者发送消息是毫不费力的，而消费者一般是要跟业务相结合的，消费者接收到消息之后就需要处理，可能需要花费时间,即耗时操作，由于只有一个消费者，此时队列就会挤压了很多的消息等待处理，所以工作队列能够解决这个问题\n\n从上面的代码中可以发现,消费者1和消费者2处理的消息是一样的,\n消费者1: 偶数\n消费者2：奇数\n这个方式叫做轮训分发(round-robin),结果就是不管谁忙者谁清闲，都不会多给一个消息，消息任务总是你一个我一个\n\n\n\n\n\n\n\n","slug":"RabbitMQ学习-2-队列模型","published":1,"updated":"2018-11-25T00:34:17.568Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpw2eyfg0002n0ujkhf6vlcc","content":"<h1><span id=\"rabbitmq学习1队列模型\">RabbitMQ学习(1)–队列模型</span></h1>\n<h2><span id=\"概念\">概念</span></h2>\n<p>RabbitMQ存在六种模型</p>\n<blockquote>\n<p>1.简单队列<br>\n2.工作队列<br>\n3.发布订阅<br>\n4.路由<br>\n5.Topic<br>\n6.RPC</p>\n</blockquote>\n<h2><span id=\"模型\">模型</span></h2>\n<h3><span id=\"简单队列\">简单队列</span></h3>\n<p><img src=\"%E7%AE%80%E5%8D%95%E9%98%9F%E5%88%97.png\" alt=\"简单队列\"></p>\n<blockquote>\n<p>模型解析<br>\nP: 消息生产者<br>\n红色方块集合: 消息队列<br>\nC: 消息消费者</p>\n</blockquote>\n<h4><span id=\"golang实现简单队列\">Golang实现简单队列</span></h4>\n<p>官方依赖库: go get <a href=\"http://github.com/streadway/amqp\" target=\"_blank\" rel=\"noopener\">github.com/streadway/amqp</a></p>\n<p>向队列发送消息具体流程</p>\n<blockquote>\n<p>1.获取MQ的连接<br>\n2.创建频道,从连接中获取通道<br>\n3.创建队列声明<br>\n4.创建消息，并发送消息<br>\n5.关闭连接</p>\n</blockquote>\n<blockquote>\n<p>具体代码:</p>\n</blockquote>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"github.com/streadway/amqp\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"log\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// We also need an helper function to check the return value for each amqp call</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">failOnError</span><span class=\"params\">(err error, msg <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatalf(<span class=\"string\">\"%s: %s\"</span>, msg, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 连接到RabbitMQ Server</span></span><br><span class=\"line\">\tconn, err := amqp.Dial(<span class=\"string\">\"amqp://user_mmr:123456@localhost:5672/\"</span>)</span><br><span class=\"line\">\tfailOnError(err, <span class=\"string\">\"Failed to connect to RabbitMQ\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> conn.Close()</span><br><span class=\"line\">\t<span class=\"comment\">// 创建channel，channel为驻留程序</span></span><br><span class=\"line\">\tch, err := conn.Channel()</span><br><span class=\"line\">\tfailOnError(err, <span class=\"string\">\"Failed to Open a channel\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> ch.Close()</span><br><span class=\"line\">\t<span class=\"comment\">// 我们需要声明发送队列，那么我们可以发送消息到这个队列上</span></span><br><span class=\"line\">\t<span class=\"comment\">// 队列的创建时幂等的，只有当不存在，才会创建队列，且队列名是唯一的</span></span><br><span class=\"line\">\tq, err := ch.QueueDeclare(</span><br><span class=\"line\">\t\t<span class=\"string\">\"hello\"</span>, <span class=\"comment\">// name</span></span><br><span class=\"line\">\t\t<span class=\"literal\">false</span>,   <span class=\"comment\">// durable</span></span><br><span class=\"line\">\t\t<span class=\"literal\">false</span>,   <span class=\"comment\">// delete when unused</span></span><br><span class=\"line\">\t\t<span class=\"literal\">false</span>,   <span class=\"comment\">// exclusive</span></span><br><span class=\"line\">\t\t<span class=\"literal\">false</span>,   <span class=\"comment\">// no-wait</span></span><br><span class=\"line\">\t\t<span class=\"literal\">nil</span>,     <span class=\"comment\">// arguments</span></span><br><span class=\"line\">\t)</span><br><span class=\"line\">\tfailOnError(err, <span class=\"string\">\"Failed to declare a queue\"</span>)</span><br><span class=\"line\">\tbody := <span class=\"string\">\"Hello World222!\"</span></span><br><span class=\"line\">\terr = ch.Publish(</span><br><span class=\"line\">\t\t<span class=\"string\">\"\"</span>,     <span class=\"comment\">// exchange</span></span><br><span class=\"line\">\t\tq.Name, <span class=\"comment\">// routing key</span></span><br><span class=\"line\">\t\t<span class=\"literal\">false</span>,  <span class=\"comment\">// mandatory</span></span><br><span class=\"line\">\t\t<span class=\"literal\">false</span>,  <span class=\"comment\">// immediate</span></span><br><span class=\"line\">\t\tamqp.Publishing&#123;</span><br><span class=\"line\">\t\t\tContentType: <span class=\"string\">\"text/plain\"</span>,</span><br><span class=\"line\">\t\t\tBody:        []<span class=\"keyword\">byte</span>(body),</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\tfailOnError(err, <span class=\"string\">\"Failed to publish a message\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从队列接收消息具体流程</p>\n<blockquote>\n<p>1.获取MQ的连接<br>\n2.创建频道,从连接中获取通道<br>\n3.定义队列的监听者<br>\n4.监听队列(开一个协程来监听处理)</p>\n</blockquote>\n<blockquote>\n<p>具体代码:</p>\n</blockquote>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"github.com/streadway/amqp\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"log\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// We also need an helper function to check the return value for each amqp call</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">failOnError</span><span class=\"params\">(err error, msg <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatalf(<span class=\"string\">\"%s: %s\"</span>, msg, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tconn, err := amqp.Dial(<span class=\"string\">\"amqp://user_mmr:123456@localhost:5672/\"</span>)</span><br><span class=\"line\">\tfailOnError(err, <span class=\"string\">\"Failed to connect to RabbitMQ\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> conn.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">\tch, err := conn.Channel()</span><br><span class=\"line\">\tfailOnError(err, <span class=\"string\">\"Failed to open a channel\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> ch.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">\tq, err := ch.QueueDeclare(</span><br><span class=\"line\">\t\t<span class=\"string\">\"hello\"</span>, <span class=\"comment\">// name</span></span><br><span class=\"line\">\t\t<span class=\"literal\">false</span>,   <span class=\"comment\">// durable</span></span><br><span class=\"line\">\t\t<span class=\"literal\">false</span>,   <span class=\"comment\">// delete when usused</span></span><br><span class=\"line\">\t\t<span class=\"literal\">false</span>,   <span class=\"comment\">// exclusive</span></span><br><span class=\"line\">\t\t<span class=\"literal\">false</span>,   <span class=\"comment\">// no-wait</span></span><br><span class=\"line\">\t\t<span class=\"literal\">nil</span>,     <span class=\"comment\">// arguments</span></span><br><span class=\"line\">\t)</span><br><span class=\"line\">\tfailOnError(err, <span class=\"string\">\"Failed to declare a queue\"</span>)</span><br><span class=\"line\">\tmsgs, err := ch.Consume(</span><br><span class=\"line\">\t\tq.Name, <span class=\"comment\">// queue</span></span><br><span class=\"line\">\t\t<span class=\"string\">\"\"</span>,     <span class=\"comment\">// consumer</span></span><br><span class=\"line\">\t\t<span class=\"literal\">true</span>,   <span class=\"comment\">// auto-ack</span></span><br><span class=\"line\">\t\t<span class=\"literal\">false</span>,  <span class=\"comment\">// exclusive</span></span><br><span class=\"line\">\t\t<span class=\"literal\">false</span>,  <span class=\"comment\">// no-local</span></span><br><span class=\"line\">\t\t<span class=\"literal\">false</span>,  <span class=\"comment\">// no-wait</span></span><br><span class=\"line\">\t\t<span class=\"literal\">nil</span>,    <span class=\"comment\">// args</span></span><br><span class=\"line\">\t)</span><br><span class=\"line\">\tfailOnError(err, <span class=\"string\">\"Failed to register a consumer\"</span>)</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">\"aaaaaa\"</span>)</span><br><span class=\"line\">\tforever := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">bool</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> d := <span class=\"keyword\">range</span> msgs &#123;</span><br><span class=\"line\">\t\t\tlog.Printf(<span class=\"string\">\"Received a message: %s\"</span>, d.Body)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">\tlog.Printf(<span class=\"string\">\" [*] Waiting for messages. To exit press CTRL+C\"</span>)</span><br><span class=\"line\">\t&lt;-forever</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4><span id=\"简单队列的不足\">简单队列的不足</span></h4>\n<p>耦合性高，生产者一一对应消费者(如果我想有多个消费者消费队列中的消息，这种情况就不行了)<br>\n队列名变更，这个时候也得同时变更</p>\n<h3><span id=\"工作队列\">工作队列</span></h3>\n<p><img src=\"%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97.png\" alt=\"工作队列\"></p>\n<p>####为什么会出现工作队列<br>\nSimple 队列是一一对应的，而且我们实际开发，生产者发送消息是毫不费力的，而消费者一般是要跟业务相结合的，消费者接收到消息之后就需要处理，可能需要花费时间,即耗时操作，由于只有一个消费者，此时队列就会挤压了很多的消息等待处理，所以工作队列能够解决这个问题</p>\n<p>从上面的代码中可以发现,消费者1和消费者2处理的消息是一样的,<br>\n消费者1: 偶数<br>\n消费者2：奇数<br>\n这个方式叫做轮训分发(round-robin),结果就是不管谁忙者谁清闲，都不会多给一个消息，消息任务总是你一个我一个</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>RabbitMQ学习(1)–队列模型</h1>\n<h2>概念</h2>\n<p>RabbitMQ存在六种模型</p>\n<blockquote>\n<p>1.简单队列<br>\n2.工作队列<br>\n3.发布订阅<br>\n4.路由<br>\n5.Topic<br>\n6.RPC</p>\n</blockquote>\n<h2>模型</h2>\n<h3>简单队列</h3>\n<p><img src=\"%E7%AE%80%E5%8D%95%E9%98%9F%E5%88%97.png\" alt=\"简单队列\"></p>\n<blockquote>\n<p>模型解析<br>\nP: 消息生产者<br>\n红色方块集合: 消息队列<br>\nC: 消息消费者</p>\n</blockquote>\n<h4>Golang实现简单队列</h4>\n<p>官方依赖库: go get <a href=\"http://github.com/streadway/amqp\" target=\"_blank\" rel=\"noopener\">github.com/streadway/amqp</a></p>\n<p>向队列发送消息具体流程</p>\n<blockquote>\n<p>1.获取MQ的连接<br>\n2.创建频道,从连接中获取通道<br>\n3.创建队列声明<br>\n4.创建消息，并发送消息<br>\n5.关闭连接</p>\n</blockquote>\n<blockquote>\n<p>具体代码:</p>\n</blockquote>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"github.com/streadway/amqp\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"log\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// We also need an helper function to check the return value for each amqp call</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">failOnError</span><span class=\"params\">(err error, msg <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatalf(<span class=\"string\">\"%s: %s\"</span>, msg, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 连接到RabbitMQ Server</span></span><br><span class=\"line\">\tconn, err := amqp.Dial(<span class=\"string\">\"amqp://user_mmr:123456@localhost:5672/\"</span>)</span><br><span class=\"line\">\tfailOnError(err, <span class=\"string\">\"Failed to connect to RabbitMQ\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> conn.Close()</span><br><span class=\"line\">\t<span class=\"comment\">// 创建channel，channel为驻留程序</span></span><br><span class=\"line\">\tch, err := conn.Channel()</span><br><span class=\"line\">\tfailOnError(err, <span class=\"string\">\"Failed to Open a channel\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> ch.Close()</span><br><span class=\"line\">\t<span class=\"comment\">// 我们需要声明发送队列，那么我们可以发送消息到这个队列上</span></span><br><span class=\"line\">\t<span class=\"comment\">// 队列的创建时幂等的，只有当不存在，才会创建队列，且队列名是唯一的</span></span><br><span class=\"line\">\tq, err := ch.QueueDeclare(</span><br><span class=\"line\">\t\t<span class=\"string\">\"hello\"</span>, <span class=\"comment\">// name</span></span><br><span class=\"line\">\t\t<span class=\"literal\">false</span>,   <span class=\"comment\">// durable</span></span><br><span class=\"line\">\t\t<span class=\"literal\">false</span>,   <span class=\"comment\">// delete when unused</span></span><br><span class=\"line\">\t\t<span class=\"literal\">false</span>,   <span class=\"comment\">// exclusive</span></span><br><span class=\"line\">\t\t<span class=\"literal\">false</span>,   <span class=\"comment\">// no-wait</span></span><br><span class=\"line\">\t\t<span class=\"literal\">nil</span>,     <span class=\"comment\">// arguments</span></span><br><span class=\"line\">\t)</span><br><span class=\"line\">\tfailOnError(err, <span class=\"string\">\"Failed to declare a queue\"</span>)</span><br><span class=\"line\">\tbody := <span class=\"string\">\"Hello World222!\"</span></span><br><span class=\"line\">\terr = ch.Publish(</span><br><span class=\"line\">\t\t<span class=\"string\">\"\"</span>,     <span class=\"comment\">// exchange</span></span><br><span class=\"line\">\t\tq.Name, <span class=\"comment\">// routing key</span></span><br><span class=\"line\">\t\t<span class=\"literal\">false</span>,  <span class=\"comment\">// mandatory</span></span><br><span class=\"line\">\t\t<span class=\"literal\">false</span>,  <span class=\"comment\">// immediate</span></span><br><span class=\"line\">\t\tamqp.Publishing&#123;</span><br><span class=\"line\">\t\t\tContentType: <span class=\"string\">\"text/plain\"</span>,</span><br><span class=\"line\">\t\t\tBody:        []<span class=\"keyword\">byte</span>(body),</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\tfailOnError(err, <span class=\"string\">\"Failed to publish a message\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从队列接收消息具体流程</p>\n<blockquote>\n<p>1.获取MQ的连接<br>\n2.创建频道,从连接中获取通道<br>\n3.定义队列的监听者<br>\n4.监听队列(开一个协程来监听处理)</p>\n</blockquote>\n<blockquote>\n<p>具体代码:</p>\n</blockquote>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"github.com/streadway/amqp\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"log\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// We also need an helper function to check the return value for each amqp call</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">failOnError</span><span class=\"params\">(err error, msg <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatalf(<span class=\"string\">\"%s: %s\"</span>, msg, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tconn, err := amqp.Dial(<span class=\"string\">\"amqp://user_mmr:123456@localhost:5672/\"</span>)</span><br><span class=\"line\">\tfailOnError(err, <span class=\"string\">\"Failed to connect to RabbitMQ\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> conn.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">\tch, err := conn.Channel()</span><br><span class=\"line\">\tfailOnError(err, <span class=\"string\">\"Failed to open a channel\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> ch.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">\tq, err := ch.QueueDeclare(</span><br><span class=\"line\">\t\t<span class=\"string\">\"hello\"</span>, <span class=\"comment\">// name</span></span><br><span class=\"line\">\t\t<span class=\"literal\">false</span>,   <span class=\"comment\">// durable</span></span><br><span class=\"line\">\t\t<span class=\"literal\">false</span>,   <span class=\"comment\">// delete when usused</span></span><br><span class=\"line\">\t\t<span class=\"literal\">false</span>,   <span class=\"comment\">// exclusive</span></span><br><span class=\"line\">\t\t<span class=\"literal\">false</span>,   <span class=\"comment\">// no-wait</span></span><br><span class=\"line\">\t\t<span class=\"literal\">nil</span>,     <span class=\"comment\">// arguments</span></span><br><span class=\"line\">\t)</span><br><span class=\"line\">\tfailOnError(err, <span class=\"string\">\"Failed to declare a queue\"</span>)</span><br><span class=\"line\">\tmsgs, err := ch.Consume(</span><br><span class=\"line\">\t\tq.Name, <span class=\"comment\">// queue</span></span><br><span class=\"line\">\t\t<span class=\"string\">\"\"</span>,     <span class=\"comment\">// consumer</span></span><br><span class=\"line\">\t\t<span class=\"literal\">true</span>,   <span class=\"comment\">// auto-ack</span></span><br><span class=\"line\">\t\t<span class=\"literal\">false</span>,  <span class=\"comment\">// exclusive</span></span><br><span class=\"line\">\t\t<span class=\"literal\">false</span>,  <span class=\"comment\">// no-local</span></span><br><span class=\"line\">\t\t<span class=\"literal\">false</span>,  <span class=\"comment\">// no-wait</span></span><br><span class=\"line\">\t\t<span class=\"literal\">nil</span>,    <span class=\"comment\">// args</span></span><br><span class=\"line\">\t)</span><br><span class=\"line\">\tfailOnError(err, <span class=\"string\">\"Failed to register a consumer\"</span>)</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">\"aaaaaa\"</span>)</span><br><span class=\"line\">\tforever := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">bool</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> d := <span class=\"keyword\">range</span> msgs &#123;</span><br><span class=\"line\">\t\t\tlog.Printf(<span class=\"string\">\"Received a message: %s\"</span>, d.Body)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">\tlog.Printf(<span class=\"string\">\" [*] Waiting for messages. To exit press CTRL+C\"</span>)</span><br><span class=\"line\">\t&lt;-forever</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4>简单队列的不足</h4>\n<p>耦合性高，生产者一一对应消费者(如果我想有多个消费者消费队列中的消息，这种情况就不行了)<br>\n队列名变更，这个时候也得同时变更</p>\n<h3>工作队列</h3>\n<p><img src=\"%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97.png\" alt=\"工作队列\"></p>\n<p>####为什么会出现工作队列<br>\nSimple 队列是一一对应的，而且我们实际开发，生产者发送消息是毫不费力的，而消费者一般是要跟业务相结合的，消费者接收到消息之后就需要处理，可能需要花费时间,即耗时操作，由于只有一个消费者，此时队列就会挤压了很多的消息等待处理，所以工作队列能够解决这个问题</p>\n<p>从上面的代码中可以发现,消费者1和消费者2处理的消息是一样的,<br>\n消费者1: 偶数<br>\n消费者2：奇数<br>\n这个方式叫做轮训分发(round-robin),结果就是不管谁忙者谁清闲，都不会多给一个消息，消息任务总是你一个我一个</p>\n"},{"title":"[Hexo] 主题使用教程","catalog":true,"date":"2018-11-08T16:23:00.000Z","subtitle":"This is hexo theme Demo.","header-img":"Demo.png","catagories":["Hexo"],"_content":"> Ported Theme of [Hux Blog](https://github.com/Huxpro/huxpro.github.io), Thank [Huxpro](https://github.com/Huxpro) for designing such a flawless theme.\n> \n> This BeanTech theme created by [YuHsuan](http://beantech.org) modified from the original Porter [Kaijun](http://kaijun.rocks/hexo-theme-huxblog/)\n\n# [Live Demo](http://beantech.org)\n---\n![BeanTech Desktop](http://beantech.org/img/beantech-desktop.png)\n\n# Usage\n---\nI publish the whole project for your convenience, so you can just follow the instruction down below, then you can easily customiz your own blog!\n\nLet's begin!!!\n\n## Init\n---\n```bash\ngit clone https://github.com/YenYuHsuan/hexo-theme-beantech.git ./hexo-beantech\ncd hexo-beantech\nnpm install\n```\n\n## Modify\n---\nModify `_config.yml` file with your own info.\nEspecially the section:\n### Deployment\nReplace to your own repo!\n```yml\ndeploy:\n  type: git\n  repo: https://github.com/<yourAccount>/<repo>\n  branch: <your-branch>\n```\n\n### Sidebar settings\nCopy your avatar image to `<root>/img/` and modify the `_config.yml`:\n```yml\nsidebar: true    # whether or not using Sidebar.\nsidebar-about-description: \"<your description>\"\nsidebar-avatar: img/<your avatar path>\n```\nand activate your personal widget you like\n```yml\nwidgets:         # here are widget you can use, you can comment out\n- featured-tags\n- short-about\n- recent-posts\n- friends-blog\n- archive\n- category\n```\nif you want to add sidebar widget, please add at `layout/_widget`.\n### Signature Setup\nCopy your signature image to `<root>/img/signature` and modify the `_config.yml`:\n```yml\nsignature: true   # show signature\nsignature-img: img/signature/<your-signature-ID>\n```\n### Go to top icon Setup\nMy icon is using iron man, you can change to your own icon at `css/image`.\n\n### Post tag\nYou can decide to show post tags or not.\n```yml\nhome_posts_tag: true\n```\n![home_posts_tag-true](home_posts_tag-true.png)\n```yml\nhome_posts_tag: false\n```\n![home_posts_tag-false](home_posts_tag-false.png)\n\n### Markdown render\nMy markdown render engine plugin is [hexo-renderer-markdown-it](https://github.com/celsomiranda/hexo-renderer-markdown-it).\n```yml\n# Markdown-it config\n## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wiki\nmarkdown:\n  render:\n    html: true\n    xhtmlOut: false\n    breaks: true\n    linkify: true\n    typographer: true\n    quotes: '“”‘’'\n```\nand if you want to change the header anchor 'ℬ', you can go to `layout/post.ejs` to change it.\n```javascript\nasync(\"https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js\",function(){\n        anchors.options = {\n          visible: 'hover',\n          placement: 'left',\n          icon: ℬ // this is the header anchor \"unicode\" icon\n        };\n```\n\n## Hexo Basics\n---\nSome hexo command:\n```bash\nhexo new post \"<post name>\" # you can change post to another layout if you want\nhexo clean && hexo generate # generate the static file\nhexo server # run hexo in local environment\nhexo deploy # hexo will push the static files automatically into the specific branch(gh-pages) of your repo!\n```\n\n# Have fun ^_^ \n---\n<!-- Place this tag in your head or just before your close body tag. -->\n<script async defer src=\"https://buttons.github.io/buttons.js\"></script>\n<!-- Place this tag where you want the button to render. -->\n\nPlease <a class=\"github-button\" href=\"https://github.com/YenYuHsuan/hexo-theme-beantech\" data-icon=\"octicon-star\" aria-label=\"Star YenYuHsuan/hexo-theme-beantech on GitHub\">Star</a> this Project if you like it! <a class=\"github-button\" href=\"https://github.com/YenYuHsuan\" aria-label=\"Follow @YenYuHsuan on GitHub\">Follow</a> would also be appreciated!\nPeace!\n","source":"_posts/hexo-theme-beantech.md","raw":"---\ntitle: \"[Hexo] 主题使用教程\"\ncatalog: true\ndate: 2018-11-09 00:23:00\nsubtitle: \"This is hexo theme Demo.\"\nheader-img: \"Demo.png\"\ntags:\n- Hexo\ncatagories:\n- Hexo\n---\n> Ported Theme of [Hux Blog](https://github.com/Huxpro/huxpro.github.io), Thank [Huxpro](https://github.com/Huxpro) for designing such a flawless theme.\n> \n> This BeanTech theme created by [YuHsuan](http://beantech.org) modified from the original Porter [Kaijun](http://kaijun.rocks/hexo-theme-huxblog/)\n\n# [Live Demo](http://beantech.org)\n---\n![BeanTech Desktop](http://beantech.org/img/beantech-desktop.png)\n\n# Usage\n---\nI publish the whole project for your convenience, so you can just follow the instruction down below, then you can easily customiz your own blog!\n\nLet's begin!!!\n\n## Init\n---\n```bash\ngit clone https://github.com/YenYuHsuan/hexo-theme-beantech.git ./hexo-beantech\ncd hexo-beantech\nnpm install\n```\n\n## Modify\n---\nModify `_config.yml` file with your own info.\nEspecially the section:\n### Deployment\nReplace to your own repo!\n```yml\ndeploy:\n  type: git\n  repo: https://github.com/<yourAccount>/<repo>\n  branch: <your-branch>\n```\n\n### Sidebar settings\nCopy your avatar image to `<root>/img/` and modify the `_config.yml`:\n```yml\nsidebar: true    # whether or not using Sidebar.\nsidebar-about-description: \"<your description>\"\nsidebar-avatar: img/<your avatar path>\n```\nand activate your personal widget you like\n```yml\nwidgets:         # here are widget you can use, you can comment out\n- featured-tags\n- short-about\n- recent-posts\n- friends-blog\n- archive\n- category\n```\nif you want to add sidebar widget, please add at `layout/_widget`.\n### Signature Setup\nCopy your signature image to `<root>/img/signature` and modify the `_config.yml`:\n```yml\nsignature: true   # show signature\nsignature-img: img/signature/<your-signature-ID>\n```\n### Go to top icon Setup\nMy icon is using iron man, you can change to your own icon at `css/image`.\n\n### Post tag\nYou can decide to show post tags or not.\n```yml\nhome_posts_tag: true\n```\n![home_posts_tag-true](home_posts_tag-true.png)\n```yml\nhome_posts_tag: false\n```\n![home_posts_tag-false](home_posts_tag-false.png)\n\n### Markdown render\nMy markdown render engine plugin is [hexo-renderer-markdown-it](https://github.com/celsomiranda/hexo-renderer-markdown-it).\n```yml\n# Markdown-it config\n## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wiki\nmarkdown:\n  render:\n    html: true\n    xhtmlOut: false\n    breaks: true\n    linkify: true\n    typographer: true\n    quotes: '“”‘’'\n```\nand if you want to change the header anchor 'ℬ', you can go to `layout/post.ejs` to change it.\n```javascript\nasync(\"https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js\",function(){\n        anchors.options = {\n          visible: 'hover',\n          placement: 'left',\n          icon: ℬ // this is the header anchor \"unicode\" icon\n        };\n```\n\n## Hexo Basics\n---\nSome hexo command:\n```bash\nhexo new post \"<post name>\" # you can change post to another layout if you want\nhexo clean && hexo generate # generate the static file\nhexo server # run hexo in local environment\nhexo deploy # hexo will push the static files automatically into the specific branch(gh-pages) of your repo!\n```\n\n# Have fun ^_^ \n---\n<!-- Place this tag in your head or just before your close body tag. -->\n<script async defer src=\"https://buttons.github.io/buttons.js\"></script>\n<!-- Place this tag where you want the button to render. -->\n\nPlease <a class=\"github-button\" href=\"https://github.com/YenYuHsuan/hexo-theme-beantech\" data-icon=\"octicon-star\" aria-label=\"Star YenYuHsuan/hexo-theme-beantech on GitHub\">Star</a> this Project if you like it! <a class=\"github-button\" href=\"https://github.com/YenYuHsuan\" aria-label=\"Follow @YenYuHsuan on GitHub\">Follow</a> would also be appreciated!\nPeace!\n","slug":"hexo-theme-beantech","published":1,"updated":"2018-11-09T23:53:16.362Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpw2eyfl0004n0uj1n0kv5xr","content":"<blockquote>\n<p>Ported Theme of <a href=\"https://github.com/Huxpro/huxpro.github.io\" target=\"_blank\" rel=\"noopener\">Hux Blog</a>, Thank <a href=\"https://github.com/Huxpro\" target=\"_blank\" rel=\"noopener\">Huxpro</a> for designing such a flawless theme.</p>\n<p>This BeanTech theme created by <a href=\"http://beantech.org\" target=\"_blank\" rel=\"noopener\">YuHsuan</a> modified from the original Porter <a href=\"http://kaijun.rocks/hexo-theme-huxblog/\" target=\"_blank\" rel=\"noopener\">Kaijun</a></p>\n</blockquote>\n<h1><span id=\"live-demo\"></span></h1>\n<hr>\n<p><img src=\"http://beantech.org/img/beantech-desktop.png\" alt=\"BeanTech Desktop\"></p>\n<h1><span id=\"usage\">Usage</span></h1>\n<hr>\n<p>I publish the whole project for your convenience, so you can just follow the instruction down below, then you can easily customiz your own blog!</p>\n<p>Let’s begin!!!</p>\n<h2><span id=\"init\">Init</span></h2>\n<hr>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/YenYuHsuan/hexo-theme-beantech.git ./hexo-beantech</span><br><span class=\"line\"><span class=\"built_in\">cd</span> hexo-beantech</span><br><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n<h2><span id=\"modify\">Modify</span></h2>\n<hr>\n<p>Modify <code>_config.yml</code> file with your own info.<br>\nEspecially the section:</p>\n<h3><span id=\"deployment\">Deployment</span></h3>\n<p>Replace to your own repo!</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\"><span class=\"attr\">  type:</span> <span class=\"string\">git</span></span><br><span class=\"line\"><span class=\"attr\">  repo:</span> <span class=\"attr\">https://github.com/&lt;yourAccount&gt;/&lt;repo&gt;</span></span><br><span class=\"line\"><span class=\"attr\">  branch:</span> <span class=\"string\">&lt;your-branch&gt;</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"sidebar-settings\">Sidebar settings</span></h3>\n<p>Copy your avatar image to <code>&lt;root&gt;/img/</code> and modify the <code>_config.yml</code>:</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">sidebar:</span> <span class=\"literal\">true</span>    <span class=\"comment\"># whether or not using Sidebar.</span></span><br><span class=\"line\"><span class=\"attr\">sidebar-about-description:</span> <span class=\"string\">\"&lt;your description&gt;\"</span></span><br><span class=\"line\"><span class=\"attr\">sidebar-avatar:</span> <span class=\"string\">img/&lt;your</span> <span class=\"string\">avatar</span> <span class=\"string\">path&gt;</span></span><br></pre></td></tr></table></figure>\n<p>and activate your personal widget you like</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">widgets:</span>         <span class=\"comment\"># here are widget you can use, you can comment out</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">featured-tags</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">short-about</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">recent-posts</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">friends-blog</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">archive</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">category</span></span><br></pre></td></tr></table></figure>\n<p>if you want to add sidebar widget, please add at <code>layout/_widget</code>.</p>\n<h3><span id=\"signature-setup\">Signature Setup</span></h3>\n<p>Copy your signature image to <code>&lt;root&gt;/img/signature</code> and modify the <code>_config.yml</code>:</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">signature:</span> <span class=\"literal\">true</span>   <span class=\"comment\"># show signature</span></span><br><span class=\"line\"><span class=\"attr\">signature-img:</span> <span class=\"string\">img/signature/&lt;your-signature-ID&gt;</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"go-to-top-icon-setup\">Go to top icon Setup</span></h3>\n<p>My icon is using iron man, you can change to your own icon at <code>css/image</code>.</p>\n<h3><span id=\"post-tag\">Post tag</span></h3>\n<p>You can decide to show post tags or not.</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">home_posts_tag:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"home_posts_tag-true.png\" alt=\"home_posts_tag-true\"></p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">home_posts_tag:</span> <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"home_posts_tag-false.png\" alt=\"home_posts_tag-false\"></p>\n<h3><span id=\"markdown-render\">Markdown render</span></h3>\n<p>My markdown render engine plugin is <a href=\"https://github.com/celsomiranda/hexo-renderer-markdown-it\" target=\"_blank\" rel=\"noopener\">hexo-renderer-markdown-it</a>.</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Markdown-it config</span></span><br><span class=\"line\"><span class=\"comment\">## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wiki</span></span><br><span class=\"line\"><span class=\"attr\">markdown:</span></span><br><span class=\"line\"><span class=\"attr\">  render:</span></span><br><span class=\"line\"><span class=\"attr\">    html:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    xhtmlOut:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    breaks:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    linkify:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    typographer:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    quotes:</span> <span class=\"string\">'“”‘’'</span></span><br></pre></td></tr></table></figure>\n<p>and if you want to change the header anchor ‘ℬ’, you can go to <code>layout/post.ejs</code> to change it.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span>(<span class=\"string\">\"https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        anchors.options = &#123;</span><br><span class=\"line\">          visible: <span class=\"string\">'hover'</span>,</span><br><span class=\"line\">          placement: <span class=\"string\">'left'</span>,</span><br><span class=\"line\">          icon: ℬ <span class=\"comment\">// this is the header anchor \"unicode\" icon</span></span><br><span class=\"line\">        &#125;;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"hexo-basics\">Hexo Basics</span></h2>\n<hr>\n<p>Some hexo command:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new post <span class=\"string\">\"&lt;post name&gt;\"</span> <span class=\"comment\"># you can change post to another layout if you want</span></span><br><span class=\"line\">hexo clean &amp;&amp; hexo generate <span class=\"comment\"># generate the static file</span></span><br><span class=\"line\">hexo server <span class=\"comment\"># run hexo in local environment</span></span><br><span class=\"line\">hexo deploy <span class=\"comment\"># hexo will push the static files automatically into the specific branch(gh-pages) of your repo!</span></span><br></pre></td></tr></table></figure>\n<h1><span id=\"have-fun-_\">Have fun ^_^</span></h1>\n<hr>\n<!-- Place this tag in your head or just before your close body tag. -->\n<script async defer src=\"https://buttons.github.io/buttons.js\"></script>\n<!-- Place this tag where you want the button to render. -->\n<p>Please <a class=\"github-button\" href=\"https://github.com/YenYuHsuan/hexo-theme-beantech\" data-icon=\"octicon-star\" aria-label=\"Star YenYuHsuan/hexo-theme-beantech on GitHub\" target=\"_blank\" rel=\"noopener\">Star</a> this Project if you like it! <a class=\"github-button\" href=\"https://github.com/YenYuHsuan\" aria-label=\"Follow @YenYuHsuan on GitHub\" target=\"_blank\" rel=\"noopener\">Follow</a> would also be appreciated!<br>\nPeace!</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>Ported Theme of <a href=\"https://github.com/Huxpro/huxpro.github.io\" target=\"_blank\" rel=\"noopener\">Hux Blog</a>, Thank <a href=\"https://github.com/Huxpro\" target=\"_blank\" rel=\"noopener\">Huxpro</a> for designing such a flawless theme.</p>\n<p>This BeanTech theme created by <a href=\"http://beantech.org\" target=\"_blank\" rel=\"noopener\">YuHsuan</a> modified from the original Porter <a href=\"http://kaijun.rocks/hexo-theme-huxblog/\" target=\"_blank\" rel=\"noopener\">Kaijun</a></p>\n</blockquote>\n<h1><a href=\"http://beantech.org\" target=\"_blank\" rel=\"noopener\">Live Demo</a></h1>\n<hr>\n<p><img src=\"http://beantech.org/img/beantech-desktop.png\" alt=\"BeanTech Desktop\"></p>\n<h1>Usage</h1>\n<hr>\n<p>I publish the whole project for your convenience, so you can just follow the instruction down below, then you can easily customiz your own blog!</p>\n<p>Let’s begin!!!</p>\n<h2>Init</h2>\n<hr>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/YenYuHsuan/hexo-theme-beantech.git ./hexo-beantech</span><br><span class=\"line\"><span class=\"built_in\">cd</span> hexo-beantech</span><br><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n<h2>Modify</h2>\n<hr>\n<p>Modify <code>_config.yml</code> file with your own info.<br>\nEspecially the section:</p>\n<h3>Deployment</h3>\n<p>Replace to your own repo!</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\"><span class=\"attr\">  type:</span> <span class=\"string\">git</span></span><br><span class=\"line\"><span class=\"attr\">  repo:</span> <span class=\"attr\">https://github.com/&lt;yourAccount&gt;/&lt;repo&gt;</span></span><br><span class=\"line\"><span class=\"attr\">  branch:</span> <span class=\"string\">&lt;your-branch&gt;</span></span><br></pre></td></tr></table></figure>\n<h3>Sidebar settings</h3>\n<p>Copy your avatar image to <code>&lt;root&gt;/img/</code> and modify the <code>_config.yml</code>:</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">sidebar:</span> <span class=\"literal\">true</span>    <span class=\"comment\"># whether or not using Sidebar.</span></span><br><span class=\"line\"><span class=\"attr\">sidebar-about-description:</span> <span class=\"string\">\"&lt;your description&gt;\"</span></span><br><span class=\"line\"><span class=\"attr\">sidebar-avatar:</span> <span class=\"string\">img/&lt;your</span> <span class=\"string\">avatar</span> <span class=\"string\">path&gt;</span></span><br></pre></td></tr></table></figure>\n<p>and activate your personal widget you like</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">widgets:</span>         <span class=\"comment\"># here are widget you can use, you can comment out</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">featured-tags</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">short-about</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">recent-posts</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">friends-blog</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">archive</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">category</span></span><br></pre></td></tr></table></figure>\n<p>if you want to add sidebar widget, please add at <code>layout/_widget</code>.</p>\n<h3>Signature Setup</h3>\n<p>Copy your signature image to <code>&lt;root&gt;/img/signature</code> and modify the <code>_config.yml</code>:</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">signature:</span> <span class=\"literal\">true</span>   <span class=\"comment\"># show signature</span></span><br><span class=\"line\"><span class=\"attr\">signature-img:</span> <span class=\"string\">img/signature/&lt;your-signature-ID&gt;</span></span><br></pre></td></tr></table></figure>\n<h3>Go to top icon Setup</h3>\n<p>My icon is using iron man, you can change to your own icon at <code>css/image</code>.</p>\n<h3>Post tag</h3>\n<p>You can decide to show post tags or not.</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">home_posts_tag:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"home_posts_tag-true.png\" alt=\"home_posts_tag-true\"></p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">home_posts_tag:</span> <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"home_posts_tag-false.png\" alt=\"home_posts_tag-false\"></p>\n<h3>Markdown render</h3>\n<p>My markdown render engine plugin is <a href=\"https://github.com/celsomiranda/hexo-renderer-markdown-it\" target=\"_blank\" rel=\"noopener\">hexo-renderer-markdown-it</a>.</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Markdown-it config</span></span><br><span class=\"line\"><span class=\"comment\">## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wiki</span></span><br><span class=\"line\"><span class=\"attr\">markdown:</span></span><br><span class=\"line\"><span class=\"attr\">  render:</span></span><br><span class=\"line\"><span class=\"attr\">    html:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    xhtmlOut:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    breaks:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    linkify:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    typographer:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    quotes:</span> <span class=\"string\">'“”‘’'</span></span><br></pre></td></tr></table></figure>\n<p>and if you want to change the header anchor ‘ℬ’, you can go to <code>layout/post.ejs</code> to change it.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span>(<span class=\"string\">\"https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        anchors.options = &#123;</span><br><span class=\"line\">          visible: <span class=\"string\">'hover'</span>,</span><br><span class=\"line\">          placement: <span class=\"string\">'left'</span>,</span><br><span class=\"line\">          icon: ℬ <span class=\"comment\">// this is the header anchor \"unicode\" icon</span></span><br><span class=\"line\">        &#125;;</span><br></pre></td></tr></table></figure>\n<h2>Hexo Basics</h2>\n<hr>\n<p>Some hexo command:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new post <span class=\"string\">\"&lt;post name&gt;\"</span> <span class=\"comment\"># you can change post to another layout if you want</span></span><br><span class=\"line\">hexo clean &amp;&amp; hexo generate <span class=\"comment\"># generate the static file</span></span><br><span class=\"line\">hexo server <span class=\"comment\"># run hexo in local environment</span></span><br><span class=\"line\">hexo deploy <span class=\"comment\"># hexo will push the static files automatically into the specific branch(gh-pages) of your repo!</span></span><br></pre></td></tr></table></figure>\n<h1>Have fun ^_^</h1>\n<hr>\n<!-- Place this tag in your head or just before your close body tag. -->\n<script async defer src=\"https://buttons.github.io/buttons.js\"></script>\n<!-- Place this tag where you want the button to render. -->\n<p>Please <a class=\"github-button\" href=\"https://github.com/YenYuHsuan/hexo-theme-beantech\" data-icon=\"octicon-star\" aria-label=\"Star YenYuHsuan/hexo-theme-beantech on GitHub\" target=\"_blank\" rel=\"noopener\">Star</a> this Project if you like it! <a class=\"github-button\" href=\"https://github.com/YenYuHsuan\" aria-label=\"Follow @YenYuHsuan on GitHub\" target=\"_blank\" rel=\"noopener\">Follow</a> would also be appreciated!<br>\nPeace!</p>\n"},{"title":"gRPC使用 -- Golang版示例","catalog":true,"date":"2018-11-12T06:00:00.000Z","subtitle":null,"header-img":null,"catagories":["Hexo"],"_content":"# RPC入门\n\n## RPC框架原理\n```\n    RPC框架的目的就是让远程服务调用更加简单,透明，RPC框架负责屏蔽底层的传输方式(TCP或者UDP),\n    序列化方式(XML/JSON/二进制)和通信细节。服务调用者可以向本地接口一样调用远程的服务提供者，\n    而不需要关心底层通信细节和调用过程.\n```\n![rpc原理图](rpc原理图.png)\n\n## gRPC\n\n### gRPC简介\n```\n    gRPC 是一个高性能、开源和通用的 RPC 框架，面向服务端和移动端,基于HTTP/2设计.\n```\n![gRPC调用示例](gRPC调用示例.png)\n\n### gRPC特点\n![gRPC特点](gRPC特点.png)\n\n### Golang gRPC 示例\n\n#### 1、安装gRPC runtime\n```\ngo get google.golang.org/grpc\n```\n\n#### 2、protocal buffer安装\n```\n从https://github.com/google/protobuf/releases下载安装包，\n例如：protobuf-cpp-3.0.0-beta-3.zip，解压后\n./configure\nmake && make install\n再添加环境变量：export LD_LIBRARY_PATH=/usr/local/lib，之后protoc命令即可运行    \n```\n\n#### 3、安装GoLang protoc 插件\n```\ngo get -a github.com/golang/protobuf/protoc-gen-go\n```\n\n#### 4、定义service\n一个RPC service就是一个能够通过参数和返回值进行远程调用的method，我们可以简单地将它理解成一个函数。因为gRPC是通过将数据编码成protocal buffer来实现传输的。因此，我们通过protocal buffers interface definitioin language(IDL)来定义service method，同时将参数和返回值也定义成protocal buffer message类型。具体实现如下所示，包含下面代码的文件叫helloworld.proto：\n```\nsyntax = \"proto3\";\n \noption java_package = \"io.grpc.examples\";\n \npackage helloworld;\n \n// The greeter service definition.\nservice Greeter {\n  // Sends a greeting\n  rpc SayHello (HelloRequest) returns (HelloReply) {}\n}\n \n// The request message containing the user's name.\nmessage HelloRequest {\n  string name = 1;\n}\n \n// The response message containing the greetings\nmessage HelloReply {\n  string message = 1;\n}\n```\n\n#### 5.生成Golang通用代码\n```\n接着，根据上述定义的service，我们可以利用protocal buffer compiler ，\n即protoc生成相应的服务器端和客户端的GoLang代码。生成的代码中包含了客户端能够进行RPC的方法以及服务器端需要进行实现的接口。\n假设现在所在的目录是$GOPATH/src/helloworld/helloworld，我们将通过如下命令生成gRPC对应的GoLang代码：\nprotoc -I ./ helloworld.proto --go_out=plugins=grpc:.\n```\n\n#### 6.生成相关的RPC的客户端和服务端\n在目录$GOPATH/src/helloworld/下创建server.go 和client.go，分别用于服务器和客户端的实现\n\n##### 服务端代码\n```\npackage main\n \n// server.go\n \nimport (\n    \"log\"\n    \"net\"\n \n    \"golang.org/x/net/context\"\n    \"google.golang.org/grpc\"\n    pb \"helloworld/helloworld\"\n)\n \nconst (\n    port = \":50051\"\n)\n \ntype server struct {}\n \nfunc (s *server) SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloReply, error) {\n    return &pb.HelloReply{Message: \"Hello \" + in.Name}, nil\n}\n \nfunc main() {\n    lis, err := net.Listen(\"tcp\", port)\n    if err != nil {\n        log.Fatal(\"failed to listen: %v\", err)\n    }\n    s := grpc.NewServer()\n    pb.RegisterGreeterServer(s, &server{})\n    s.Serve(lis)\n}\n```\n\n##### 客户端代码\n```\npackage main\n \n//client.go\n \nimport (\n    \"log\"\n    \"os\"\n \n    \"golang.org/x/net/context\"\n    \"google.golang.org/grpc\"\n    pb \"helloworld/helloworld\"\n)\n \nconst (\n    address     = \"localhost:50051\"\n    defaultName = \"world\"\n)\n \nfunc main() {\n    conn, err := grpc.Dial(address, grpc.WithInsecure())\n    if err != nil {\n        log.Fatal(\"did not connect: %v\", err)\n    }\n    defer conn.Close()\n    c := pb.NewGreeterClient(conn)\n \n    name := defaultName\n    if len(os.Args) >1 {\n        name = os.Args[1]\n    }\n    r, err := c.SayHello(context.Background(), &pb.HelloRequest{Name: name})\n    if err != nil {\n        log.Fatal(\"could not greet: %v\", err)\n    }\n    log.Printf(\"Greeting: %s\", r.Message)\n}\n```\n这里需要注意的是包pb是我们之前生成的helloworld.pb.go所在的包，\n并非必须如上述代码所示在$GOPATH/src/helloworld/helloworld目录下\n\n#### 7.运行示例\n```\ngo run server.go\ngo run client.go\n```\n","source":"_posts/基于Golang的gRPC使用笔记1.md","raw":"---\ntitle: gRPC使用 -- Golang版示例\ncatalog: true\ndate: 2018-11-12 14:00:00\nsubtitle:\nheader-img:\ntags:\n- gRPC\n- golang\ncatagories:\n- Hexo\n---\n# RPC入门\n\n## RPC框架原理\n```\n    RPC框架的目的就是让远程服务调用更加简单,透明，RPC框架负责屏蔽底层的传输方式(TCP或者UDP),\n    序列化方式(XML/JSON/二进制)和通信细节。服务调用者可以向本地接口一样调用远程的服务提供者，\n    而不需要关心底层通信细节和调用过程.\n```\n![rpc原理图](rpc原理图.png)\n\n## gRPC\n\n### gRPC简介\n```\n    gRPC 是一个高性能、开源和通用的 RPC 框架，面向服务端和移动端,基于HTTP/2设计.\n```\n![gRPC调用示例](gRPC调用示例.png)\n\n### gRPC特点\n![gRPC特点](gRPC特点.png)\n\n### Golang gRPC 示例\n\n#### 1、安装gRPC runtime\n```\ngo get google.golang.org/grpc\n```\n\n#### 2、protocal buffer安装\n```\n从https://github.com/google/protobuf/releases下载安装包，\n例如：protobuf-cpp-3.0.0-beta-3.zip，解压后\n./configure\nmake && make install\n再添加环境变量：export LD_LIBRARY_PATH=/usr/local/lib，之后protoc命令即可运行    \n```\n\n#### 3、安装GoLang protoc 插件\n```\ngo get -a github.com/golang/protobuf/protoc-gen-go\n```\n\n#### 4、定义service\n一个RPC service就是一个能够通过参数和返回值进行远程调用的method，我们可以简单地将它理解成一个函数。因为gRPC是通过将数据编码成protocal buffer来实现传输的。因此，我们通过protocal buffers interface definitioin language(IDL)来定义service method，同时将参数和返回值也定义成protocal buffer message类型。具体实现如下所示，包含下面代码的文件叫helloworld.proto：\n```\nsyntax = \"proto3\";\n \noption java_package = \"io.grpc.examples\";\n \npackage helloworld;\n \n// The greeter service definition.\nservice Greeter {\n  // Sends a greeting\n  rpc SayHello (HelloRequest) returns (HelloReply) {}\n}\n \n// The request message containing the user's name.\nmessage HelloRequest {\n  string name = 1;\n}\n \n// The response message containing the greetings\nmessage HelloReply {\n  string message = 1;\n}\n```\n\n#### 5.生成Golang通用代码\n```\n接着，根据上述定义的service，我们可以利用protocal buffer compiler ，\n即protoc生成相应的服务器端和客户端的GoLang代码。生成的代码中包含了客户端能够进行RPC的方法以及服务器端需要进行实现的接口。\n假设现在所在的目录是$GOPATH/src/helloworld/helloworld，我们将通过如下命令生成gRPC对应的GoLang代码：\nprotoc -I ./ helloworld.proto --go_out=plugins=grpc:.\n```\n\n#### 6.生成相关的RPC的客户端和服务端\n在目录$GOPATH/src/helloworld/下创建server.go 和client.go，分别用于服务器和客户端的实现\n\n##### 服务端代码\n```\npackage main\n \n// server.go\n \nimport (\n    \"log\"\n    \"net\"\n \n    \"golang.org/x/net/context\"\n    \"google.golang.org/grpc\"\n    pb \"helloworld/helloworld\"\n)\n \nconst (\n    port = \":50051\"\n)\n \ntype server struct {}\n \nfunc (s *server) SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloReply, error) {\n    return &pb.HelloReply{Message: \"Hello \" + in.Name}, nil\n}\n \nfunc main() {\n    lis, err := net.Listen(\"tcp\", port)\n    if err != nil {\n        log.Fatal(\"failed to listen: %v\", err)\n    }\n    s := grpc.NewServer()\n    pb.RegisterGreeterServer(s, &server{})\n    s.Serve(lis)\n}\n```\n\n##### 客户端代码\n```\npackage main\n \n//client.go\n \nimport (\n    \"log\"\n    \"os\"\n \n    \"golang.org/x/net/context\"\n    \"google.golang.org/grpc\"\n    pb \"helloworld/helloworld\"\n)\n \nconst (\n    address     = \"localhost:50051\"\n    defaultName = \"world\"\n)\n \nfunc main() {\n    conn, err := grpc.Dial(address, grpc.WithInsecure())\n    if err != nil {\n        log.Fatal(\"did not connect: %v\", err)\n    }\n    defer conn.Close()\n    c := pb.NewGreeterClient(conn)\n \n    name := defaultName\n    if len(os.Args) >1 {\n        name = os.Args[1]\n    }\n    r, err := c.SayHello(context.Background(), &pb.HelloRequest{Name: name})\n    if err != nil {\n        log.Fatal(\"could not greet: %v\", err)\n    }\n    log.Printf(\"Greeting: %s\", r.Message)\n}\n```\n这里需要注意的是包pb是我们之前生成的helloworld.pb.go所在的包，\n并非必须如上述代码所示在$GOPATH/src/helloworld/helloworld目录下\n\n#### 7.运行示例\n```\ngo run server.go\ngo run client.go\n```\n","slug":"基于Golang的gRPC使用笔记1","published":1,"updated":"2018-11-20T14:49:25.945Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpw2eyfn0005n0ujbmnh9c96","content":"<h1><span id=\"rpc入门\">RPC入门</span></h1>\n<h2><span id=\"rpc框架原理\">RPC框架原理</span></h2>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RPC框架的目的就是让远程服务调用更加简单,透明，RPC框架负责屏蔽底层的传输方式<span class=\"comment\">(TCP或者UDP)</span>,</span><br><span class=\"line\">序列化方式<span class=\"comment\">(XML/JSON/二进制)</span>和通信细节。服务调用者可以向本地接口一样调用远程的服务提供者，</span><br><span class=\"line\">而不需要关心底层通信细节和调用过程.</span><br></pre></td></tr></table></figure>\n<p><img src=\"rpc%E5%8E%9F%E7%90%86%E5%9B%BE.png\" alt=\"rpc原理图\"></p>\n<h2><span id=\"grpc\">gRPC</span></h2>\n<h3><span id=\"grpc简介\">gRPC简介</span></h3>\n<figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gRPC 是一个高性能、开源和通用的 RPC 框架，面向服务端和移动端,基于HTTP/<span class=\"number\">2</span>设计.</span><br></pre></td></tr></table></figure>\n<p><img src=\"gRPC%E8%B0%83%E7%94%A8%E7%A4%BA%E4%BE%8B.png\" alt=\"gRPC调用示例\"></p>\n<h3><span id=\"grpc特点\">gRPC特点</span></h3>\n<p><img src=\"gRPC%E7%89%B9%E7%82%B9.png\" alt=\"gRPC特点\"></p>\n<h3><span id=\"golang-grpc-示例\">Golang gRPC 示例</span></h3>\n<h4><span id=\"1-安装grpc-runtime\">1、安装gRPC runtime</span></h4>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go get google<span class=\"selector-class\">.golang</span><span class=\"selector-class\">.org</span>/grpc</span><br></pre></td></tr></table></figure>\n<h4><span id=\"2-protocal-buffer安装\">2、protocal buffer安装</span></h4>\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">从https:<span class=\"comment\">//github.com/google/protobuf/releases下载安装包，</span></span><br><span class=\"line\">例如：protobuf-cpp<span class=\"number\">-3.0</span><span class=\"number\">.0</span>-<span class=\"built_in\">beta</span><span class=\"number\">-3.</span>zip，解压后</span><br><span class=\"line\">./configure</span><br><span class=\"line\"><span class=\"built_in\">make</span> &amp;&amp; <span class=\"built_in\">make</span> install</span><br><span class=\"line\">再添加环境变量：export LD_LIBRARY_PATH=/usr/<span class=\"keyword\">local</span>/<span class=\"keyword\">lib</span>，之后protoc命令即可运行</span><br></pre></td></tr></table></figure>\n<h4><span id=\"3-安装golang-protoc-插件\">3、安装GoLang protoc 插件</span></h4>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"built_in\">get</span> -<span class=\"keyword\">a</span> github.<span class=\"keyword\">com</span>/golang/protobuf/protoc-gen-<span class=\"keyword\">go</span></span><br></pre></td></tr></table></figure>\n<h4><span id=\"4-定义service\">4、定义service</span></h4>\n<p>一个RPC service就是一个能够通过参数和返回值进行远程调用的method，我们可以简单地将它理解成一个函数。因为gRPC是通过将数据编码成protocal buffer来实现传输的。因此，我们通过protocal buffers interface definitioin language(IDL)来定义service method，同时将参数和返回值也定义成protocal buffer message类型。具体实现如下所示，包含下面代码的文件叫helloworld.proto：</p>\n<figure class=\"highlight thrift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">syntax = <span class=\"string\">\"proto3\"</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">option java_package = <span class=\"string\">\"io.grpc.examples\"</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">package helloworld;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// The greeter service definition.</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">service</span> <span class=\"title\">Greeter</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Sends a greeting</span></span><br><span class=\"line\">  rpc SayHello (HelloRequest) returns (HelloReply) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// The request message containing the user's name.</span></span><br><span class=\"line\">message HelloRequest &#123;</span><br><span class=\"line\">  <span class=\"built_in\">string</span> name = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// The response message containing the greetings</span></span><br><span class=\"line\">message HelloReply &#123;</span><br><span class=\"line\">  <span class=\"built_in\">string</span> message = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4><span id=\"5生成golang通用代码\">5.生成Golang通用代码</span></h4>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">接着，根据上述定义的service，我们可以利用protocal buffer compiler ，</span><br><span class=\"line\">即protoc生成相应的服务器端和客户端的GoLang代码。生成的代码中包含了客户端能够进行RPC的方法以及服务器端需要进行实现的接口。</span><br><span class=\"line\">假设现在所在的目录是<span class=\"variable\">$GOPATH</span>/src/helloworld/helloworld，我们将通过如下命令生成gRPC对应的GoLang代码：</span><br><span class=\"line\">protoc -I ./ helloworld.proto <span class=\"attribute\">--go_out</span>=plugins=grpc:.</span><br></pre></td></tr></table></figure>\n<h4><span id=\"6生成相关的rpc的客户端和服务端\">6.生成相关的RPC的客户端和服务端</span></h4>\n<p>在目录$GOPATH/src/helloworld/下创建server.go 和client.go，分别用于服务器和客户端的实现</p>\n<h5><span id=\"服务端代码\">服务端代码</span></h5>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// server.go</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">\"log\"</span></span><br><span class=\"line\">    <span class=\"string\">\"net\"</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"string\">\"golang.org/x/net/context\"</span></span><br><span class=\"line\">    <span class=\"string\">\"google.golang.org/grpc\"</span></span><br><span class=\"line\">    pb <span class=\"string\">\"helloworld/helloworld\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">    port = <span class=\"string\">\":50051\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">type</span> server <span class=\"keyword\">struct</span> &#123;&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *server)</span> <span class=\"title\">SayHello</span><span class=\"params\">(ctx context.Context, in *pb.HelloRequest)</span> <span class=\"params\">(*pb.HelloReply, error)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;pb.HelloReply&#123;Message: <span class=\"string\">\"Hello \"</span> + in.Name&#125;, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    lis, err := net.Listen(<span class=\"string\">\"tcp\"</span>, port)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(<span class=\"string\">\"failed to listen: %v\"</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    s := grpc.NewServer()</span><br><span class=\"line\">    pb.RegisterGreeterServer(s, &amp;server&#123;&#125;)</span><br><span class=\"line\">    s.Serve(lis)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5><span id=\"客户端代码\">客户端代码</span></h5>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//client.go</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">\"log\"</span></span><br><span class=\"line\">    <span class=\"string\">\"os\"</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"string\">\"golang.org/x/net/context\"</span></span><br><span class=\"line\">    <span class=\"string\">\"google.golang.org/grpc\"</span></span><br><span class=\"line\">    pb <span class=\"string\">\"helloworld/helloworld\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">    address     = <span class=\"string\">\"localhost:50051\"</span></span><br><span class=\"line\">    defaultName = <span class=\"string\">\"world\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    conn, err := grpc.Dial(address, grpc.WithInsecure())</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(<span class=\"string\">\"did not connect: %v\"</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> conn.Close()</span><br><span class=\"line\">    c := pb.NewGreeterClient(conn)</span><br><span class=\"line\"> </span><br><span class=\"line\">    name := defaultName</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(os.Args) &gt;<span class=\"number\">1</span> &#123;</span><br><span class=\"line\">        name = os.Args[<span class=\"number\">1</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    r, err := c.SayHello(context.Background(), &amp;pb.HelloRequest&#123;Name: name&#125;)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(<span class=\"string\">\"could not greet: %v\"</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    log.Printf(<span class=\"string\">\"Greeting: %s\"</span>, r.Message)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里需要注意的是包pb是我们之前生成的helloworld.pb.go所在的包，<br>\n并非必须如上述代码所示在$GOPATH/src/helloworld/helloworld目录下</p>\n<h4><span id=\"7运行示例\">7.运行示例</span></h4>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go <span class=\"keyword\">run</span><span class=\"bash\"> server.go</span></span><br><span class=\"line\"><span class=\"bash\">go run client.go</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1>RPC入门</h1>\n<h2>RPC框架原理</h2>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RPC框架的目的就是让远程服务调用更加简单,透明，RPC框架负责屏蔽底层的传输方式<span class=\"comment\">(TCP或者UDP)</span>,</span><br><span class=\"line\">序列化方式<span class=\"comment\">(XML/JSON/二进制)</span>和通信细节。服务调用者可以向本地接口一样调用远程的服务提供者，</span><br><span class=\"line\">而不需要关心底层通信细节和调用过程.</span><br></pre></td></tr></table></figure>\n<p><img src=\"rpc%E5%8E%9F%E7%90%86%E5%9B%BE.png\" alt=\"rpc原理图\"></p>\n<h2>gRPC</h2>\n<h3>gRPC简介</h3>\n<figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gRPC 是一个高性能、开源和通用的 RPC 框架，面向服务端和移动端,基于HTTP/<span class=\"number\">2</span>设计.</span><br></pre></td></tr></table></figure>\n<p><img src=\"gRPC%E8%B0%83%E7%94%A8%E7%A4%BA%E4%BE%8B.png\" alt=\"gRPC调用示例\"></p>\n<h3>gRPC特点</h3>\n<p><img src=\"gRPC%E7%89%B9%E7%82%B9.png\" alt=\"gRPC特点\"></p>\n<h3>Golang gRPC 示例</h3>\n<h4>1、安装gRPC runtime</h4>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go get google<span class=\"selector-class\">.golang</span><span class=\"selector-class\">.org</span>/grpc</span><br></pre></td></tr></table></figure>\n<h4>2、protocal buffer安装</h4>\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">从https:<span class=\"comment\">//github.com/google/protobuf/releases下载安装包，</span></span><br><span class=\"line\">例如：protobuf-cpp<span class=\"number\">-3.0</span><span class=\"number\">.0</span>-<span class=\"built_in\">beta</span><span class=\"number\">-3.</span>zip，解压后</span><br><span class=\"line\">./configure</span><br><span class=\"line\"><span class=\"built_in\">make</span> &amp;&amp; <span class=\"built_in\">make</span> install</span><br><span class=\"line\">再添加环境变量：export LD_LIBRARY_PATH=/usr/<span class=\"keyword\">local</span>/<span class=\"keyword\">lib</span>，之后protoc命令即可运行</span><br></pre></td></tr></table></figure>\n<h4>3、安装GoLang protoc 插件</h4>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"built_in\">get</span> -<span class=\"keyword\">a</span> github.<span class=\"keyword\">com</span>/golang/protobuf/protoc-gen-<span class=\"keyword\">go</span></span><br></pre></td></tr></table></figure>\n<h4>4、定义service</h4>\n<p>一个RPC service就是一个能够通过参数和返回值进行远程调用的method，我们可以简单地将它理解成一个函数。因为gRPC是通过将数据编码成protocal buffer来实现传输的。因此，我们通过protocal buffers interface definitioin language(IDL)来定义service method，同时将参数和返回值也定义成protocal buffer message类型。具体实现如下所示，包含下面代码的文件叫helloworld.proto：</p>\n<figure class=\"highlight thrift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">syntax = <span class=\"string\">\"proto3\"</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">option java_package = <span class=\"string\">\"io.grpc.examples\"</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">package helloworld;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// The greeter service definition.</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">service</span> <span class=\"title\">Greeter</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Sends a greeting</span></span><br><span class=\"line\">  rpc SayHello (HelloRequest) returns (HelloReply) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// The request message containing the user's name.</span></span><br><span class=\"line\">message HelloRequest &#123;</span><br><span class=\"line\">  <span class=\"built_in\">string</span> name = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// The response message containing the greetings</span></span><br><span class=\"line\">message HelloReply &#123;</span><br><span class=\"line\">  <span class=\"built_in\">string</span> message = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4>5.生成Golang通用代码</h4>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">接着，根据上述定义的service，我们可以利用protocal buffer compiler ，</span><br><span class=\"line\">即protoc生成相应的服务器端和客户端的GoLang代码。生成的代码中包含了客户端能够进行RPC的方法以及服务器端需要进行实现的接口。</span><br><span class=\"line\">假设现在所在的目录是<span class=\"variable\">$GOPATH</span>/src/helloworld/helloworld，我们将通过如下命令生成gRPC对应的GoLang代码：</span><br><span class=\"line\">protoc -I ./ helloworld.proto <span class=\"attribute\">--go_out</span>=plugins=grpc:.</span><br></pre></td></tr></table></figure>\n<h4>6.生成相关的RPC的客户端和服务端</h4>\n<p>在目录$GOPATH/src/helloworld/下创建server.go 和client.go，分别用于服务器和客户端的实现</p>\n<h5>服务端代码</h5>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// server.go</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">\"log\"</span></span><br><span class=\"line\">    <span class=\"string\">\"net\"</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"string\">\"golang.org/x/net/context\"</span></span><br><span class=\"line\">    <span class=\"string\">\"google.golang.org/grpc\"</span></span><br><span class=\"line\">    pb <span class=\"string\">\"helloworld/helloworld\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">    port = <span class=\"string\">\":50051\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">type</span> server <span class=\"keyword\">struct</span> &#123;&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *server)</span> <span class=\"title\">SayHello</span><span class=\"params\">(ctx context.Context, in *pb.HelloRequest)</span> <span class=\"params\">(*pb.HelloReply, error)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;pb.HelloReply&#123;Message: <span class=\"string\">\"Hello \"</span> + in.Name&#125;, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    lis, err := net.Listen(<span class=\"string\">\"tcp\"</span>, port)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(<span class=\"string\">\"failed to listen: %v\"</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    s := grpc.NewServer()</span><br><span class=\"line\">    pb.RegisterGreeterServer(s, &amp;server&#123;&#125;)</span><br><span class=\"line\">    s.Serve(lis)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5>客户端代码</h5>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//client.go</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">\"log\"</span></span><br><span class=\"line\">    <span class=\"string\">\"os\"</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"string\">\"golang.org/x/net/context\"</span></span><br><span class=\"line\">    <span class=\"string\">\"google.golang.org/grpc\"</span></span><br><span class=\"line\">    pb <span class=\"string\">\"helloworld/helloworld\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">    address     = <span class=\"string\">\"localhost:50051\"</span></span><br><span class=\"line\">    defaultName = <span class=\"string\">\"world\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    conn, err := grpc.Dial(address, grpc.WithInsecure())</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(<span class=\"string\">\"did not connect: %v\"</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> conn.Close()</span><br><span class=\"line\">    c := pb.NewGreeterClient(conn)</span><br><span class=\"line\"> </span><br><span class=\"line\">    name := defaultName</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(os.Args) &gt;<span class=\"number\">1</span> &#123;</span><br><span class=\"line\">        name = os.Args[<span class=\"number\">1</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    r, err := c.SayHello(context.Background(), &amp;pb.HelloRequest&#123;Name: name&#125;)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(<span class=\"string\">\"could not greet: %v\"</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    log.Printf(<span class=\"string\">\"Greeting: %s\"</span>, r.Message)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里需要注意的是包pb是我们之前生成的helloworld.pb.go所在的包，<br>\n并非必须如上述代码所示在$GOPATH/src/helloworld/helloworld目录下</p>\n<h4>7.运行示例</h4>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go <span class=\"keyword\">run</span><span class=\"bash\"> server.go</span></span><br><span class=\"line\"><span class=\"bash\">go run client.go</span></span><br></pre></td></tr></table></figure>\n"},{"title":"微服务API网关框架(1)--介绍","catalog":true,"date":"2018-12-07T06:27:21.000Z","subtitle":null,"header-img":"Demo.png","catagories":["微服务API网关"],"_content":"\n# 概念介绍\n    \n### 网关作用\n    统一入口\n    安全：黑名单、权限身份认证\n    限流：实现微服务访问流量计算，基于流量计算分析进行限流，可以定义多种限流规则。\n    缓存：数据缓存\n    日志：日志记录\n    监控：记录请求响应数据，api耗时分析，性能监控\n    重试：异常重试\n    熔断：降级 (防止服务雪崩)\n    \n### API网关\n    API网关是一个服务器，是系统的唯一入口。从面向对象设计的角度看，它与外观模式类似。API网关封装了系统内部架构，为每个客户端提供一个定制的API。它可能还具有其它职责，如身份验证、监控、负载均衡、缓存、请求分片与管理、静态响应处理。\n    API网关方式的核心要点是，所有的客户端和消费端都通过统一的网关接入微服务，在网关层处理所有的非业务功能。通常，网关也是提供REST/HTTP的访问API。服务端通过API-GW注册和管理服务。\n\n### API网关种类\n1. 单节点网关\n![单节点场景网关](单节点场景网关.png)\n2.多节点网关\n![多节点场景网关](多节点场景网关.png)\n\n#### API网关网关的价值\n    网关层对外部和内部进行了隔离，保障了后台服务的安全性。 \n    对外访问控制由网络层面转换成了运维层面，减少变更的流程和错误成本 \n    减少客户端与服务的耦合，服务可以独立发展。通过网关层来做映射。 \n    通过网关层聚合，减少外部访问的频次，提升访问效率。 \n    节约后端服务开发成本，减少上线风险。 \n    为服务熔断，灰度发布，线上测试提供简单方案。\n\n## 开源微服务项目\n    Dubbo\n    Spring Cloud\n    \n## 开源网关项目\n    Tyk：Tyk是一个开放源码的API网关，它是快速、可扩展和现代的。Tyk提供了一个API管理平台，其中包括API网关、API分析、开发人员门户和API管理面板。Try 是一个基于Go实现的网关服务。\n    Kong：Kong是一个可扩展的开放源码API Layer(也称为API网关或API中间件)。Kong 在任何RESTful API的前面运行，通过插件扩展，它提供了超越核心平台的额外功能和服务。\n    Orange：和Kong类似也是基于OpenResty的一个API网关程序，是由国人开发的。\n    Netflix zuul：Zuul是一种提供动态路由、监视、弹性、安全性等功能的边缘服务。Zuul是Netflix出品的一个基于JVM路由和服务端的负载均衡器。\n    apiaxle: Nodejs 实现的一个 API 网关。\n    api-umbrella: Ruby 实现的一个 API 网关。\n\n## 网关技术选型\n    kong \n        包含功能\n        (\n            统一入口\n            安全：黑名单、权限身份认证\n            限流：实现微服务访问流量计算，基于流量计算分析进行限流，可以定义多种限流规则。\n            缓存：数据缓存\n            日志：日志记录\n            监控：记录请求响应数据，api耗时分析，性能监控\n        )\n    Zuul\n        包含功能\n        (\n            重试\n            熔断\n        )\n        \n    kong 是基于Nginx + Lua模式开发出来的，我们将要自己搭建一个属于自己的网关，所以采用Nginx + Lua，真实部署的时候可以\n    采用kong+zuul的模式进行实际部署，因为自己搭建的需要考虑的问题有很多，当然自己构建的话，灵活性和个性化设置也是可以控制的，\n    这个需要看看团队的实际需要，客观进行评估.\n       \n### 架构实现图\n![架构](架构.png)\n![架构2](架构2.png)\n![架构3](架构3.png)\n\n### 项目运行环境\n    CentOS\n\n### Nginx安装\n    1、Nginx下载：nginx-1.13.0.tar.gz，下载到：/opt/softwares/\n        $ wget http://nginx.org/download/nginx-1.13.0.tar.gz\n    2、Nginx解压安装：\n        $ tar -zxvf nginx-1.13.0.tar.gz -C ./\n    3、预先安装(nginx所需要的运行库)\n        $ yum -y install gcc gcc-c++ ncurses-devel perl pcre pcre-devel zlib gzip zlib-devel\n    4、Nginx编译\n        $ ./configure --prefix=/usr/local/nginx\n    5、安装Nginx：\n        安装命令：make & make install\n    6、查看安装路径\n        $ cd /usr/local/nginx\n        $ ll\n        \n        // 文件夹路径解读\n        conf 存放配置文件\n        html 网页文件\n        logs 存放日志\n        sbin   shell启动、停止等脚本\n    7、启动nginx\n        $ cd sbin\n        $ ./nginx\n    8、浏览器，访问ip地址，默认80端口\n        http://127.0.0.1\n    9、停止nginx\n        // 查询nginx的状态\n        $ ps -ef | grep nginx\n        执行命令：$ kill –INT 进程号\n        $ kill -INT 3844\n    \n        $ ./nginx -s stop\n    \n    10、重新读取配置文件\n        $ nginx -s reload\n    \n    11、检查配置文件是否正确\n    $ ./nginx -t\n    \n    问题报错：[error] invalid PID number \"\" in \"/usr/local/nginx/logs/nginx.pid\"\n    \n    解决方案:\n    // 注意: -c 带的文件路径必须是绝对路径，相对路径是不行的\n    # /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf\n        -c的命令是指定配置文件位置\n\n## 代理\n\n### 正向代理\n    用户要访问服务器C，但因为网络原因无法访问，但是服务器A可以访问服务器C，这样可以把服务器A设置为正向代理服务器\n    由服务器A去请求服务器C，然后服务器A把数据返回给客户\n![正向代理](正向代理.png)\n\n### 反向代理\n    用户需要访问一些服务器应用，但对方不想把服务器应用地址暴露给用户，这样可以确保安全。那客户如果访问，可以通过反向代理\n    服务器，用户只需要知道反向代理服务器地址就可以了，最后反向代理服务器去访问服务器的应用\n![反向代理](反向代理.png)    \n\n### 总结: 正向代理与反向代理的区别\n    (1)正向代理是需要在用户的电脑上，配置正向服务代理器的；而反向代理则不需要，因为用户是直接访问反向代理器的\n    (2)正向代理的应用场景是用户是知道目标服务器地址，如:http://www.baidu.com,但是不能直接的访问，那么就需要在电脑配置一个正向\n    代理服务器，用户再次访问的地址就是www.google.com\n      而反向代理的应用场景是，用户本来就是不知道目标服务器的地址，而是由平台方提供一个反向代理服务器的地址，用户直接访问反向代理服务器的地址就行了，www.a.com\n      不管目标服务器有多少，用户是不需要关心的，只要访问反向代理服务器就OK，由反向代理服务器去解析访问目标服务器\n    (3)反向代理，极大的保护了应用的安全性，而且此结构能够很好的搭建负载均衡  \n\n","source":"_posts/微服务API网关框架-1.md","raw":"---\ntitle: 微服务API网关框架(1)--介绍\ncatalog: true\ndate: 2018-12-07 14:27:21\nsubtitle:\nheader-img: \"Demo.png\"\ntags:\n- 微服务API网关\ncatagories:\n- 微服务API网关\n---\n\n# 概念介绍\n    \n### 网关作用\n    统一入口\n    安全：黑名单、权限身份认证\n    限流：实现微服务访问流量计算，基于流量计算分析进行限流，可以定义多种限流规则。\n    缓存：数据缓存\n    日志：日志记录\n    监控：记录请求响应数据，api耗时分析，性能监控\n    重试：异常重试\n    熔断：降级 (防止服务雪崩)\n    \n### API网关\n    API网关是一个服务器，是系统的唯一入口。从面向对象设计的角度看，它与外观模式类似。API网关封装了系统内部架构，为每个客户端提供一个定制的API。它可能还具有其它职责，如身份验证、监控、负载均衡、缓存、请求分片与管理、静态响应处理。\n    API网关方式的核心要点是，所有的客户端和消费端都通过统一的网关接入微服务，在网关层处理所有的非业务功能。通常，网关也是提供REST/HTTP的访问API。服务端通过API-GW注册和管理服务。\n\n### API网关种类\n1. 单节点网关\n![单节点场景网关](单节点场景网关.png)\n2.多节点网关\n![多节点场景网关](多节点场景网关.png)\n\n#### API网关网关的价值\n    网关层对外部和内部进行了隔离，保障了后台服务的安全性。 \n    对外访问控制由网络层面转换成了运维层面，减少变更的流程和错误成本 \n    减少客户端与服务的耦合，服务可以独立发展。通过网关层来做映射。 \n    通过网关层聚合，减少外部访问的频次，提升访问效率。 \n    节约后端服务开发成本，减少上线风险。 \n    为服务熔断，灰度发布，线上测试提供简单方案。\n\n## 开源微服务项目\n    Dubbo\n    Spring Cloud\n    \n## 开源网关项目\n    Tyk：Tyk是一个开放源码的API网关，它是快速、可扩展和现代的。Tyk提供了一个API管理平台，其中包括API网关、API分析、开发人员门户和API管理面板。Try 是一个基于Go实现的网关服务。\n    Kong：Kong是一个可扩展的开放源码API Layer(也称为API网关或API中间件)。Kong 在任何RESTful API的前面运行，通过插件扩展，它提供了超越核心平台的额外功能和服务。\n    Orange：和Kong类似也是基于OpenResty的一个API网关程序，是由国人开发的。\n    Netflix zuul：Zuul是一种提供动态路由、监视、弹性、安全性等功能的边缘服务。Zuul是Netflix出品的一个基于JVM路由和服务端的负载均衡器。\n    apiaxle: Nodejs 实现的一个 API 网关。\n    api-umbrella: Ruby 实现的一个 API 网关。\n\n## 网关技术选型\n    kong \n        包含功能\n        (\n            统一入口\n            安全：黑名单、权限身份认证\n            限流：实现微服务访问流量计算，基于流量计算分析进行限流，可以定义多种限流规则。\n            缓存：数据缓存\n            日志：日志记录\n            监控：记录请求响应数据，api耗时分析，性能监控\n        )\n    Zuul\n        包含功能\n        (\n            重试\n            熔断\n        )\n        \n    kong 是基于Nginx + Lua模式开发出来的，我们将要自己搭建一个属于自己的网关，所以采用Nginx + Lua，真实部署的时候可以\n    采用kong+zuul的模式进行实际部署，因为自己搭建的需要考虑的问题有很多，当然自己构建的话，灵活性和个性化设置也是可以控制的，\n    这个需要看看团队的实际需要，客观进行评估.\n       \n### 架构实现图\n![架构](架构.png)\n![架构2](架构2.png)\n![架构3](架构3.png)\n\n### 项目运行环境\n    CentOS\n\n### Nginx安装\n    1、Nginx下载：nginx-1.13.0.tar.gz，下载到：/opt/softwares/\n        $ wget http://nginx.org/download/nginx-1.13.0.tar.gz\n    2、Nginx解压安装：\n        $ tar -zxvf nginx-1.13.0.tar.gz -C ./\n    3、预先安装(nginx所需要的运行库)\n        $ yum -y install gcc gcc-c++ ncurses-devel perl pcre pcre-devel zlib gzip zlib-devel\n    4、Nginx编译\n        $ ./configure --prefix=/usr/local/nginx\n    5、安装Nginx：\n        安装命令：make & make install\n    6、查看安装路径\n        $ cd /usr/local/nginx\n        $ ll\n        \n        // 文件夹路径解读\n        conf 存放配置文件\n        html 网页文件\n        logs 存放日志\n        sbin   shell启动、停止等脚本\n    7、启动nginx\n        $ cd sbin\n        $ ./nginx\n    8、浏览器，访问ip地址，默认80端口\n        http://127.0.0.1\n    9、停止nginx\n        // 查询nginx的状态\n        $ ps -ef | grep nginx\n        执行命令：$ kill –INT 进程号\n        $ kill -INT 3844\n    \n        $ ./nginx -s stop\n    \n    10、重新读取配置文件\n        $ nginx -s reload\n    \n    11、检查配置文件是否正确\n    $ ./nginx -t\n    \n    问题报错：[error] invalid PID number \"\" in \"/usr/local/nginx/logs/nginx.pid\"\n    \n    解决方案:\n    // 注意: -c 带的文件路径必须是绝对路径，相对路径是不行的\n    # /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf\n        -c的命令是指定配置文件位置\n\n## 代理\n\n### 正向代理\n    用户要访问服务器C，但因为网络原因无法访问，但是服务器A可以访问服务器C，这样可以把服务器A设置为正向代理服务器\n    由服务器A去请求服务器C，然后服务器A把数据返回给客户\n![正向代理](正向代理.png)\n\n### 反向代理\n    用户需要访问一些服务器应用，但对方不想把服务器应用地址暴露给用户，这样可以确保安全。那客户如果访问，可以通过反向代理\n    服务器，用户只需要知道反向代理服务器地址就可以了，最后反向代理服务器去访问服务器的应用\n![反向代理](反向代理.png)    \n\n### 总结: 正向代理与反向代理的区别\n    (1)正向代理是需要在用户的电脑上，配置正向服务代理器的；而反向代理则不需要，因为用户是直接访问反向代理器的\n    (2)正向代理的应用场景是用户是知道目标服务器地址，如:http://www.baidu.com,但是不能直接的访问，那么就需要在电脑配置一个正向\n    代理服务器，用户再次访问的地址就是www.google.com\n      而反向代理的应用场景是，用户本来就是不知道目标服务器的地址，而是由平台方提供一个反向代理服务器的地址，用户直接访问反向代理服务器的地址就行了，www.a.com\n      不管目标服务器有多少，用户是不需要关心的，只要访问反向代理服务器就OK，由反向代理服务器去解析访问目标服务器\n    (3)反向代理，极大的保护了应用的安全性，而且此结构能够很好的搭建负载均衡  \n\n","slug":"微服务API网关框架-1","published":1,"updated":"2018-12-19T08:45:39.151Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpw2eyfp0006n0ujay58202c","content":"<h1><span id=\"概念介绍\">概念介绍</span></h1>\n<h3><span id=\"网关作用\">网关作用</span></h3>\n<pre><code>统一入口\n安全：黑名单、权限身份认证\n限流：实现微服务访问流量计算，基于流量计算分析进行限流，可以定义多种限流规则。\n缓存：数据缓存\n日志：日志记录\n监控：记录请求响应数据，api耗时分析，性能监控\n重试：异常重试\n熔断：降级 (防止服务雪崩)\n</code></pre>\n<h3><span id=\"api网关\">API网关</span></h3>\n<pre><code>API网关是一个服务器，是系统的唯一入口。从面向对象设计的角度看，它与外观模式类似。API网关封装了系统内部架构，为每个客户端提供一个定制的API。它可能还具有其它职责，如身份验证、监控、负载均衡、缓存、请求分片与管理、静态响应处理。\nAPI网关方式的核心要点是，所有的客户端和消费端都通过统一的网关接入微服务，在网关层处理所有的非业务功能。通常，网关也是提供REST/HTTP的访问API。服务端通过API-GW注册和管理服务。\n</code></pre>\n<h3><span id=\"api网关种类\">API网关种类</span></h3>\n<ol>\n<li>单节点网关<br>\n<img src=\"%E5%8D%95%E8%8A%82%E7%82%B9%E5%9C%BA%E6%99%AF%E7%BD%91%E5%85%B3.png\" alt=\"单节点场景网关\"><br>\n2.多节点网关<br>\n<img src=\"%E5%A4%9A%E8%8A%82%E7%82%B9%E5%9C%BA%E6%99%AF%E7%BD%91%E5%85%B3.png\" alt=\"多节点场景网关\"></li>\n</ol>\n<h4><span id=\"api网关网关的价值\">API网关网关的价值</span></h4>\n<pre><code>网关层对外部和内部进行了隔离，保障了后台服务的安全性。 \n对外访问控制由网络层面转换成了运维层面，减少变更的流程和错误成本 \n减少客户端与服务的耦合，服务可以独立发展。通过网关层来做映射。 \n通过网关层聚合，减少外部访问的频次，提升访问效率。 \n节约后端服务开发成本，减少上线风险。 \n为服务熔断，灰度发布，线上测试提供简单方案。\n</code></pre>\n<h2><span id=\"开源微服务项目\">开源微服务项目</span></h2>\n<pre><code>Dubbo\nSpring Cloud\n</code></pre>\n<h2><span id=\"开源网关项目\">开源网关项目</span></h2>\n<pre><code>Tyk：Tyk是一个开放源码的API网关，它是快速、可扩展和现代的。Tyk提供了一个API管理平台，其中包括API网关、API分析、开发人员门户和API管理面板。Try 是一个基于Go实现的网关服务。\nKong：Kong是一个可扩展的开放源码API Layer(也称为API网关或API中间件)。Kong 在任何RESTful API的前面运行，通过插件扩展，它提供了超越核心平台的额外功能和服务。\nOrange：和Kong类似也是基于OpenResty的一个API网关程序，是由国人开发的。\nNetflix zuul：Zuul是一种提供动态路由、监视、弹性、安全性等功能的边缘服务。Zuul是Netflix出品的一个基于JVM路由和服务端的负载均衡器。\napiaxle: Nodejs 实现的一个 API 网关。\napi-umbrella: Ruby 实现的一个 API 网关。\n</code></pre>\n<h2><span id=\"网关技术选型\">网关技术选型</span></h2>\n<pre><code>kong \n    包含功能\n    (\n        统一入口\n        安全：黑名单、权限身份认证\n        限流：实现微服务访问流量计算，基于流量计算分析进行限流，可以定义多种限流规则。\n        缓存：数据缓存\n        日志：日志记录\n        监控：记录请求响应数据，api耗时分析，性能监控\n    )\nZuul\n    包含功能\n    (\n        重试\n        熔断\n    )\n    \nkong 是基于Nginx + Lua模式开发出来的，我们将要自己搭建一个属于自己的网关，所以采用Nginx + Lua，真实部署的时候可以\n采用kong+zuul的模式进行实际部署，因为自己搭建的需要考虑的问题有很多，当然自己构建的话，灵活性和个性化设置也是可以控制的，\n这个需要看看团队的实际需要，客观进行评估.\n</code></pre>\n<h3><span id=\"架构实现图\">架构实现图</span></h3>\n<p><img src=\"%E6%9E%B6%E6%9E%84.png\" alt=\"架构\"><br>\n<img src=\"%E6%9E%B6%E6%9E%842.png\" alt=\"架构2\"><br>\n<img src=\"%E6%9E%B6%E6%9E%843.png\" alt=\"架构3\"></p>\n<h3><span id=\"项目运行环境\">项目运行环境</span></h3>\n<pre><code>CentOS\n</code></pre>\n<h3><span id=\"nginx安装\">Nginx安装</span></h3>\n<pre><code>1、Nginx下载：nginx-1.13.0.tar.gz，下载到：/opt/softwares/\n    $ wget http://nginx.org/download/nginx-1.13.0.tar.gz\n2、Nginx解压安装：\n    $ tar -zxvf nginx-1.13.0.tar.gz -C ./\n3、预先安装(nginx所需要的运行库)\n    $ yum -y install gcc gcc-c++ ncurses-devel perl pcre pcre-devel zlib gzip zlib-devel\n4、Nginx编译\n    $ ./configure --prefix=/usr/local/nginx\n5、安装Nginx：\n    安装命令：make &amp; make install\n6、查看安装路径\n    $ cd /usr/local/nginx\n    $ ll\n    \n    // 文件夹路径解读\n    conf 存放配置文件\n    html 网页文件\n    logs 存放日志\n    sbin   shell启动、停止等脚本\n7、启动nginx\n    $ cd sbin\n    $ ./nginx\n8、浏览器，访问ip地址，默认80端口\n    http://127.0.0.1\n9、停止nginx\n    // 查询nginx的状态\n    $ ps -ef | grep nginx\n    执行命令：$ kill –INT 进程号\n    $ kill -INT 3844\n\n    $ ./nginx -s stop\n\n10、重新读取配置文件\n    $ nginx -s reload\n\n11、检查配置文件是否正确\n$ ./nginx -t\n\n问题报错：[error] invalid PID number &quot;&quot; in &quot;/usr/local/nginx/logs/nginx.pid&quot;\n\n解决方案:\n// 注意: -c 带的文件路径必须是绝对路径，相对路径是不行的\n# /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf\n    -c的命令是指定配置文件位置\n</code></pre>\n<h2><span id=\"代理\">代理</span></h2>\n<h3><span id=\"正向代理\">正向代理</span></h3>\n<pre><code>用户要访问服务器C，但因为网络原因无法访问，但是服务器A可以访问服务器C，这样可以把服务器A设置为正向代理服务器\n由服务器A去请求服务器C，然后服务器A把数据返回给客户\n</code></pre>\n<p><img src=\"%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86.png\" alt=\"正向代理\"></p>\n<h3><span id=\"反向代理\">反向代理</span></h3>\n<pre><code>用户需要访问一些服务器应用，但对方不想把服务器应用地址暴露给用户，这样可以确保安全。那客户如果访问，可以通过反向代理\n服务器，用户只需要知道反向代理服务器地址就可以了，最后反向代理服务器去访问服务器的应用\n</code></pre>\n<p><img src=\"%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86.png\" alt=\"反向代理\"></p>\n<h3><span id=\"总结-正向代理与反向代理的区别\">总结: 正向代理与反向代理的区别</span></h3>\n<pre><code>(1)正向代理是需要在用户的电脑上，配置正向服务代理器的；而反向代理则不需要，因为用户是直接访问反向代理器的\n(2)正向代理的应用场景是用户是知道目标服务器地址，如:http://www.baidu.com,但是不能直接的访问，那么就需要在电脑配置一个正向\n代理服务器，用户再次访问的地址就是www.google.com\n  而反向代理的应用场景是，用户本来就是不知道目标服务器的地址，而是由平台方提供一个反向代理服务器的地址，用户直接访问反向代理服务器的地址就行了，www.a.com\n  不管目标服务器有多少，用户是不需要关心的，只要访问反向代理服务器就OK，由反向代理服务器去解析访问目标服务器\n(3)反向代理，极大的保护了应用的安全性，而且此结构能够很好的搭建负载均衡\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1>概念介绍</h1>\n<h3>网关作用</h3>\n<pre><code>统一入口\n安全：黑名单、权限身份认证\n限流：实现微服务访问流量计算，基于流量计算分析进行限流，可以定义多种限流规则。\n缓存：数据缓存\n日志：日志记录\n监控：记录请求响应数据，api耗时分析，性能监控\n重试：异常重试\n熔断：降级 (防止服务雪崩)\n</code></pre>\n<h3>API网关</h3>\n<pre><code>API网关是一个服务器，是系统的唯一入口。从面向对象设计的角度看，它与外观模式类似。API网关封装了系统内部架构，为每个客户端提供一个定制的API。它可能还具有其它职责，如身份验证、监控、负载均衡、缓存、请求分片与管理、静态响应处理。\nAPI网关方式的核心要点是，所有的客户端和消费端都通过统一的网关接入微服务，在网关层处理所有的非业务功能。通常，网关也是提供REST/HTTP的访问API。服务端通过API-GW注册和管理服务。\n</code></pre>\n<h3>API网关种类</h3>\n<ol>\n<li>单节点网关<br>\n<img src=\"%E5%8D%95%E8%8A%82%E7%82%B9%E5%9C%BA%E6%99%AF%E7%BD%91%E5%85%B3.png\" alt=\"单节点场景网关\"><br>\n2.多节点网关<br>\n<img src=\"%E5%A4%9A%E8%8A%82%E7%82%B9%E5%9C%BA%E6%99%AF%E7%BD%91%E5%85%B3.png\" alt=\"多节点场景网关\"></li>\n</ol>\n<h4>API网关网关的价值</h4>\n<pre><code>网关层对外部和内部进行了隔离，保障了后台服务的安全性。 \n对外访问控制由网络层面转换成了运维层面，减少变更的流程和错误成本 \n减少客户端与服务的耦合，服务可以独立发展。通过网关层来做映射。 \n通过网关层聚合，减少外部访问的频次，提升访问效率。 \n节约后端服务开发成本，减少上线风险。 \n为服务熔断，灰度发布，线上测试提供简单方案。\n</code></pre>\n<h2>开源微服务项目</h2>\n<pre><code>Dubbo\nSpring Cloud\n</code></pre>\n<h2>开源网关项目</h2>\n<pre><code>Tyk：Tyk是一个开放源码的API网关，它是快速、可扩展和现代的。Tyk提供了一个API管理平台，其中包括API网关、API分析、开发人员门户和API管理面板。Try 是一个基于Go实现的网关服务。\nKong：Kong是一个可扩展的开放源码API Layer(也称为API网关或API中间件)。Kong 在任何RESTful API的前面运行，通过插件扩展，它提供了超越核心平台的额外功能和服务。\nOrange：和Kong类似也是基于OpenResty的一个API网关程序，是由国人开发的。\nNetflix zuul：Zuul是一种提供动态路由、监视、弹性、安全性等功能的边缘服务。Zuul是Netflix出品的一个基于JVM路由和服务端的负载均衡器。\napiaxle: Nodejs 实现的一个 API 网关。\napi-umbrella: Ruby 实现的一个 API 网关。\n</code></pre>\n<h2>网关技术选型</h2>\n<pre><code>kong \n    包含功能\n    (\n        统一入口\n        安全：黑名单、权限身份认证\n        限流：实现微服务访问流量计算，基于流量计算分析进行限流，可以定义多种限流规则。\n        缓存：数据缓存\n        日志：日志记录\n        监控：记录请求响应数据，api耗时分析，性能监控\n    )\nZuul\n    包含功能\n    (\n        重试\n        熔断\n    )\n    \nkong 是基于Nginx + Lua模式开发出来的，我们将要自己搭建一个属于自己的网关，所以采用Nginx + Lua，真实部署的时候可以\n采用kong+zuul的模式进行实际部署，因为自己搭建的需要考虑的问题有很多，当然自己构建的话，灵活性和个性化设置也是可以控制的，\n这个需要看看团队的实际需要，客观进行评估.\n</code></pre>\n<h3>架构实现图</h3>\n<p><img src=\"%E6%9E%B6%E6%9E%84.png\" alt=\"架构\"><br>\n<img src=\"%E6%9E%B6%E6%9E%842.png\" alt=\"架构2\"><br>\n<img src=\"%E6%9E%B6%E6%9E%843.png\" alt=\"架构3\"></p>\n<h3>项目运行环境</h3>\n<pre><code>CentOS\n</code></pre>\n<h3>Nginx安装</h3>\n<pre><code>1、Nginx下载：nginx-1.13.0.tar.gz，下载到：/opt/softwares/\n    $ wget http://nginx.org/download/nginx-1.13.0.tar.gz\n2、Nginx解压安装：\n    $ tar -zxvf nginx-1.13.0.tar.gz -C ./\n3、预先安装(nginx所需要的运行库)\n    $ yum -y install gcc gcc-c++ ncurses-devel perl pcre pcre-devel zlib gzip zlib-devel\n4、Nginx编译\n    $ ./configure --prefix=/usr/local/nginx\n5、安装Nginx：\n    安装命令：make &amp; make install\n6、查看安装路径\n    $ cd /usr/local/nginx\n    $ ll\n    \n    // 文件夹路径解读\n    conf 存放配置文件\n    html 网页文件\n    logs 存放日志\n    sbin   shell启动、停止等脚本\n7、启动nginx\n    $ cd sbin\n    $ ./nginx\n8、浏览器，访问ip地址，默认80端口\n    http://127.0.0.1\n9、停止nginx\n    // 查询nginx的状态\n    $ ps -ef | grep nginx\n    执行命令：$ kill –INT 进程号\n    $ kill -INT 3844\n\n    $ ./nginx -s stop\n\n10、重新读取配置文件\n    $ nginx -s reload\n\n11、检查配置文件是否正确\n$ ./nginx -t\n\n问题报错：[error] invalid PID number &quot;&quot; in &quot;/usr/local/nginx/logs/nginx.pid&quot;\n\n解决方案:\n// 注意: -c 带的文件路径必须是绝对路径，相对路径是不行的\n# /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf\n    -c的命令是指定配置文件位置\n</code></pre>\n<h2>代理</h2>\n<h3>正向代理</h3>\n<pre><code>用户要访问服务器C，但因为网络原因无法访问，但是服务器A可以访问服务器C，这样可以把服务器A设置为正向代理服务器\n由服务器A去请求服务器C，然后服务器A把数据返回给客户\n</code></pre>\n<p><img src=\"%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86.png\" alt=\"正向代理\"></p>\n<h3>反向代理</h3>\n<pre><code>用户需要访问一些服务器应用，但对方不想把服务器应用地址暴露给用户，这样可以确保安全。那客户如果访问，可以通过反向代理\n服务器，用户只需要知道反向代理服务器地址就可以了，最后反向代理服务器去访问服务器的应用\n</code></pre>\n<p><img src=\"%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86.png\" alt=\"反向代理\"></p>\n<h3>总结: 正向代理与反向代理的区别</h3>\n<pre><code>(1)正向代理是需要在用户的电脑上，配置正向服务代理器的；而反向代理则不需要，因为用户是直接访问反向代理器的\n(2)正向代理的应用场景是用户是知道目标服务器地址，如:http://www.baidu.com,但是不能直接的访问，那么就需要在电脑配置一个正向\n代理服务器，用户再次访问的地址就是www.google.com\n  而反向代理的应用场景是，用户本来就是不知道目标服务器的地址，而是由平台方提供一个反向代理服务器的地址，用户直接访问反向代理服务器的地址就行了，www.a.com\n  不管目标服务器有多少，用户是不需要关心的，只要访问反向代理服务器就OK，由反向代理服务器去解析访问目标服务器\n(3)反向代理，极大的保护了应用的安全性，而且此结构能够很好的搭建负载均衡\n</code></pre>\n"},{"title":"微服务API网关框架(3)--Lua基本语法","catalog":true,"date":"2018-12-20T02:47:23.000Z","subtitle":null,"header-img":"Demo.png","catagories":["微服务API网关"],"_content":"\n# Lua基本语法\n\n### 编程模式\n    1. 交互式编程 (shell)\n        与python的shell使用方法一致，直接在终端下运行lua命令即可\n    2. 脚本式编程\n        创建xxxx.lua文件，然后使用lua xxxx.lua命令或者是luajit xxxx.lua文件即可进行运行\n           \n### 注释\n    1.单行注释\n        --\n    2.多行注释\n        --[[\n        多行注释\n        多行注释\n        --]]   \n        \n### 标示符\n    Lua 是一个区分大小写的编程语言\n    Lua 标示符用于定义一个变量，函数获取其他用户定义的项。标示符以一个字母 A 到 Z 或 a 到 z 或下划线 _ 开头后加上0个或多个字母，下划线，数字(0到9)\n    Lua 不允许使用特殊字符如 @, $, 和 % 来定义标示符\n    最好不要使用下划线加大写字母的标示符，因为Lua的保留字也是这样的\n    一般约定，以下划线开头连接一串大写字母的名字（比如 _VERSION）被保留用于 Lua 内部全局变量\n\n### 关键词\n    and    break    do    else\n    elseif    end    false    for\n    function    if    in    local\n    nil    not    or    repeat\n    return    then    true    until\n    while\n\n### 变量\n    Lua 变量有三种类型：全局变量、局部变量、表中的域\n    变量在使用前，必须在代码中进行声明，即创建该变量\n    变量的默认值均为 nil。\n\n    1.全局变量\n        (1)在默认情况下，变量总是认为是全局的。\n        (2)全局变量不需要声明，给一个变量赋值后即创建了这个全局变量，访问一个没有初始化的全局变量也不会出错，只不过得到的结果是：nil。\n        (3)如果你想删除一个全局变量，只需要将变量赋值为nil。\n        (4)Lua 中的变量全是全局变量，那怕是语句块或是函数里，除非用 local 显式声明为局部变量。\n    2.局部变量\n        局部变量的作用域为从声明位置开始到所在语句块结束。\n    3.表中的域\n    \n#### 赋值\n    1. 使用\"=\"号进行赋值\n    2. Lua可以对多个变量同时赋值，变量列表和值列表的各个元素用逗号分开，赋值语句右边的值会依次赋给左边的变量\n        a,b=21,22\n    3. 赋值语句Lua会先计算右边所有的值然后再执行赋值操作，所以我们可以这样进行交换变量的值\n        x, y = y, x                     -- swap 'x' for 'y'\n        a[i], a[j] = a[j], a[i]         -- swap 'a[i]' for 'a[j]'  \n    4. 重点: 当变量个数和值的个数不一致时，Lua会一直以变量个数为基础采取以下策略\n        a. 变量个数 > 值的个数             按变量个数补足nil\n        b. 变量个数 < 值的个数             多余的值会被忽略\n        \n        a, b, c = 0, 1\n        print(a,b,c)             --> 0   1   nil  \n        \n        a, b = a+1, b+1, b+2     -- value of b+2 is ignored\n        print(a,b)               --> 1   2\n        \n        a, b, c = 0\n        print(a,b,c)             --> 0   nil   nil\n    5. 多值赋值经常用来交换变量，或将函数调用返回给变量\n           a, b = f()\n           f()返回两个值，第一个赋给a，第二个赋给b。\n           应该尽可能的使用局部变量，有两个好处：\n               1. 避免命名冲突。\n               2. 访问局部变量的速度比全局变量更快。\n### 数据类型\n    Lua是动态类型语言，变量不要类型定义,只需要为变量赋值。 值可以存储在变量中，作为参数传递或结果返回。\n    Lua中有8个基本类型分别为：nil、boolean、number、string、userdata、function、thread和table。\n\n    数据类型\t描述\n    nil\t            这个最简单，只有值nil属于该类，表示一个无效值（在条件表达式中相当于false）。\n    boolean\t        包含两个值：false和true。Lua认为false和nil为\"假\",其他任何值都是\"真\",包括0\n    number\t        表示双精度类型的实浮点数\n    string\t        字符串由一对双引号或单引号来表示\n    function\t    由 C 或 Lua 编写的函数\n    userdata\t    表示任意存储在变量中的C数据结构\n    thread\t        表示执行的独立线路，用于执行协同程序\n    table\t        Lua 中的表（table）其实是一个\"关联数组\"（associative arrays），数组的索引可以是数字或者是字符串。在 Lua 里，table 的创建是通过\"构造表达式\"来完成，最简单构造表达式是{}，用来创建一个空表。\n\n#### 获取数据的类型\n    重点: type(xxx) -- 返回的都是字符串形式的数据类型\n          type(type(xxx)) == \"string\"\n    \n    print(type(\"Hello world\"))      --> string      \n    print(type(10.4*3))             --> number\n    print(type(print))              --> function\n    print(type(type))               --> function\n    print(type(true))               --> boolean\n    print(type(nil))                --> nil\n    print(type(type(X)))            --> string\n\n#### 获取当前变量的数据类型是否与设想的一致\n    v = \"Hello World.\"\n    if type(v) == \"string\"\n    then\n        print(\"字符串类型\")\n    end\n\n#### nil (空值)\n    nil 类型表示一种没有任何有效值，它只有一个值 -- nil\n    作用:对于全局变量和 table，nil 还有一个\"删除\"作用，给全局变量或者 table 表里的变量赋一个 nil 值，等同于把它们删掉\n       \n        例子:\n            tab1 = { key1 = \"val1\", key2 = \"val2\", \"val3\" }\n            for k, v in pairs(tab1) do\n                print(k .. \" - \" .. v)\n            end\n             \n            tab1.key1 = nil\n            for k, v in pairs(tab1) do\n                print(k .. \" - \" .. v)\n            end\n\n#### boolean(布尔值)\n    boolean 类型只有两个可选值：true（真） 和 false（假），Lua 把 false 和 nil 看作是\"假\"，其他的都为\"真\",包括\"0\"也是真\n    \n#### number(数字)\n    Lua 默认只有一种 number 类型 -- double（双精度）类型（默认类型可以修改 luaconf.h 里的定义）\n    \n#### string(字符串)\n    1. 字符串由一对双引号或单引号来表示。\n        string1 = \"this is string1\"\n        string2 = 'this is string2'\n    2. 两个方括号 \"[[]]\" 来表示\"一块\"字符串,用于多行文本 \n        html = [[\n        <html>\n        <head></head>\n        <body>\n            <a href=\"http://www.runoob.com/\">菜鸟教程</a>\n        </body>\n        </html>\n        ]]\n    3. 在对一个数字字符串上进行算术操作时，Lua 会尝试将这个数字字符串转成一个数字\n        > print(\"2\" + 6)\n        8.0\n        > print(\"2\" + \"6\")\n        8.0\n        > print(\"2 + 6\")\n        2 + 6\n        > print(\"-2e2\" * \"6\")\n        -1200.0\n    4. 字符串连接符\"..\"\n         > print(\"a\" .. 'b')\n         ab\n         > print(157 .. 428)\n         157428\n         > \n    5. 计算字符串长度\n         > len = \"www.runoob.com\"\n         > print(#len)\n         14\n         > print(#\"www.runoob.com\")\n         14\n\n##### 字符串用法拓展\n    1. 常规的转义符号\n        \\a  响铃(BEL)\n        \\b  退格(BS) ，将当前位置移到前一列\n        \\f  换页(FF)，将当前位置移到下页开头\n        \\n  换行(LF) ，将当前位置移到下一行开头\n        \\r  回车(CR) ，将当前位置移到本行开头\n        \\t  水平制表(HT) （跳到下一个TAB位置）\n        \\v  垂直制表(VT)\n        \\\\  代表一个反斜线字符''\\'\n        \\'  代表一个单引号（撇号）字符\n        \\\"  代表一个双引号字符\n        \\0  空字符(NULL)\n        \\ddd    1到3位八进制数所代表的任意字符\n        \\xhh    1到2位十六进制所代表的任意字符\n    \n    2. 字符串操作\n        (1)string.upper(argument):字符串全部转为大写字母  \n        (2)string.lower(argument):字符串全部转为小写字母\n        (3)string.gsub(mainString,findString,replaceString,num):在字符串中替换,mainString为要替换的字符串， findString 为被替换的字符，replaceString 要替换的字符，num 替换次数（可以忽略，则全部替换）\n            > string.gsub(\"aaaa\",\"a\",\"z\",3);\n            zzza    3\n        (4)string.find (str, substr, [init, [end]]):在一个指定的目标字符串中搜索指定的内容(第三个参数为索引),返回其具体位置。不存在则返回 nil\n            > string.find(\"Hello Lua user\", \"Lua\", 1) \n            7    9\n        (5)string.reverse(arg):字符串反转    \n        (6)string.format(...):返回一个类似printf的格式化字符串\n            > string.format(\"the value is:%d\",4)\n            the value is:4\n        (7)string.char(arg) 和 string.byte(arg[,int]): char 将整型数字转成字符并连接， byte 转换字符为整数值(可以指定某个字符，默认第一个字符)。\n            > string.char(97,98,99,100)\n            abcd\n            > string.byte(\"ABCD\",4)\n            68\n            > string.byte(\"ABCD\")\n            65\n        (8)string.len(arg):计算字符串长度。\n        (9)string.rep(string, n):返回字符串string的n个拷贝\n        (10)\"..\" 符号: 链接两个字符串\n        (11)string.gmatch(str, pattern):回一个迭代器函数，每一次调用这个函数，返回一个在字符串 str 找到的下一个符合 pattern 描述的子串。如果参数 pattern 描述的字符串没有找到，迭代函数返回nil。\n            > for word in string.gmatch(\"Hello Lua user\", \"%a+\") do print(word) end\n            Hello\n            Lua\n            user\n        (12)string.match(str, pattern, init):string.match()只寻找源字串str中的第一个配对. 参数init可选, 指定搜寻过程的起点, 默认为1。 \n                                            在成功配对时, 函数将返回配对表达式中的所有捕获结果; 如果没有设置捕获标记, 则返回整个配对字符串. 当没有成功的配对时, 返回nil。\n             > = string.match(\"I have 2 questions for you.\", \"%d+ %a+\")\n             2 questions\n             > = string.format(\"%d, %q\", string.match(\"I have 2 questions for you.\", \"(%d+) (%a+)\"))\n             2, \"questions\"  \n    3.字符串格式化         \n         Lua 提供了 string.format() 函数来生成具有特定格式的字符串, 函数的第一个参数是格式 , 之后是对应格式中每个代号的各种数据。\n            %c - 接受一个数字, 并将其转化为ASCII码表中对应的字符\n            %d, %i - 接受一个数字并将其转化为有符号的整数格式\n            %o - 接受一个数字并将其转化为八进制数格式\n            %u - 接受一个数字并将其转化为无符号整数格式\n            %x - 接受一个数字并将其转化为十六进制数格式, 使用小写字母\n            %X - 接受一个数字并将其转化为十六进制数格式, 使用大写字母\n            %e - 接受一个数字并将其转化为科学记数法格式, 使用小写字母e\n            %E - 接受一个数字并将其转化为科学记数法格式, 使用大写字母E\n            %f - 接受一个数字并将其转化为浮点数格式\n            %g(%G) - 接受一个数字并将其转化为%e(%E, 对应%G)及%f中较短的一种格式\n            %q - 接受一个字符串并将其转化为可安全被Lua编译器读入的格式\n            %s - 接受一个字符串并按照给定的参数格式化该字符串\n         为进一步细化格式, 可以在%号后添加参数. 参数将以如下的顺序读入:\n            (1) 符号: 一个+号表示其后的数字转义符将让正数显示正号. 默认情况下只有负数显示符号.\n            (2) 占位符: 一个0, 在后面指定了字串宽度时占位用. 不填时的默认占位符是空格.\n            (3) 对齐标识: 在指定了字串宽度时, 默认为右对齐, 增加-号可以改为左对齐.\n            (4) 宽度数值\n            (5) 小数位数/字串裁切: 在宽度数值后增加的小数部分n, 若后接f(浮点数转义符, 如%6.3f)则设定该浮点数的小数只保留n位, 若后接s(字符串转义符, 如%5.3s)则设定该字符串只显示前n位\n         例子:\n            string1 = \"Lua\"\n            string2 = \"Tutorial\"\n            number1 = 10\n            number2 = 20\n            -- 基本字符串格式化\n            print(string.format(\"基本格式化 %s %s\",string1,string2))\n            -- 日期格式化\n            date = 2; month = 1; year = 2014\n            print(string.format(\"日期格式化 %02d/%02d/%03d\", date, month, year))\n            -- 十进制格式化\n            print(string.format(\"%.4f\",1/3))\n    4. 字符与整数相互转换  \n         -- 字符转换\n         -- 转换第一个字符\n         print(string.byte(\"Lua\"))\n         -- 转换第三个字符\n         print(string.byte(\"Lua\",3))\n         -- 转换末尾第一个字符\n         print(string.byte(\"Lua\",-1))\n         -- 第二个字符\n         print(string.byte(\"Lua\",2))\n         -- 转换末尾第二个字符\n         print(string.byte(\"Lua\",-2))\n         -- 整数 ASCII 码转换为字符\n         print(string.char(97))   \n\n##### 字符串--正则表达式\n     Lua 中的匹配模式直接用常规的字符串来描述。 它用于模式匹配函数 string.find, string.gmatch, string.gsub, string.match。\n     你还可以在模式串中使用字符类。\n     字符类指可以匹配一个特定字符集合内任何字符的模式项。比如，字符类%d匹配任意数字。所以你可以使用模式串 '%d%d/%d%d/%d%d%d%d' 搜索 dd/mm/yyyy 格式的日期：\n     下面的表列出了Lua支持的所有字符类：\n     单个字符(除 ^$()%.[]*+-? 外): 与该字符自身配对\n     .(点): 与任何字符配对\n     %a: 与任何字母配对\n     %c: 与任何控制符配对(例如\\n)\n     %d: 与任何数字配对\n     %l: 与任何小写字母配对\n     %p: 与任何标点(punctuation)配对\n     %s: 与空白字符配对\n     %u: 与任何大写字母配对\n     %w: 与任何字母/数字配对\n     %x: 与任何十六进制数配对\n     %z: 与任何代表0的字符配对\n     %x(此处x是非字母非数字字符): 与字符x配对. 主要用来处理表达式中有功能的字符(^$()%.[]*+-?)的配对问题, 例如%%与%配对\n     [数个字符类]: 与任何[]中包含的字符类配对. 例如[%w_]与任何字母/数字, 或下划线符号(_)配对\n     [^数个字符类]: 与任何不包含在[]中的字符类配对. 例如[^%s]与任何非空白字符配对        \n     \n     当上述的字符类用大写书写时, 表示与非此字符类的任何字符配对. 例如, %S表示与任何非空白字符配对.例如，'%A'非字母的字符:\n     > print(string.gsub(\"hello, up-down!\", \"%A\", \".\"))\n     hello..up.down.    4\n     数字4不是字符串结果的一部分，他是gsub返回的第二个结果，代表发生替换的次数。\n     在模式匹配中有一些特殊字符，他们有特殊的意义，Lua中的特殊字符如下：\n     ( ) . % + - * ? [ ^ $\n     '%' 用作特殊字符的转义字符，因此 '%.' 匹配点；'%%' 匹配字符 '%'。转义字符 '%'不仅可以用来转义特殊字符，还可以用于所有的非字母的字符。\n      \n      模式条目可以是：\n          单个字符类匹配该类别中任意单个字符；\n          单个字符类跟一个 '*'， 将匹配零或多个该类的字符。 这个条目总是匹配尽可能长的串；\n          单个字符类跟一个 '+'， 将匹配一或更多个该类的字符。 这个条目总是匹配尽可能长的串；\n          单个字符类跟一个 '-'， 将匹配零或更多个该类的字符。 和 '*' 不同， 这个条目总是匹配尽可能短的串；\n          单个字符类跟一个 '?'， 将匹配零或一个该类的字符。 只要有可能，它会匹配一个；\n          %n， 这里的 n 可以从 1 到 9； 这个条目匹配一个等于 n 号捕获物（后面有描述）的子串。\n          %bxy， 这里的 x 和 y 是两个明确的字符； 这个条目匹配以 x 开始 y 结束， 且其中 x 和 y 保持 平衡 的字符串。 意思是，如果从左到右读这个字符串，对每次读到一个 x 就 +1 ，读到一个 y 就 -1， 最终结束处的那个 y 是第一个记数到 0 的 y。 举个例子，条目 %b() 可以匹配到括号平衡的表达式。\n          %f[set]， 指 边境模式； 这个条目会匹配到一个位于 set 内某个字符之前的一个空串， 且这个位置的前一个字符不属于 set 。 集合 set 的含义如前面所述。 匹配出的那个空串之开始和结束点的计算就看成该处有个字符 '\\0' 一样。\n      模式：\n        模式 指一个模式条目的序列。 在模式最前面加上符号 '^' 将锚定从字符串的开始处做匹配。 在模式最后面加上符号 '$' 将使匹配过程锚定到字符串的结尾。 如果 '^' 和 '$' 出现在其它位置，它们均没有特殊含义，只表示自身。\n      捕获：\n        模式可以在内部用小括号括起一个子模式； 这些子模式被称为 捕获物。 当匹配成功时，由 捕获物 匹配到的字符串中的子串被保存起来用于未来的用途。 捕获物以它们左括号的次序来编号。 例如，对于模式 \"(a*(.)%w(%s*))\" ， 字符串中匹配到 \"a*(.)%w(%s*)\" 的部分保存在第一个捕获物中 （因此是编号 1 ）； 由 \".\" 匹配到的字符是 2 号捕获物， 匹配到 \"%s*\" 的那部分是 3 号。\n      作为一个特例，空的捕获 () 将捕获到当前字符串的位置（它是一个数字）。 例如，如果将模式 \"()aa()\" 作用到字符串 \"flaaap\" 上，将产生两个捕获物： 3 和 5 。\n            \n#### table(表)   \n    在 Lua 里，table 的创获取数据的类型建是通过\"构造表达式\"来完成，最简单构造表达式是{}，用来创建一个空表\n    也可以在表里添加一些数据，直接初始化表:\n    1. 初始化表与移除引用\n        -- 创建一个空的 table\n        local tbl1 = {}         \n        -- 直接初始表\n        local tbl2 = {\"apple\", \"pear\", \"orange\", \"grape\"}\n        -- 初始化表\n        mytable = {} \n        -- 指定值\n        mytable[1]= \"Lua\"\n        -- 移除引用\n        mytable = nil\n        -- lua 垃圾回收会释放内存\n    \n    2. -- 创建一个空的 table\n       local tbl1 = {}\n       -- 直接初始表\n       local tbl2 = {\"apple\", \"pear\", \"orange\", \"grape\"}\n    \n    3. Lua 中的表（table）其实是一个\"关联数组\"（associative arrays），数组的索引可以是数字或者是字符串\n      table 不会固定长度大小，有新数据添加时 table 长度会自动增长，没初始的 table 都是 nil。\n      重点: 不同于其他语言的数组把 0 作为数组的初始索引，在 Lua 里表的默认初始索引一般以 1 开始  \n            local tbl = {\"apple\", \"pear\", \"orange\", \"grape\"}\n            for key, val in pairs(tbl) do\n               print(\"Key\", key)\n            end\n    4. 索引,对 table 的索引使用方括号 []。Lua 也提供了\".\"操作\n        > site = {}\n        > site[\"key\"] = \"www.w3cschool.cc\"\n        > print(site[\"key\"])\n        www.w3cschool.cc\n        > print(site.key)\n        www.w3cschool.cc\n\n##### table -- 操作\n    1.table.concat (table [, sep [, start [, end]]]):concat是concatenate(连锁, 连接)的缩写. table.concat()函数列出参数中指定table的数组部分从start位置到end位置的所有元素, 元素间以指定的分隔符(sep)隔开。\n    2.table.insert (table, [pos,] value):在table的数组部分指定位置(pos)插入值为value的一个元素. pos参数可选, 默认为数组部分末尾.\n    3.table.remove (table [, pos]):返回table数组部分位于pos位置的元素. 其后的元素会被前移. pos参数可选, 默认为table长度, 即从最后一个元素删起。\n    4.table.sort (table [, comp]):对给定的table进行升序排序\n\n##### table -- table间连接,table中的插入,移除,排序\n    使用 concat() 方法来连接两个 table\n        fruits = {\"banana\",\"orange\",\"apple\"}\n        -- 返回 table 连接后的字符串\n        print(\"连接后的字符串 \",table.concat(fruits)\n        -- 指定连接字符\n        print(\"连接后的字符串 \",table.concat(fruits,\", \"))\n        -- 指定索引来连接 table\n        print(\"连接后的字符串 \",table.concat(fruits,\", \", 2,3))\n        \n        fruits = {\"banana\",\"orange\",\"apple\"}\n        -- 在末尾插入\n        table.insert(fruits,\"mango\")\n        print(\"索引为 4 的元素为 \",fruits[4])\n        \n        -- 在索引为 2 的键处插入\n        table.insert(fruits,2,\"grapes\")\n        print(\"索引为 2 的元素为 \",fruits[2])\n        \n        print(\"最后一个元素为 \",fruits[5])\n        table.remove(fruits)\n        print(\"移除后最后一个元素为 \",fruits[5])    \n        \n        --排序\n        fruits = {\"banana\",\"orange\",\"apple\",\"grapes\"}\n        print(\"排序前\")\n        for k,v in ipairs(fruits) do\n            print(k,v)\n        end\n        \n        table.sort(fruits)\n        print(\"排序后\")\n        for k,v in ipairs(fruits) do\n            print(k,v)\n        end\n\n##### table -- 数组\n    1. 一维数组\n        array = {\"Lua\", \"Tutorial\"}\n        \n        for i= 0, 2 do\n           print(array[i])\n        end\n    2. 多维数组\n         -- 初始化数组\n         array = {}\n         for i=1,3 do\n            array[i] = {}\n               for j=1,3 do\n                  array[i][j] = i*j\n               end\n         end\n         \n         -- 访问数组\n         for i=1,3 do\n            for j=1,3 do\n               print(array[i][j])\n            end\n         end   \n        \n#### function（函数）\n    1.在 Lua 中，函数是被看作是\"一类公民（First-Class Value）\"\n        function factorial1(n)\n            if n == 0 then\n                return 1\n            else\n                return n * factorial1(n - 1)\n            end\n        end\n        print(factorial1(5))\n        factorial2 = factorial1\n        print(factorial2(5))\n     \n    2.function 可以以匿名函数（anonymous function）的方式通过参数传递\n        -- function_test2.lua 脚本文件\n        function testFun(tab,fun)\n            for k ,v in pairs(tab) do\n                print(fun(k,v));\n            end\n        end\n        \n        \n        tab={key1=\"val1\",key2=\"val2\"};\n        testFun(tab,\n        function(key,val)--匿名函数\n            return key..\"=\"..val;\n        end\n        );  \n    3. 多返回值\n        Lua函数中，在return后列出要返回的值的列表即可返回多值\n            function maximum (a)\n                local mi = 1             -- 最大值索引\n                local m = a[mi]          -- 最大值\n                for i,val in ipairs(a) do\n                   if val > m then\n                       mi = i\n                       m = val\n                   end\n                end\n                return m, mi\n            end\n            \n            print(maximum({8,10,23,12,5}))     \n\n##### 函数定义\n    optional_function_scope function function_name( argument1, argument2, argument3..., argumentn)\n        function_body\n        return result_params_comma_separated\n    end\n    \n    optional_function_scope: 该参数是可选的制定函数是全局函数还是局部函数，未设置该参数默认为全局函数，如果你需要设置函数为局部函数需要使用关键字 local。\n    function_name: 指定函数名称。\n    argument1, argument2, argument3..., argumentn: 函数参数，多个参数以逗号隔开，函数也可以不带参数。\n    function_body: 函数体，函数中需要执行的代码语句块。\n    result_params_comma_separated: 函数返回值，Lua语言函数可以返回多个值，每个值以逗号隔开。\n    \n##### 函数的可变参数\n       1. 在函数参数列表中使用三点 ... 表示函数有可变的参数\n            function add(...)  \n            local s = 0  \n              for i, v in ipairs{...} do   --> {...} 表示一个由所有变长参数构成的数组  \n                s = s + v  \n              end  \n              return s  \n            end  \n            print(add(3,4,5,6,7))  --->25\n       2. select(\"#\",...) 来获取可变参数的数量\n                function average(...)\n                   result = 0\n                   local arg={...}\n                   for i,v in ipairs(arg) do\n                      result = result + v\n                   end\n                   print(\"总共传入 \" .. select(\"#\",...) .. \" 个数\")\n                   return result/select(\"#\",...)\n                end\n                \n                print(\"平均值为\",average(10,5,3,4,5,6))\n            \n            在遍历变长参数的时候只需要使用 {…}，然而变长参数可能会包含一些 nil，那么就可以用 select 函数来访问变长参数了：select('#', …) 或者 select(n, …)\n            select('#', …) 返回可变参数的长度\n            select(n, …) 用于访问 n 到 select('#',…) 的参数\n            调用select时，必须传入一个固定实参selector(选择开关)和一系列变长参数。如果selector为数字n,那么select返回它的第n个可变实参，否则只能为字符串\"#\",这样select会返回变长参数的总数\n                do  \n                    function foo(...)  \n                        for i = 1, select('#', ...) do  -->获取参数总数\n                            local arg = select(i, ...); -->读取参数\n                            print(\"arg\", arg);  \n                        end  \n                    end  \n                  \n                    foo(1, 2, 3, 4);  \n                end\n        \n#### thread(线程)\n    在 Lua 里，最主要的线程是协同程序（coroutine）。\n    协程跟线程（thread）差不多，拥有自己独立的栈、局部变量和指令指针，可以跟其他协同程序共享全局变量和其他大部分东西。\n    线程跟协程的区别：线程可以同时多个运行，而协程任意时刻只能运行一个，并且处于运行状态的协程只有被挂起（suspend）时才会暂停。\n    \n#### userdata(自定义类型)     \n    userdata 是一种用户自定义数据，用于表示一种由应用程序或 C/C++ 语言库所创建的类型，可以将任意 C/C++ 的任意数据类型的数据（通常是 struct 和 指针）存储到 Lua 变量中调用。\n","source":"_posts/微服务API网关框架-3.md","raw":"---\ntitle: 微服务API网关框架(3)--Lua基本语法\ncatalog: true\ndate: 2018-12-20 10:47:23\nsubtitle:\nheader-img: \"Demo.png\"\ntags:\n- 微服务API网关\ncatagories:\n- 微服务API网关\n---\n\n# Lua基本语法\n\n### 编程模式\n    1. 交互式编程 (shell)\n        与python的shell使用方法一致，直接在终端下运行lua命令即可\n    2. 脚本式编程\n        创建xxxx.lua文件，然后使用lua xxxx.lua命令或者是luajit xxxx.lua文件即可进行运行\n           \n### 注释\n    1.单行注释\n        --\n    2.多行注释\n        --[[\n        多行注释\n        多行注释\n        --]]   \n        \n### 标示符\n    Lua 是一个区分大小写的编程语言\n    Lua 标示符用于定义一个变量，函数获取其他用户定义的项。标示符以一个字母 A 到 Z 或 a 到 z 或下划线 _ 开头后加上0个或多个字母，下划线，数字(0到9)\n    Lua 不允许使用特殊字符如 @, $, 和 % 来定义标示符\n    最好不要使用下划线加大写字母的标示符，因为Lua的保留字也是这样的\n    一般约定，以下划线开头连接一串大写字母的名字（比如 _VERSION）被保留用于 Lua 内部全局变量\n\n### 关键词\n    and    break    do    else\n    elseif    end    false    for\n    function    if    in    local\n    nil    not    or    repeat\n    return    then    true    until\n    while\n\n### 变量\n    Lua 变量有三种类型：全局变量、局部变量、表中的域\n    变量在使用前，必须在代码中进行声明，即创建该变量\n    变量的默认值均为 nil。\n\n    1.全局变量\n        (1)在默认情况下，变量总是认为是全局的。\n        (2)全局变量不需要声明，给一个变量赋值后即创建了这个全局变量，访问一个没有初始化的全局变量也不会出错，只不过得到的结果是：nil。\n        (3)如果你想删除一个全局变量，只需要将变量赋值为nil。\n        (4)Lua 中的变量全是全局变量，那怕是语句块或是函数里，除非用 local 显式声明为局部变量。\n    2.局部变量\n        局部变量的作用域为从声明位置开始到所在语句块结束。\n    3.表中的域\n    \n#### 赋值\n    1. 使用\"=\"号进行赋值\n    2. Lua可以对多个变量同时赋值，变量列表和值列表的各个元素用逗号分开，赋值语句右边的值会依次赋给左边的变量\n        a,b=21,22\n    3. 赋值语句Lua会先计算右边所有的值然后再执行赋值操作，所以我们可以这样进行交换变量的值\n        x, y = y, x                     -- swap 'x' for 'y'\n        a[i], a[j] = a[j], a[i]         -- swap 'a[i]' for 'a[j]'  \n    4. 重点: 当变量个数和值的个数不一致时，Lua会一直以变量个数为基础采取以下策略\n        a. 变量个数 > 值的个数             按变量个数补足nil\n        b. 变量个数 < 值的个数             多余的值会被忽略\n        \n        a, b, c = 0, 1\n        print(a,b,c)             --> 0   1   nil  \n        \n        a, b = a+1, b+1, b+2     -- value of b+2 is ignored\n        print(a,b)               --> 1   2\n        \n        a, b, c = 0\n        print(a,b,c)             --> 0   nil   nil\n    5. 多值赋值经常用来交换变量，或将函数调用返回给变量\n           a, b = f()\n           f()返回两个值，第一个赋给a，第二个赋给b。\n           应该尽可能的使用局部变量，有两个好处：\n               1. 避免命名冲突。\n               2. 访问局部变量的速度比全局变量更快。\n### 数据类型\n    Lua是动态类型语言，变量不要类型定义,只需要为变量赋值。 值可以存储在变量中，作为参数传递或结果返回。\n    Lua中有8个基本类型分别为：nil、boolean、number、string、userdata、function、thread和table。\n\n    数据类型\t描述\n    nil\t            这个最简单，只有值nil属于该类，表示一个无效值（在条件表达式中相当于false）。\n    boolean\t        包含两个值：false和true。Lua认为false和nil为\"假\",其他任何值都是\"真\",包括0\n    number\t        表示双精度类型的实浮点数\n    string\t        字符串由一对双引号或单引号来表示\n    function\t    由 C 或 Lua 编写的函数\n    userdata\t    表示任意存储在变量中的C数据结构\n    thread\t        表示执行的独立线路，用于执行协同程序\n    table\t        Lua 中的表（table）其实是一个\"关联数组\"（associative arrays），数组的索引可以是数字或者是字符串。在 Lua 里，table 的创建是通过\"构造表达式\"来完成，最简单构造表达式是{}，用来创建一个空表。\n\n#### 获取数据的类型\n    重点: type(xxx) -- 返回的都是字符串形式的数据类型\n          type(type(xxx)) == \"string\"\n    \n    print(type(\"Hello world\"))      --> string      \n    print(type(10.4*3))             --> number\n    print(type(print))              --> function\n    print(type(type))               --> function\n    print(type(true))               --> boolean\n    print(type(nil))                --> nil\n    print(type(type(X)))            --> string\n\n#### 获取当前变量的数据类型是否与设想的一致\n    v = \"Hello World.\"\n    if type(v) == \"string\"\n    then\n        print(\"字符串类型\")\n    end\n\n#### nil (空值)\n    nil 类型表示一种没有任何有效值，它只有一个值 -- nil\n    作用:对于全局变量和 table，nil 还有一个\"删除\"作用，给全局变量或者 table 表里的变量赋一个 nil 值，等同于把它们删掉\n       \n        例子:\n            tab1 = { key1 = \"val1\", key2 = \"val2\", \"val3\" }\n            for k, v in pairs(tab1) do\n                print(k .. \" - \" .. v)\n            end\n             \n            tab1.key1 = nil\n            for k, v in pairs(tab1) do\n                print(k .. \" - \" .. v)\n            end\n\n#### boolean(布尔值)\n    boolean 类型只有两个可选值：true（真） 和 false（假），Lua 把 false 和 nil 看作是\"假\"，其他的都为\"真\",包括\"0\"也是真\n    \n#### number(数字)\n    Lua 默认只有一种 number 类型 -- double（双精度）类型（默认类型可以修改 luaconf.h 里的定义）\n    \n#### string(字符串)\n    1. 字符串由一对双引号或单引号来表示。\n        string1 = \"this is string1\"\n        string2 = 'this is string2'\n    2. 两个方括号 \"[[]]\" 来表示\"一块\"字符串,用于多行文本 \n        html = [[\n        <html>\n        <head></head>\n        <body>\n            <a href=\"http://www.runoob.com/\">菜鸟教程</a>\n        </body>\n        </html>\n        ]]\n    3. 在对一个数字字符串上进行算术操作时，Lua 会尝试将这个数字字符串转成一个数字\n        > print(\"2\" + 6)\n        8.0\n        > print(\"2\" + \"6\")\n        8.0\n        > print(\"2 + 6\")\n        2 + 6\n        > print(\"-2e2\" * \"6\")\n        -1200.0\n    4. 字符串连接符\"..\"\n         > print(\"a\" .. 'b')\n         ab\n         > print(157 .. 428)\n         157428\n         > \n    5. 计算字符串长度\n         > len = \"www.runoob.com\"\n         > print(#len)\n         14\n         > print(#\"www.runoob.com\")\n         14\n\n##### 字符串用法拓展\n    1. 常规的转义符号\n        \\a  响铃(BEL)\n        \\b  退格(BS) ，将当前位置移到前一列\n        \\f  换页(FF)，将当前位置移到下页开头\n        \\n  换行(LF) ，将当前位置移到下一行开头\n        \\r  回车(CR) ，将当前位置移到本行开头\n        \\t  水平制表(HT) （跳到下一个TAB位置）\n        \\v  垂直制表(VT)\n        \\\\  代表一个反斜线字符''\\'\n        \\'  代表一个单引号（撇号）字符\n        \\\"  代表一个双引号字符\n        \\0  空字符(NULL)\n        \\ddd    1到3位八进制数所代表的任意字符\n        \\xhh    1到2位十六进制所代表的任意字符\n    \n    2. 字符串操作\n        (1)string.upper(argument):字符串全部转为大写字母  \n        (2)string.lower(argument):字符串全部转为小写字母\n        (3)string.gsub(mainString,findString,replaceString,num):在字符串中替换,mainString为要替换的字符串， findString 为被替换的字符，replaceString 要替换的字符，num 替换次数（可以忽略，则全部替换）\n            > string.gsub(\"aaaa\",\"a\",\"z\",3);\n            zzza    3\n        (4)string.find (str, substr, [init, [end]]):在一个指定的目标字符串中搜索指定的内容(第三个参数为索引),返回其具体位置。不存在则返回 nil\n            > string.find(\"Hello Lua user\", \"Lua\", 1) \n            7    9\n        (5)string.reverse(arg):字符串反转    \n        (6)string.format(...):返回一个类似printf的格式化字符串\n            > string.format(\"the value is:%d\",4)\n            the value is:4\n        (7)string.char(arg) 和 string.byte(arg[,int]): char 将整型数字转成字符并连接， byte 转换字符为整数值(可以指定某个字符，默认第一个字符)。\n            > string.char(97,98,99,100)\n            abcd\n            > string.byte(\"ABCD\",4)\n            68\n            > string.byte(\"ABCD\")\n            65\n        (8)string.len(arg):计算字符串长度。\n        (9)string.rep(string, n):返回字符串string的n个拷贝\n        (10)\"..\" 符号: 链接两个字符串\n        (11)string.gmatch(str, pattern):回一个迭代器函数，每一次调用这个函数，返回一个在字符串 str 找到的下一个符合 pattern 描述的子串。如果参数 pattern 描述的字符串没有找到，迭代函数返回nil。\n            > for word in string.gmatch(\"Hello Lua user\", \"%a+\") do print(word) end\n            Hello\n            Lua\n            user\n        (12)string.match(str, pattern, init):string.match()只寻找源字串str中的第一个配对. 参数init可选, 指定搜寻过程的起点, 默认为1。 \n                                            在成功配对时, 函数将返回配对表达式中的所有捕获结果; 如果没有设置捕获标记, 则返回整个配对字符串. 当没有成功的配对时, 返回nil。\n             > = string.match(\"I have 2 questions for you.\", \"%d+ %a+\")\n             2 questions\n             > = string.format(\"%d, %q\", string.match(\"I have 2 questions for you.\", \"(%d+) (%a+)\"))\n             2, \"questions\"  \n    3.字符串格式化         \n         Lua 提供了 string.format() 函数来生成具有特定格式的字符串, 函数的第一个参数是格式 , 之后是对应格式中每个代号的各种数据。\n            %c - 接受一个数字, 并将其转化为ASCII码表中对应的字符\n            %d, %i - 接受一个数字并将其转化为有符号的整数格式\n            %o - 接受一个数字并将其转化为八进制数格式\n            %u - 接受一个数字并将其转化为无符号整数格式\n            %x - 接受一个数字并将其转化为十六进制数格式, 使用小写字母\n            %X - 接受一个数字并将其转化为十六进制数格式, 使用大写字母\n            %e - 接受一个数字并将其转化为科学记数法格式, 使用小写字母e\n            %E - 接受一个数字并将其转化为科学记数法格式, 使用大写字母E\n            %f - 接受一个数字并将其转化为浮点数格式\n            %g(%G) - 接受一个数字并将其转化为%e(%E, 对应%G)及%f中较短的一种格式\n            %q - 接受一个字符串并将其转化为可安全被Lua编译器读入的格式\n            %s - 接受一个字符串并按照给定的参数格式化该字符串\n         为进一步细化格式, 可以在%号后添加参数. 参数将以如下的顺序读入:\n            (1) 符号: 一个+号表示其后的数字转义符将让正数显示正号. 默认情况下只有负数显示符号.\n            (2) 占位符: 一个0, 在后面指定了字串宽度时占位用. 不填时的默认占位符是空格.\n            (3) 对齐标识: 在指定了字串宽度时, 默认为右对齐, 增加-号可以改为左对齐.\n            (4) 宽度数值\n            (5) 小数位数/字串裁切: 在宽度数值后增加的小数部分n, 若后接f(浮点数转义符, 如%6.3f)则设定该浮点数的小数只保留n位, 若后接s(字符串转义符, 如%5.3s)则设定该字符串只显示前n位\n         例子:\n            string1 = \"Lua\"\n            string2 = \"Tutorial\"\n            number1 = 10\n            number2 = 20\n            -- 基本字符串格式化\n            print(string.format(\"基本格式化 %s %s\",string1,string2))\n            -- 日期格式化\n            date = 2; month = 1; year = 2014\n            print(string.format(\"日期格式化 %02d/%02d/%03d\", date, month, year))\n            -- 十进制格式化\n            print(string.format(\"%.4f\",1/3))\n    4. 字符与整数相互转换  \n         -- 字符转换\n         -- 转换第一个字符\n         print(string.byte(\"Lua\"))\n         -- 转换第三个字符\n         print(string.byte(\"Lua\",3))\n         -- 转换末尾第一个字符\n         print(string.byte(\"Lua\",-1))\n         -- 第二个字符\n         print(string.byte(\"Lua\",2))\n         -- 转换末尾第二个字符\n         print(string.byte(\"Lua\",-2))\n         -- 整数 ASCII 码转换为字符\n         print(string.char(97))   \n\n##### 字符串--正则表达式\n     Lua 中的匹配模式直接用常规的字符串来描述。 它用于模式匹配函数 string.find, string.gmatch, string.gsub, string.match。\n     你还可以在模式串中使用字符类。\n     字符类指可以匹配一个特定字符集合内任何字符的模式项。比如，字符类%d匹配任意数字。所以你可以使用模式串 '%d%d/%d%d/%d%d%d%d' 搜索 dd/mm/yyyy 格式的日期：\n     下面的表列出了Lua支持的所有字符类：\n     单个字符(除 ^$()%.[]*+-? 外): 与该字符自身配对\n     .(点): 与任何字符配对\n     %a: 与任何字母配对\n     %c: 与任何控制符配对(例如\\n)\n     %d: 与任何数字配对\n     %l: 与任何小写字母配对\n     %p: 与任何标点(punctuation)配对\n     %s: 与空白字符配对\n     %u: 与任何大写字母配对\n     %w: 与任何字母/数字配对\n     %x: 与任何十六进制数配对\n     %z: 与任何代表0的字符配对\n     %x(此处x是非字母非数字字符): 与字符x配对. 主要用来处理表达式中有功能的字符(^$()%.[]*+-?)的配对问题, 例如%%与%配对\n     [数个字符类]: 与任何[]中包含的字符类配对. 例如[%w_]与任何字母/数字, 或下划线符号(_)配对\n     [^数个字符类]: 与任何不包含在[]中的字符类配对. 例如[^%s]与任何非空白字符配对        \n     \n     当上述的字符类用大写书写时, 表示与非此字符类的任何字符配对. 例如, %S表示与任何非空白字符配对.例如，'%A'非字母的字符:\n     > print(string.gsub(\"hello, up-down!\", \"%A\", \".\"))\n     hello..up.down.    4\n     数字4不是字符串结果的一部分，他是gsub返回的第二个结果，代表发生替换的次数。\n     在模式匹配中有一些特殊字符，他们有特殊的意义，Lua中的特殊字符如下：\n     ( ) . % + - * ? [ ^ $\n     '%' 用作特殊字符的转义字符，因此 '%.' 匹配点；'%%' 匹配字符 '%'。转义字符 '%'不仅可以用来转义特殊字符，还可以用于所有的非字母的字符。\n      \n      模式条目可以是：\n          单个字符类匹配该类别中任意单个字符；\n          单个字符类跟一个 '*'， 将匹配零或多个该类的字符。 这个条目总是匹配尽可能长的串；\n          单个字符类跟一个 '+'， 将匹配一或更多个该类的字符。 这个条目总是匹配尽可能长的串；\n          单个字符类跟一个 '-'， 将匹配零或更多个该类的字符。 和 '*' 不同， 这个条目总是匹配尽可能短的串；\n          单个字符类跟一个 '?'， 将匹配零或一个该类的字符。 只要有可能，它会匹配一个；\n          %n， 这里的 n 可以从 1 到 9； 这个条目匹配一个等于 n 号捕获物（后面有描述）的子串。\n          %bxy， 这里的 x 和 y 是两个明确的字符； 这个条目匹配以 x 开始 y 结束， 且其中 x 和 y 保持 平衡 的字符串。 意思是，如果从左到右读这个字符串，对每次读到一个 x 就 +1 ，读到一个 y 就 -1， 最终结束处的那个 y 是第一个记数到 0 的 y。 举个例子，条目 %b() 可以匹配到括号平衡的表达式。\n          %f[set]， 指 边境模式； 这个条目会匹配到一个位于 set 内某个字符之前的一个空串， 且这个位置的前一个字符不属于 set 。 集合 set 的含义如前面所述。 匹配出的那个空串之开始和结束点的计算就看成该处有个字符 '\\0' 一样。\n      模式：\n        模式 指一个模式条目的序列。 在模式最前面加上符号 '^' 将锚定从字符串的开始处做匹配。 在模式最后面加上符号 '$' 将使匹配过程锚定到字符串的结尾。 如果 '^' 和 '$' 出现在其它位置，它们均没有特殊含义，只表示自身。\n      捕获：\n        模式可以在内部用小括号括起一个子模式； 这些子模式被称为 捕获物。 当匹配成功时，由 捕获物 匹配到的字符串中的子串被保存起来用于未来的用途。 捕获物以它们左括号的次序来编号。 例如，对于模式 \"(a*(.)%w(%s*))\" ， 字符串中匹配到 \"a*(.)%w(%s*)\" 的部分保存在第一个捕获物中 （因此是编号 1 ）； 由 \".\" 匹配到的字符是 2 号捕获物， 匹配到 \"%s*\" 的那部分是 3 号。\n      作为一个特例，空的捕获 () 将捕获到当前字符串的位置（它是一个数字）。 例如，如果将模式 \"()aa()\" 作用到字符串 \"flaaap\" 上，将产生两个捕获物： 3 和 5 。\n            \n#### table(表)   \n    在 Lua 里，table 的创获取数据的类型建是通过\"构造表达式\"来完成，最简单构造表达式是{}，用来创建一个空表\n    也可以在表里添加一些数据，直接初始化表:\n    1. 初始化表与移除引用\n        -- 创建一个空的 table\n        local tbl1 = {}         \n        -- 直接初始表\n        local tbl2 = {\"apple\", \"pear\", \"orange\", \"grape\"}\n        -- 初始化表\n        mytable = {} \n        -- 指定值\n        mytable[1]= \"Lua\"\n        -- 移除引用\n        mytable = nil\n        -- lua 垃圾回收会释放内存\n    \n    2. -- 创建一个空的 table\n       local tbl1 = {}\n       -- 直接初始表\n       local tbl2 = {\"apple\", \"pear\", \"orange\", \"grape\"}\n    \n    3. Lua 中的表（table）其实是一个\"关联数组\"（associative arrays），数组的索引可以是数字或者是字符串\n      table 不会固定长度大小，有新数据添加时 table 长度会自动增长，没初始的 table 都是 nil。\n      重点: 不同于其他语言的数组把 0 作为数组的初始索引，在 Lua 里表的默认初始索引一般以 1 开始  \n            local tbl = {\"apple\", \"pear\", \"orange\", \"grape\"}\n            for key, val in pairs(tbl) do\n               print(\"Key\", key)\n            end\n    4. 索引,对 table 的索引使用方括号 []。Lua 也提供了\".\"操作\n        > site = {}\n        > site[\"key\"] = \"www.w3cschool.cc\"\n        > print(site[\"key\"])\n        www.w3cschool.cc\n        > print(site.key)\n        www.w3cschool.cc\n\n##### table -- 操作\n    1.table.concat (table [, sep [, start [, end]]]):concat是concatenate(连锁, 连接)的缩写. table.concat()函数列出参数中指定table的数组部分从start位置到end位置的所有元素, 元素间以指定的分隔符(sep)隔开。\n    2.table.insert (table, [pos,] value):在table的数组部分指定位置(pos)插入值为value的一个元素. pos参数可选, 默认为数组部分末尾.\n    3.table.remove (table [, pos]):返回table数组部分位于pos位置的元素. 其后的元素会被前移. pos参数可选, 默认为table长度, 即从最后一个元素删起。\n    4.table.sort (table [, comp]):对给定的table进行升序排序\n\n##### table -- table间连接,table中的插入,移除,排序\n    使用 concat() 方法来连接两个 table\n        fruits = {\"banana\",\"orange\",\"apple\"}\n        -- 返回 table 连接后的字符串\n        print(\"连接后的字符串 \",table.concat(fruits)\n        -- 指定连接字符\n        print(\"连接后的字符串 \",table.concat(fruits,\", \"))\n        -- 指定索引来连接 table\n        print(\"连接后的字符串 \",table.concat(fruits,\", \", 2,3))\n        \n        fruits = {\"banana\",\"orange\",\"apple\"}\n        -- 在末尾插入\n        table.insert(fruits,\"mango\")\n        print(\"索引为 4 的元素为 \",fruits[4])\n        \n        -- 在索引为 2 的键处插入\n        table.insert(fruits,2,\"grapes\")\n        print(\"索引为 2 的元素为 \",fruits[2])\n        \n        print(\"最后一个元素为 \",fruits[5])\n        table.remove(fruits)\n        print(\"移除后最后一个元素为 \",fruits[5])    \n        \n        --排序\n        fruits = {\"banana\",\"orange\",\"apple\",\"grapes\"}\n        print(\"排序前\")\n        for k,v in ipairs(fruits) do\n            print(k,v)\n        end\n        \n        table.sort(fruits)\n        print(\"排序后\")\n        for k,v in ipairs(fruits) do\n            print(k,v)\n        end\n\n##### table -- 数组\n    1. 一维数组\n        array = {\"Lua\", \"Tutorial\"}\n        \n        for i= 0, 2 do\n           print(array[i])\n        end\n    2. 多维数组\n         -- 初始化数组\n         array = {}\n         for i=1,3 do\n            array[i] = {}\n               for j=1,3 do\n                  array[i][j] = i*j\n               end\n         end\n         \n         -- 访问数组\n         for i=1,3 do\n            for j=1,3 do\n               print(array[i][j])\n            end\n         end   \n        \n#### function（函数）\n    1.在 Lua 中，函数是被看作是\"一类公民（First-Class Value）\"\n        function factorial1(n)\n            if n == 0 then\n                return 1\n            else\n                return n * factorial1(n - 1)\n            end\n        end\n        print(factorial1(5))\n        factorial2 = factorial1\n        print(factorial2(5))\n     \n    2.function 可以以匿名函数（anonymous function）的方式通过参数传递\n        -- function_test2.lua 脚本文件\n        function testFun(tab,fun)\n            for k ,v in pairs(tab) do\n                print(fun(k,v));\n            end\n        end\n        \n        \n        tab={key1=\"val1\",key2=\"val2\"};\n        testFun(tab,\n        function(key,val)--匿名函数\n            return key..\"=\"..val;\n        end\n        );  \n    3. 多返回值\n        Lua函数中，在return后列出要返回的值的列表即可返回多值\n            function maximum (a)\n                local mi = 1             -- 最大值索引\n                local m = a[mi]          -- 最大值\n                for i,val in ipairs(a) do\n                   if val > m then\n                       mi = i\n                       m = val\n                   end\n                end\n                return m, mi\n            end\n            \n            print(maximum({8,10,23,12,5}))     \n\n##### 函数定义\n    optional_function_scope function function_name( argument1, argument2, argument3..., argumentn)\n        function_body\n        return result_params_comma_separated\n    end\n    \n    optional_function_scope: 该参数是可选的制定函数是全局函数还是局部函数，未设置该参数默认为全局函数，如果你需要设置函数为局部函数需要使用关键字 local。\n    function_name: 指定函数名称。\n    argument1, argument2, argument3..., argumentn: 函数参数，多个参数以逗号隔开，函数也可以不带参数。\n    function_body: 函数体，函数中需要执行的代码语句块。\n    result_params_comma_separated: 函数返回值，Lua语言函数可以返回多个值，每个值以逗号隔开。\n    \n##### 函数的可变参数\n       1. 在函数参数列表中使用三点 ... 表示函数有可变的参数\n            function add(...)  \n            local s = 0  \n              for i, v in ipairs{...} do   --> {...} 表示一个由所有变长参数构成的数组  \n                s = s + v  \n              end  \n              return s  \n            end  \n            print(add(3,4,5,6,7))  --->25\n       2. select(\"#\",...) 来获取可变参数的数量\n                function average(...)\n                   result = 0\n                   local arg={...}\n                   for i,v in ipairs(arg) do\n                      result = result + v\n                   end\n                   print(\"总共传入 \" .. select(\"#\",...) .. \" 个数\")\n                   return result/select(\"#\",...)\n                end\n                \n                print(\"平均值为\",average(10,5,3,4,5,6))\n            \n            在遍历变长参数的时候只需要使用 {…}，然而变长参数可能会包含一些 nil，那么就可以用 select 函数来访问变长参数了：select('#', …) 或者 select(n, …)\n            select('#', …) 返回可变参数的长度\n            select(n, …) 用于访问 n 到 select('#',…) 的参数\n            调用select时，必须传入一个固定实参selector(选择开关)和一系列变长参数。如果selector为数字n,那么select返回它的第n个可变实参，否则只能为字符串\"#\",这样select会返回变长参数的总数\n                do  \n                    function foo(...)  \n                        for i = 1, select('#', ...) do  -->获取参数总数\n                            local arg = select(i, ...); -->读取参数\n                            print(\"arg\", arg);  \n                        end  \n                    end  \n                  \n                    foo(1, 2, 3, 4);  \n                end\n        \n#### thread(线程)\n    在 Lua 里，最主要的线程是协同程序（coroutine）。\n    协程跟线程（thread）差不多，拥有自己独立的栈、局部变量和指令指针，可以跟其他协同程序共享全局变量和其他大部分东西。\n    线程跟协程的区别：线程可以同时多个运行，而协程任意时刻只能运行一个，并且处于运行状态的协程只有被挂起（suspend）时才会暂停。\n    \n#### userdata(自定义类型)     \n    userdata 是一种用户自定义数据，用于表示一种由应用程序或 C/C++ 语言库所创建的类型，可以将任意 C/C++ 的任意数据类型的数据（通常是 struct 和 指针）存储到 Lua 变量中调用。\n","slug":"微服务API网关框架-3","published":1,"updated":"2018-12-20T06:26:13.532Z","_id":"cjpw2eyft0009n0uj4pb1dbkm","comments":1,"layout":"post","photos":[],"link":"","content":"<h1><span id=\"lua基本语法\">Lua基本语法</span></h1>\n<h3><span id=\"编程模式\">编程模式</span></h3>\n<pre><code>1. 交互式编程 (shell)\n    与python的shell使用方法一致，直接在终端下运行lua命令即可\n2. 脚本式编程\n    创建xxxx.lua文件，然后使用lua xxxx.lua命令或者是luajit xxxx.lua文件即可进行运行\n</code></pre>\n<h3><span id=\"注释\">注释</span></h3>\n<pre><code>1.单行注释\n    --\n2.多行注释\n    --[[\n    多行注释\n    多行注释\n    --]]   \n</code></pre>\n<h3><span id=\"标示符\">标示符</span></h3>\n<pre><code>Lua 是一个区分大小写的编程语言\nLua 标示符用于定义一个变量，函数获取其他用户定义的项。标示符以一个字母 A 到 Z 或 a 到 z 或下划线 _ 开头后加上0个或多个字母，下划线，数字(0到9)\nLua 不允许使用特殊字符如 @, $, 和 % 来定义标示符\n最好不要使用下划线加大写字母的标示符，因为Lua的保留字也是这样的\n一般约定，以下划线开头连接一串大写字母的名字（比如 _VERSION）被保留用于 Lua 内部全局变量\n</code></pre>\n<h3><span id=\"关键词\">关键词</span></h3>\n<pre><code>and    break    do    else\nelseif    end    false    for\nfunction    if    in    local\nnil    not    or    repeat\nreturn    then    true    until\nwhile\n</code></pre>\n<h3><span id=\"变量\">变量</span></h3>\n<pre><code>Lua 变量有三种类型：全局变量、局部变量、表中的域\n变量在使用前，必须在代码中进行声明，即创建该变量\n变量的默认值均为 nil。\n\n1.全局变量\n    (1)在默认情况下，变量总是认为是全局的。\n    (2)全局变量不需要声明，给一个变量赋值后即创建了这个全局变量，访问一个没有初始化的全局变量也不会出错，只不过得到的结果是：nil。\n    (3)如果你想删除一个全局变量，只需要将变量赋值为nil。\n    (4)Lua 中的变量全是全局变量，那怕是语句块或是函数里，除非用 local 显式声明为局部变量。\n2.局部变量\n    局部变量的作用域为从声明位置开始到所在语句块结束。\n3.表中的域\n</code></pre>\n<h4><span id=\"赋值\">赋值</span></h4>\n<pre><code>1. 使用&quot;=&quot;号进行赋值\n2. Lua可以对多个变量同时赋值，变量列表和值列表的各个元素用逗号分开，赋值语句右边的值会依次赋给左边的变量\n    a,b=21,22\n3. 赋值语句Lua会先计算右边所有的值然后再执行赋值操作，所以我们可以这样进行交换变量的值\n    x, y = y, x                     -- swap 'x' for 'y'\n    a[i], a[j] = a[j], a[i]         -- swap 'a[i]' for 'a[j]'  \n4. 重点: 当变量个数和值的个数不一致时，Lua会一直以变量个数为基础采取以下策略\n    a. 变量个数 &gt; 值的个数             按变量个数补足nil\n    b. 变量个数 &lt; 值的个数             多余的值会被忽略\n    \n    a, b, c = 0, 1\n    print(a,b,c)             --&gt; 0   1   nil  \n    \n    a, b = a+1, b+1, b+2     -- value of b+2 is ignored\n    print(a,b)               --&gt; 1   2\n    \n    a, b, c = 0\n    print(a,b,c)             --&gt; 0   nil   nil\n5. 多值赋值经常用来交换变量，或将函数调用返回给变量\n       a, b = f()\n       f()返回两个值，第一个赋给a，第二个赋给b。\n       应该尽可能的使用局部变量，有两个好处：\n           1. 避免命名冲突。\n           2. 访问局部变量的速度比全局变量更快。\n</code></pre>\n<h3><span id=\"数据类型\">数据类型</span></h3>\n<pre><code>Lua是动态类型语言，变量不要类型定义,只需要为变量赋值。 值可以存储在变量中，作为参数传递或结果返回。\nLua中有8个基本类型分别为：nil、boolean、number、string、userdata、function、thread和table。\n\n数据类型\t描述\nnil\t            这个最简单，只有值nil属于该类，表示一个无效值（在条件表达式中相当于false）。\nboolean\t        包含两个值：false和true。Lua认为false和nil为&quot;假&quot;,其他任何值都是&quot;真&quot;,包括0\nnumber\t        表示双精度类型的实浮点数\nstring\t        字符串由一对双引号或单引号来表示\nfunction\t    由 C 或 Lua 编写的函数\nuserdata\t    表示任意存储在变量中的C数据结构\nthread\t        表示执行的独立线路，用于执行协同程序\ntable\t        Lua 中的表（table）其实是一个&quot;关联数组&quot;（associative arrays），数组的索引可以是数字或者是字符串。在 Lua 里，table 的创建是通过&quot;构造表达式&quot;来完成，最简单构造表达式是{}，用来创建一个空表。\n</code></pre>\n<h4><span id=\"获取数据的类型\">获取数据的类型</span></h4>\n<pre><code>重点: type(xxx) -- 返回的都是字符串形式的数据类型\n      type(type(xxx)) == &quot;string&quot;\n\nprint(type(&quot;Hello world&quot;))      --&gt; string      \nprint(type(10.4*3))             --&gt; number\nprint(type(print))              --&gt; function\nprint(type(type))               --&gt; function\nprint(type(true))               --&gt; boolean\nprint(type(nil))                --&gt; nil\nprint(type(type(X)))            --&gt; string\n</code></pre>\n<h4><span id=\"获取当前变量的数据类型是否与设想的一致\">获取当前变量的数据类型是否与设想的一致</span></h4>\n<pre><code>v = &quot;Hello World.&quot;\nif type(v) == &quot;string&quot;\nthen\n    print(&quot;字符串类型&quot;)\nend\n</code></pre>\n<h4><span id=\"nil-空值\">nil (空值)</span></h4>\n<pre><code>nil 类型表示一种没有任何有效值，它只有一个值 -- nil\n作用:对于全局变量和 table，nil 还有一个&quot;删除&quot;作用，给全局变量或者 table 表里的变量赋一个 nil 值，等同于把它们删掉\n   \n    例子:\n        tab1 = { key1 = &quot;val1&quot;, key2 = &quot;val2&quot;, &quot;val3&quot; }\n        for k, v in pairs(tab1) do\n            print(k .. &quot; - &quot; .. v)\n        end\n         \n        tab1.key1 = nil\n        for k, v in pairs(tab1) do\n            print(k .. &quot; - &quot; .. v)\n        end\n</code></pre>\n<h4><span id=\"boolean布尔值\">boolean(布尔值)</span></h4>\n<pre><code>boolean 类型只有两个可选值：true（真） 和 false（假），Lua 把 false 和 nil 看作是&quot;假&quot;，其他的都为&quot;真&quot;,包括&quot;0&quot;也是真\n</code></pre>\n<h4><span id=\"number数字\">number(数字)</span></h4>\n<pre><code>Lua 默认只有一种 number 类型 -- double（双精度）类型（默认类型可以修改 luaconf.h 里的定义）\n</code></pre>\n<h4><span id=\"string字符串\">string(字符串)</span></h4>\n<pre><code>1. 字符串由一对双引号或单引号来表示。\n    string1 = &quot;this is string1&quot;\n    string2 = 'this is string2'\n2. 两个方括号 &quot;[[]]&quot; 来表示&quot;一块&quot;字符串,用于多行文本 \n    html = [[\n    &lt;html&gt;\n    &lt;head&gt;&lt;/head&gt;\n    &lt;body&gt;\n        &lt;a href=&quot;http://www.runoob.com/&quot;&gt;菜鸟教程&lt;/a&gt;\n    &lt;/body&gt;\n    &lt;/html&gt;\n    ]]\n3. 在对一个数字字符串上进行算术操作时，Lua 会尝试将这个数字字符串转成一个数字\n    &gt; print(&quot;2&quot; + 6)\n    8.0\n    &gt; print(&quot;2&quot; + &quot;6&quot;)\n    8.0\n    &gt; print(&quot;2 + 6&quot;)\n    2 + 6\n    &gt; print(&quot;-2e2&quot; * &quot;6&quot;)\n    -1200.0\n4. 字符串连接符&quot;..&quot;\n     &gt; print(&quot;a&quot; .. 'b')\n     ab\n     &gt; print(157 .. 428)\n     157428\n     &gt; \n5. 计算字符串长度\n     &gt; len = &quot;www.runoob.com&quot;\n     &gt; print(#len)\n     14\n     &gt; print(#&quot;www.runoob.com&quot;)\n     14\n</code></pre>\n<h5><span id=\"字符串用法拓展\">字符串用法拓展</span></h5>\n<pre><code>1. 常规的转义符号\n    \\a  响铃(BEL)\n    \\b  退格(BS) ，将当前位置移到前一列\n    \\f  换页(FF)，将当前位置移到下页开头\n    \\n  换行(LF) ，将当前位置移到下一行开头\n    \\r  回车(CR) ，将当前位置移到本行开头\n    \\t  水平制表(HT) （跳到下一个TAB位置）\n    \\v  垂直制表(VT)\n    \\\\  代表一个反斜线字符''\\'\n    \\'  代表一个单引号（撇号）字符\n    \\&quot;  代表一个双引号字符\n    \\0  空字符(NULL)\n    \\ddd    1到3位八进制数所代表的任意字符\n    \\xhh    1到2位十六进制所代表的任意字符\n\n2. 字符串操作\n    (1)string.upper(argument):字符串全部转为大写字母  \n    (2)string.lower(argument):字符串全部转为小写字母\n    (3)string.gsub(mainString,findString,replaceString,num):在字符串中替换,mainString为要替换的字符串， findString 为被替换的字符，replaceString 要替换的字符，num 替换次数（可以忽略，则全部替换）\n        &gt; string.gsub(&quot;aaaa&quot;,&quot;a&quot;,&quot;z&quot;,3);\n        zzza    3\n    (4)string.find (str, substr, [init, [end]]):在一个指定的目标字符串中搜索指定的内容(第三个参数为索引),返回其具体位置。不存在则返回 nil\n        &gt; string.find(&quot;Hello Lua user&quot;, &quot;Lua&quot;, 1) \n        7    9\n    (5)string.reverse(arg):字符串反转    \n    (6)string.format(...):返回一个类似printf的格式化字符串\n        &gt; string.format(&quot;the value is:%d&quot;,4)\n        the value is:4\n    (7)string.char(arg) 和 string.byte(arg[,int]): char 将整型数字转成字符并连接， byte 转换字符为整数值(可以指定某个字符，默认第一个字符)。\n        &gt; string.char(97,98,99,100)\n        abcd\n        &gt; string.byte(&quot;ABCD&quot;,4)\n        68\n        &gt; string.byte(&quot;ABCD&quot;)\n        65\n    (8)string.len(arg):计算字符串长度。\n    (9)string.rep(string, n):返回字符串string的n个拷贝\n    (10)&quot;..&quot; 符号: 链接两个字符串\n    (11)string.gmatch(str, pattern):回一个迭代器函数，每一次调用这个函数，返回一个在字符串 str 找到的下一个符合 pattern 描述的子串。如果参数 pattern 描述的字符串没有找到，迭代函数返回nil。\n        &gt; for word in string.gmatch(&quot;Hello Lua user&quot;, &quot;%a+&quot;) do print(word) end\n        Hello\n        Lua\n        user\n    (12)string.match(str, pattern, init):string.match()只寻找源字串str中的第一个配对. 参数init可选, 指定搜寻过程的起点, 默认为1。 \n                                        在成功配对时, 函数将返回配对表达式中的所有捕获结果; 如果没有设置捕获标记, 则返回整个配对字符串. 当没有成功的配对时, 返回nil。\n         &gt; = string.match(&quot;I have 2 questions for you.&quot;, &quot;%d+ %a+&quot;)\n         2 questions\n         &gt; = string.format(&quot;%d, %q&quot;, string.match(&quot;I have 2 questions for you.&quot;, &quot;(%d+) (%a+)&quot;))\n         2, &quot;questions&quot;  \n3.字符串格式化         \n     Lua 提供了 string.format() 函数来生成具有特定格式的字符串, 函数的第一个参数是格式 , 之后是对应格式中每个代号的各种数据。\n        %c - 接受一个数字, 并将其转化为ASCII码表中对应的字符\n        %d, %i - 接受一个数字并将其转化为有符号的整数格式\n        %o - 接受一个数字并将其转化为八进制数格式\n        %u - 接受一个数字并将其转化为无符号整数格式\n        %x - 接受一个数字并将其转化为十六进制数格式, 使用小写字母\n        %X - 接受一个数字并将其转化为十六进制数格式, 使用大写字母\n        %e - 接受一个数字并将其转化为科学记数法格式, 使用小写字母e\n        %E - 接受一个数字并将其转化为科学记数法格式, 使用大写字母E\n        %f - 接受一个数字并将其转化为浮点数格式\n        %g(%G) - 接受一个数字并将其转化为%e(%E, 对应%G)及%f中较短的一种格式\n        %q - 接受一个字符串并将其转化为可安全被Lua编译器读入的格式\n        %s - 接受一个字符串并按照给定的参数格式化该字符串\n     为进一步细化格式, 可以在%号后添加参数. 参数将以如下的顺序读入:\n        (1) 符号: 一个+号表示其后的数字转义符将让正数显示正号. 默认情况下只有负数显示符号.\n        (2) 占位符: 一个0, 在后面指定了字串宽度时占位用. 不填时的默认占位符是空格.\n        (3) 对齐标识: 在指定了字串宽度时, 默认为右对齐, 增加-号可以改为左对齐.\n        (4) 宽度数值\n        (5) 小数位数/字串裁切: 在宽度数值后增加的小数部分n, 若后接f(浮点数转义符, 如%6.3f)则设定该浮点数的小数只保留n位, 若后接s(字符串转义符, 如%5.3s)则设定该字符串只显示前n位\n     例子:\n        string1 = &quot;Lua&quot;\n        string2 = &quot;Tutorial&quot;\n        number1 = 10\n        number2 = 20\n        -- 基本字符串格式化\n        print(string.format(&quot;基本格式化 %s %s&quot;,string1,string2))\n        -- 日期格式化\n        date = 2; month = 1; year = 2014\n        print(string.format(&quot;日期格式化 %02d/%02d/%03d&quot;, date, month, year))\n        -- 十进制格式化\n        print(string.format(&quot;%.4f&quot;,1/3))\n4. 字符与整数相互转换  \n     -- 字符转换\n     -- 转换第一个字符\n     print(string.byte(&quot;Lua&quot;))\n     -- 转换第三个字符\n     print(string.byte(&quot;Lua&quot;,3))\n     -- 转换末尾第一个字符\n     print(string.byte(&quot;Lua&quot;,-1))\n     -- 第二个字符\n     print(string.byte(&quot;Lua&quot;,2))\n     -- 转换末尾第二个字符\n     print(string.byte(&quot;Lua&quot;,-2))\n     -- 整数 ASCII 码转换为字符\n     print(string.char(97))   \n</code></pre>\n<h5><span id=\"字符串正则表达式\">字符串–正则表达式</span></h5>\n<pre><code> Lua 中的匹配模式直接用常规的字符串来描述。 它用于模式匹配函数 string.find, string.gmatch, string.gsub, string.match。\n 你还可以在模式串中使用字符类。\n 字符类指可以匹配一个特定字符集合内任何字符的模式项。比如，字符类%d匹配任意数字。所以你可以使用模式串 '%d%d/%d%d/%d%d%d%d' 搜索 dd/mm/yyyy 格式的日期：\n 下面的表列出了Lua支持的所有字符类：\n 单个字符(除 ^$()%.[]*+-? 外): 与该字符自身配对\n .(点): 与任何字符配对\n %a: 与任何字母配对\n %c: 与任何控制符配对(例如\\n)\n %d: 与任何数字配对\n %l: 与任何小写字母配对\n %p: 与任何标点(punctuation)配对\n %s: 与空白字符配对\n %u: 与任何大写字母配对\n %w: 与任何字母/数字配对\n %x: 与任何十六进制数配对\n %z: 与任何代表0的字符配对\n %x(此处x是非字母非数字字符): 与字符x配对. 主要用来处理表达式中有功能的字符(^$()%.[]*+-?)的配对问题, 例如%%与%配对\n [数个字符类]: 与任何[]中包含的字符类配对. 例如[%w_]与任何字母/数字, 或下划线符号(_)配对\n [^数个字符类]: 与任何不包含在[]中的字符类配对. 例如[^%s]与任何非空白字符配对        \n \n 当上述的字符类用大写书写时, 表示与非此字符类的任何字符配对. 例如, %S表示与任何非空白字符配对.例如，'%A'非字母的字符:\n &gt; print(string.gsub(&quot;hello, up-down!&quot;, &quot;%A&quot;, &quot;.&quot;))\n hello..up.down.    4\n 数字4不是字符串结果的一部分，他是gsub返回的第二个结果，代表发生替换的次数。\n 在模式匹配中有一些特殊字符，他们有特殊的意义，Lua中的特殊字符如下：\n ( ) . % + - * ? [ ^ $\n '%' 用作特殊字符的转义字符，因此 '%.' 匹配点；'%%' 匹配字符 '%'。转义字符 '%'不仅可以用来转义特殊字符，还可以用于所有的非字母的字符。\n  \n  模式条目可以是：\n      单个字符类匹配该类别中任意单个字符；\n      单个字符类跟一个 '*'， 将匹配零或多个该类的字符。 这个条目总是匹配尽可能长的串；\n      单个字符类跟一个 '+'， 将匹配一或更多个该类的字符。 这个条目总是匹配尽可能长的串；\n      单个字符类跟一个 '-'， 将匹配零或更多个该类的字符。 和 '*' 不同， 这个条目总是匹配尽可能短的串；\n      单个字符类跟一个 '?'， 将匹配零或一个该类的字符。 只要有可能，它会匹配一个；\n      %n， 这里的 n 可以从 1 到 9； 这个条目匹配一个等于 n 号捕获物（后面有描述）的子串。\n      %bxy， 这里的 x 和 y 是两个明确的字符； 这个条目匹配以 x 开始 y 结束， 且其中 x 和 y 保持 平衡 的字符串。 意思是，如果从左到右读这个字符串，对每次读到一个 x 就 +1 ，读到一个 y 就 -1， 最终结束处的那个 y 是第一个记数到 0 的 y。 举个例子，条目 %b() 可以匹配到括号平衡的表达式。\n      %f[set]， 指 边境模式； 这个条目会匹配到一个位于 set 内某个字符之前的一个空串， 且这个位置的前一个字符不属于 set 。 集合 set 的含义如前面所述。 匹配出的那个空串之开始和结束点的计算就看成该处有个字符 '\\0' 一样。\n  模式：\n    模式 指一个模式条目的序列。 在模式最前面加上符号 '^' 将锚定从字符串的开始处做匹配。 在模式最后面加上符号 '$' 将使匹配过程锚定到字符串的结尾。 如果 '^' 和 '$' 出现在其它位置，它们均没有特殊含义，只表示自身。\n  捕获：\n    模式可以在内部用小括号括起一个子模式； 这些子模式被称为 捕获物。 当匹配成功时，由 捕获物 匹配到的字符串中的子串被保存起来用于未来的用途。 捕获物以它们左括号的次序来编号。 例如，对于模式 &quot;(a*(.)%w(%s*))&quot; ， 字符串中匹配到 &quot;a*(.)%w(%s*)&quot; 的部分保存在第一个捕获物中 （因此是编号 1 ）； 由 &quot;.&quot; 匹配到的字符是 2 号捕获物， 匹配到 &quot;%s*&quot; 的那部分是 3 号。\n  作为一个特例，空的捕获 () 将捕获到当前字符串的位置（它是一个数字）。 例如，如果将模式 &quot;()aa()&quot; 作用到字符串 &quot;flaaap&quot; 上，将产生两个捕获物： 3 和 5 。\n</code></pre>\n<h4><span id=\"table表\">table(表)</span></h4>\n<pre><code>在 Lua 里，table 的创获取数据的类型建是通过&quot;构造表达式&quot;来完成，最简单构造表达式是{}，用来创建一个空表\n也可以在表里添加一些数据，直接初始化表:\n1. 初始化表与移除引用\n    -- 创建一个空的 table\n    local tbl1 = {}         \n    -- 直接初始表\n    local tbl2 = {&quot;apple&quot;, &quot;pear&quot;, &quot;orange&quot;, &quot;grape&quot;}\n    -- 初始化表\n    mytable = {} \n    -- 指定值\n    mytable[1]= &quot;Lua&quot;\n    -- 移除引用\n    mytable = nil\n    -- lua 垃圾回收会释放内存\n\n2. -- 创建一个空的 table\n   local tbl1 = {}\n   -- 直接初始表\n   local tbl2 = {&quot;apple&quot;, &quot;pear&quot;, &quot;orange&quot;, &quot;grape&quot;}\n\n3. Lua 中的表（table）其实是一个&quot;关联数组&quot;（associative arrays），数组的索引可以是数字或者是字符串\n  table 不会固定长度大小，有新数据添加时 table 长度会自动增长，没初始的 table 都是 nil。\n  重点: 不同于其他语言的数组把 0 作为数组的初始索引，在 Lua 里表的默认初始索引一般以 1 开始  \n        local tbl = {&quot;apple&quot;, &quot;pear&quot;, &quot;orange&quot;, &quot;grape&quot;}\n        for key, val in pairs(tbl) do\n           print(&quot;Key&quot;, key)\n        end\n4. 索引,对 table 的索引使用方括号 []。Lua 也提供了&quot;.&quot;操作\n    &gt; site = {}\n    &gt; site[&quot;key&quot;] = &quot;www.w3cschool.cc&quot;\n    &gt; print(site[&quot;key&quot;])\n    www.w3cschool.cc\n    &gt; print(site.key)\n    www.w3cschool.cc\n</code></pre>\n<h5><span id=\"table-操作\">table – 操作</span></h5>\n<pre><code>1.table.concat (table [, sep [, start [, end]]]):concat是concatenate(连锁, 连接)的缩写. table.concat()函数列出参数中指定table的数组部分从start位置到end位置的所有元素, 元素间以指定的分隔符(sep)隔开。\n2.table.insert (table, [pos,] value):在table的数组部分指定位置(pos)插入值为value的一个元素. pos参数可选, 默认为数组部分末尾.\n3.table.remove (table [, pos]):返回table数组部分位于pos位置的元素. 其后的元素会被前移. pos参数可选, 默认为table长度, 即从最后一个元素删起。\n4.table.sort (table [, comp]):对给定的table进行升序排序\n</code></pre>\n<h5><span id=\"table-table间连接table中的插入移除排序\">table – table间连接,table中的插入,移除,排序</span></h5>\n<pre><code>使用 concat() 方法来连接两个 table\n    fruits = {&quot;banana&quot;,&quot;orange&quot;,&quot;apple&quot;}\n    -- 返回 table 连接后的字符串\n    print(&quot;连接后的字符串 &quot;,table.concat(fruits)\n    -- 指定连接字符\n    print(&quot;连接后的字符串 &quot;,table.concat(fruits,&quot;, &quot;))\n    -- 指定索引来连接 table\n    print(&quot;连接后的字符串 &quot;,table.concat(fruits,&quot;, &quot;, 2,3))\n    \n    fruits = {&quot;banana&quot;,&quot;orange&quot;,&quot;apple&quot;}\n    -- 在末尾插入\n    table.insert(fruits,&quot;mango&quot;)\n    print(&quot;索引为 4 的元素为 &quot;,fruits[4])\n    \n    -- 在索引为 2 的键处插入\n    table.insert(fruits,2,&quot;grapes&quot;)\n    print(&quot;索引为 2 的元素为 &quot;,fruits[2])\n    \n    print(&quot;最后一个元素为 &quot;,fruits[5])\n    table.remove(fruits)\n    print(&quot;移除后最后一个元素为 &quot;,fruits[5])    \n    \n    --排序\n    fruits = {&quot;banana&quot;,&quot;orange&quot;,&quot;apple&quot;,&quot;grapes&quot;}\n    print(&quot;排序前&quot;)\n    for k,v in ipairs(fruits) do\n        print(k,v)\n    end\n    \n    table.sort(fruits)\n    print(&quot;排序后&quot;)\n    for k,v in ipairs(fruits) do\n        print(k,v)\n    end\n</code></pre>\n<h5><span id=\"table-数组\">table – 数组</span></h5>\n<pre><code>1. 一维数组\n    array = {&quot;Lua&quot;, &quot;Tutorial&quot;}\n    \n    for i= 0, 2 do\n       print(array[i])\n    end\n2. 多维数组\n     -- 初始化数组\n     array = {}\n     for i=1,3 do\n        array[i] = {}\n           for j=1,3 do\n              array[i][j] = i*j\n           end\n     end\n     \n     -- 访问数组\n     for i=1,3 do\n        for j=1,3 do\n           print(array[i][j])\n        end\n     end   \n</code></pre>\n<h4><span id=\"function函数\">function（函数）</span></h4>\n<pre><code>1.在 Lua 中，函数是被看作是&quot;一类公民（First-Class Value）&quot;\n    function factorial1(n)\n        if n == 0 then\n            return 1\n        else\n            return n * factorial1(n - 1)\n        end\n    end\n    print(factorial1(5))\n    factorial2 = factorial1\n    print(factorial2(5))\n \n2.function 可以以匿名函数（anonymous function）的方式通过参数传递\n    -- function_test2.lua 脚本文件\n    function testFun(tab,fun)\n        for k ,v in pairs(tab) do\n            print(fun(k,v));\n        end\n    end\n    \n    \n    tab={key1=&quot;val1&quot;,key2=&quot;val2&quot;};\n    testFun(tab,\n    function(key,val)--匿名函数\n        return key..&quot;=&quot;..val;\n    end\n    );  \n3. 多返回值\n    Lua函数中，在return后列出要返回的值的列表即可返回多值\n        function maximum (a)\n            local mi = 1             -- 最大值索引\n            local m = a[mi]          -- 最大值\n            for i,val in ipairs(a) do\n               if val &gt; m then\n                   mi = i\n                   m = val\n               end\n            end\n            return m, mi\n        end\n        \n        print(maximum({8,10,23,12,5}))     \n</code></pre>\n<h5><span id=\"函数定义\">函数定义</span></h5>\n<pre><code>optional_function_scope function function_name( argument1, argument2, argument3..., argumentn)\n    function_body\n    return result_params_comma_separated\nend\n\noptional_function_scope: 该参数是可选的制定函数是全局函数还是局部函数，未设置该参数默认为全局函数，如果你需要设置函数为局部函数需要使用关键字 local。\nfunction_name: 指定函数名称。\nargument1, argument2, argument3..., argumentn: 函数参数，多个参数以逗号隔开，函数也可以不带参数。\nfunction_body: 函数体，函数中需要执行的代码语句块。\nresult_params_comma_separated: 函数返回值，Lua语言函数可以返回多个值，每个值以逗号隔开。\n</code></pre>\n<h5><span id=\"函数的可变参数\">函数的可变参数</span></h5>\n<pre><code>   1. 在函数参数列表中使用三点 ... 表示函数有可变的参数\n        function add(...)  \n        local s = 0  \n          for i, v in ipairs{...} do   --&gt; {...} 表示一个由所有变长参数构成的数组  \n            s = s + v  \n          end  \n          return s  \n        end  \n        print(add(3,4,5,6,7))  ---&gt;25\n   2. select(&quot;#&quot;,...) 来获取可变参数的数量\n            function average(...)\n               result = 0\n               local arg={...}\n               for i,v in ipairs(arg) do\n                  result = result + v\n               end\n               print(&quot;总共传入 &quot; .. select(&quot;#&quot;,...) .. &quot; 个数&quot;)\n               return result/select(&quot;#&quot;,...)\n            end\n            \n            print(&quot;平均值为&quot;,average(10,5,3,4,5,6))\n        \n        在遍历变长参数的时候只需要使用 {…}，然而变长参数可能会包含一些 nil，那么就可以用 select 函数来访问变长参数了：select('#', …) 或者 select(n, …)\n        select('#', …) 返回可变参数的长度\n        select(n, …) 用于访问 n 到 select('#',…) 的参数\n        调用select时，必须传入一个固定实参selector(选择开关)和一系列变长参数。如果selector为数字n,那么select返回它的第n个可变实参，否则只能为字符串&quot;#&quot;,这样select会返回变长参数的总数\n            do  \n                function foo(...)  \n                    for i = 1, select('#', ...) do  --&gt;获取参数总数\n                        local arg = select(i, ...); --&gt;读取参数\n                        print(&quot;arg&quot;, arg);  \n                    end  \n                end  \n              \n                foo(1, 2, 3, 4);  \n            end\n</code></pre>\n<h4><span id=\"thread线程\">thread(线程)</span></h4>\n<pre><code>在 Lua 里，最主要的线程是协同程序（coroutine）。\n协程跟线程（thread）差不多，拥有自己独立的栈、局部变量和指令指针，可以跟其他协同程序共享全局变量和其他大部分东西。\n线程跟协程的区别：线程可以同时多个运行，而协程任意时刻只能运行一个，并且处于运行状态的协程只有被挂起（suspend）时才会暂停。\n</code></pre>\n<h4><span id=\"userdata自定义类型\">userdata(自定义类型)</span></h4>\n<pre><code>userdata 是一种用户自定义数据，用于表示一种由应用程序或 C/C++ 语言库所创建的类型，可以将任意 C/C++ 的任意数据类型的数据（通常是 struct 和 指针）存储到 Lua 变量中调用。\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1>Lua基本语法</h1>\n<h3>编程模式</h3>\n<pre><code>1. 交互式编程 (shell)\n    与python的shell使用方法一致，直接在终端下运行lua命令即可\n2. 脚本式编程\n    创建xxxx.lua文件，然后使用lua xxxx.lua命令或者是luajit xxxx.lua文件即可进行运行\n</code></pre>\n<h3>注释</h3>\n<pre><code>1.单行注释\n    --\n2.多行注释\n    --[[\n    多行注释\n    多行注释\n    --]]   \n</code></pre>\n<h3>标示符</h3>\n<pre><code>Lua 是一个区分大小写的编程语言\nLua 标示符用于定义一个变量，函数获取其他用户定义的项。标示符以一个字母 A 到 Z 或 a 到 z 或下划线 _ 开头后加上0个或多个字母，下划线，数字(0到9)\nLua 不允许使用特殊字符如 @, $, 和 % 来定义标示符\n最好不要使用下划线加大写字母的标示符，因为Lua的保留字也是这样的\n一般约定，以下划线开头连接一串大写字母的名字（比如 _VERSION）被保留用于 Lua 内部全局变量\n</code></pre>\n<h3>关键词</h3>\n<pre><code>and    break    do    else\nelseif    end    false    for\nfunction    if    in    local\nnil    not    or    repeat\nreturn    then    true    until\nwhile\n</code></pre>\n<h3>变量</h3>\n<pre><code>Lua 变量有三种类型：全局变量、局部变量、表中的域\n变量在使用前，必须在代码中进行声明，即创建该变量\n变量的默认值均为 nil。\n\n1.全局变量\n    (1)在默认情况下，变量总是认为是全局的。\n    (2)全局变量不需要声明，给一个变量赋值后即创建了这个全局变量，访问一个没有初始化的全局变量也不会出错，只不过得到的结果是：nil。\n    (3)如果你想删除一个全局变量，只需要将变量赋值为nil。\n    (4)Lua 中的变量全是全局变量，那怕是语句块或是函数里，除非用 local 显式声明为局部变量。\n2.局部变量\n    局部变量的作用域为从声明位置开始到所在语句块结束。\n3.表中的域\n</code></pre>\n<h4>赋值</h4>\n<pre><code>1. 使用&quot;=&quot;号进行赋值\n2. Lua可以对多个变量同时赋值，变量列表和值列表的各个元素用逗号分开，赋值语句右边的值会依次赋给左边的变量\n    a,b=21,22\n3. 赋值语句Lua会先计算右边所有的值然后再执行赋值操作，所以我们可以这样进行交换变量的值\n    x, y = y, x                     -- swap 'x' for 'y'\n    a[i], a[j] = a[j], a[i]         -- swap 'a[i]' for 'a[j]'  \n4. 重点: 当变量个数和值的个数不一致时，Lua会一直以变量个数为基础采取以下策略\n    a. 变量个数 &gt; 值的个数             按变量个数补足nil\n    b. 变量个数 &lt; 值的个数             多余的值会被忽略\n    \n    a, b, c = 0, 1\n    print(a,b,c)             --&gt; 0   1   nil  \n    \n    a, b = a+1, b+1, b+2     -- value of b+2 is ignored\n    print(a,b)               --&gt; 1   2\n    \n    a, b, c = 0\n    print(a,b,c)             --&gt; 0   nil   nil\n5. 多值赋值经常用来交换变量，或将函数调用返回给变量\n       a, b = f()\n       f()返回两个值，第一个赋给a，第二个赋给b。\n       应该尽可能的使用局部变量，有两个好处：\n           1. 避免命名冲突。\n           2. 访问局部变量的速度比全局变量更快。\n</code></pre>\n<h3>数据类型</h3>\n<pre><code>Lua是动态类型语言，变量不要类型定义,只需要为变量赋值。 值可以存储在变量中，作为参数传递或结果返回。\nLua中有8个基本类型分别为：nil、boolean、number、string、userdata、function、thread和table。\n\n数据类型\t描述\nnil\t            这个最简单，只有值nil属于该类，表示一个无效值（在条件表达式中相当于false）。\nboolean\t        包含两个值：false和true。Lua认为false和nil为&quot;假&quot;,其他任何值都是&quot;真&quot;,包括0\nnumber\t        表示双精度类型的实浮点数\nstring\t        字符串由一对双引号或单引号来表示\nfunction\t    由 C 或 Lua 编写的函数\nuserdata\t    表示任意存储在变量中的C数据结构\nthread\t        表示执行的独立线路，用于执行协同程序\ntable\t        Lua 中的表（table）其实是一个&quot;关联数组&quot;（associative arrays），数组的索引可以是数字或者是字符串。在 Lua 里，table 的创建是通过&quot;构造表达式&quot;来完成，最简单构造表达式是{}，用来创建一个空表。\n</code></pre>\n<h4>获取数据的类型</h4>\n<pre><code>重点: type(xxx) -- 返回的都是字符串形式的数据类型\n      type(type(xxx)) == &quot;string&quot;\n\nprint(type(&quot;Hello world&quot;))      --&gt; string      \nprint(type(10.4*3))             --&gt; number\nprint(type(print))              --&gt; function\nprint(type(type))               --&gt; function\nprint(type(true))               --&gt; boolean\nprint(type(nil))                --&gt; nil\nprint(type(type(X)))            --&gt; string\n</code></pre>\n<h4>获取当前变量的数据类型是否与设想的一致</h4>\n<pre><code>v = &quot;Hello World.&quot;\nif type(v) == &quot;string&quot;\nthen\n    print(&quot;字符串类型&quot;)\nend\n</code></pre>\n<h4>nil (空值)</h4>\n<pre><code>nil 类型表示一种没有任何有效值，它只有一个值 -- nil\n作用:对于全局变量和 table，nil 还有一个&quot;删除&quot;作用，给全局变量或者 table 表里的变量赋一个 nil 值，等同于把它们删掉\n   \n    例子:\n        tab1 = { key1 = &quot;val1&quot;, key2 = &quot;val2&quot;, &quot;val3&quot; }\n        for k, v in pairs(tab1) do\n            print(k .. &quot; - &quot; .. v)\n        end\n         \n        tab1.key1 = nil\n        for k, v in pairs(tab1) do\n            print(k .. &quot; - &quot; .. v)\n        end\n</code></pre>\n<h4>boolean(布尔值)</h4>\n<pre><code>boolean 类型只有两个可选值：true（真） 和 false（假），Lua 把 false 和 nil 看作是&quot;假&quot;，其他的都为&quot;真&quot;,包括&quot;0&quot;也是真\n</code></pre>\n<h4>number(数字)</h4>\n<pre><code>Lua 默认只有一种 number 类型 -- double（双精度）类型（默认类型可以修改 luaconf.h 里的定义）\n</code></pre>\n<h4>string(字符串)</h4>\n<pre><code>1. 字符串由一对双引号或单引号来表示。\n    string1 = &quot;this is string1&quot;\n    string2 = 'this is string2'\n2. 两个方括号 &quot;[[]]&quot; 来表示&quot;一块&quot;字符串,用于多行文本 \n    html = [[\n    &lt;html&gt;\n    &lt;head&gt;&lt;/head&gt;\n    &lt;body&gt;\n        &lt;a href=&quot;http://www.runoob.com/&quot;&gt;菜鸟教程&lt;/a&gt;\n    &lt;/body&gt;\n    &lt;/html&gt;\n    ]]\n3. 在对一个数字字符串上进行算术操作时，Lua 会尝试将这个数字字符串转成一个数字\n    &gt; print(&quot;2&quot; + 6)\n    8.0\n    &gt; print(&quot;2&quot; + &quot;6&quot;)\n    8.0\n    &gt; print(&quot;2 + 6&quot;)\n    2 + 6\n    &gt; print(&quot;-2e2&quot; * &quot;6&quot;)\n    -1200.0\n4. 字符串连接符&quot;..&quot;\n     &gt; print(&quot;a&quot; .. 'b')\n     ab\n     &gt; print(157 .. 428)\n     157428\n     &gt; \n5. 计算字符串长度\n     &gt; len = &quot;www.runoob.com&quot;\n     &gt; print(#len)\n     14\n     &gt; print(#&quot;www.runoob.com&quot;)\n     14\n</code></pre>\n<h5>字符串用法拓展</h5>\n<pre><code>1. 常规的转义符号\n    \\a  响铃(BEL)\n    \\b  退格(BS) ，将当前位置移到前一列\n    \\f  换页(FF)，将当前位置移到下页开头\n    \\n  换行(LF) ，将当前位置移到下一行开头\n    \\r  回车(CR) ，将当前位置移到本行开头\n    \\t  水平制表(HT) （跳到下一个TAB位置）\n    \\v  垂直制表(VT)\n    \\\\  代表一个反斜线字符''\\'\n    \\'  代表一个单引号（撇号）字符\n    \\&quot;  代表一个双引号字符\n    \\0  空字符(NULL)\n    \\ddd    1到3位八进制数所代表的任意字符\n    \\xhh    1到2位十六进制所代表的任意字符\n\n2. 字符串操作\n    (1)string.upper(argument):字符串全部转为大写字母  \n    (2)string.lower(argument):字符串全部转为小写字母\n    (3)string.gsub(mainString,findString,replaceString,num):在字符串中替换,mainString为要替换的字符串， findString 为被替换的字符，replaceString 要替换的字符，num 替换次数（可以忽略，则全部替换）\n        &gt; string.gsub(&quot;aaaa&quot;,&quot;a&quot;,&quot;z&quot;,3);\n        zzza    3\n    (4)string.find (str, substr, [init, [end]]):在一个指定的目标字符串中搜索指定的内容(第三个参数为索引),返回其具体位置。不存在则返回 nil\n        &gt; string.find(&quot;Hello Lua user&quot;, &quot;Lua&quot;, 1) \n        7    9\n    (5)string.reverse(arg):字符串反转    \n    (6)string.format(...):返回一个类似printf的格式化字符串\n        &gt; string.format(&quot;the value is:%d&quot;,4)\n        the value is:4\n    (7)string.char(arg) 和 string.byte(arg[,int]): char 将整型数字转成字符并连接， byte 转换字符为整数值(可以指定某个字符，默认第一个字符)。\n        &gt; string.char(97,98,99,100)\n        abcd\n        &gt; string.byte(&quot;ABCD&quot;,4)\n        68\n        &gt; string.byte(&quot;ABCD&quot;)\n        65\n    (8)string.len(arg):计算字符串长度。\n    (9)string.rep(string, n):返回字符串string的n个拷贝\n    (10)&quot;..&quot; 符号: 链接两个字符串\n    (11)string.gmatch(str, pattern):回一个迭代器函数，每一次调用这个函数，返回一个在字符串 str 找到的下一个符合 pattern 描述的子串。如果参数 pattern 描述的字符串没有找到，迭代函数返回nil。\n        &gt; for word in string.gmatch(&quot;Hello Lua user&quot;, &quot;%a+&quot;) do print(word) end\n        Hello\n        Lua\n        user\n    (12)string.match(str, pattern, init):string.match()只寻找源字串str中的第一个配对. 参数init可选, 指定搜寻过程的起点, 默认为1。 \n                                        在成功配对时, 函数将返回配对表达式中的所有捕获结果; 如果没有设置捕获标记, 则返回整个配对字符串. 当没有成功的配对时, 返回nil。\n         &gt; = string.match(&quot;I have 2 questions for you.&quot;, &quot;%d+ %a+&quot;)\n         2 questions\n         &gt; = string.format(&quot;%d, %q&quot;, string.match(&quot;I have 2 questions for you.&quot;, &quot;(%d+) (%a+)&quot;))\n         2, &quot;questions&quot;  \n3.字符串格式化         \n     Lua 提供了 string.format() 函数来生成具有特定格式的字符串, 函数的第一个参数是格式 , 之后是对应格式中每个代号的各种数据。\n        %c - 接受一个数字, 并将其转化为ASCII码表中对应的字符\n        %d, %i - 接受一个数字并将其转化为有符号的整数格式\n        %o - 接受一个数字并将其转化为八进制数格式\n        %u - 接受一个数字并将其转化为无符号整数格式\n        %x - 接受一个数字并将其转化为十六进制数格式, 使用小写字母\n        %X - 接受一个数字并将其转化为十六进制数格式, 使用大写字母\n        %e - 接受一个数字并将其转化为科学记数法格式, 使用小写字母e\n        %E - 接受一个数字并将其转化为科学记数法格式, 使用大写字母E\n        %f - 接受一个数字并将其转化为浮点数格式\n        %g(%G) - 接受一个数字并将其转化为%e(%E, 对应%G)及%f中较短的一种格式\n        %q - 接受一个字符串并将其转化为可安全被Lua编译器读入的格式\n        %s - 接受一个字符串并按照给定的参数格式化该字符串\n     为进一步细化格式, 可以在%号后添加参数. 参数将以如下的顺序读入:\n        (1) 符号: 一个+号表示其后的数字转义符将让正数显示正号. 默认情况下只有负数显示符号.\n        (2) 占位符: 一个0, 在后面指定了字串宽度时占位用. 不填时的默认占位符是空格.\n        (3) 对齐标识: 在指定了字串宽度时, 默认为右对齐, 增加-号可以改为左对齐.\n        (4) 宽度数值\n        (5) 小数位数/字串裁切: 在宽度数值后增加的小数部分n, 若后接f(浮点数转义符, 如%6.3f)则设定该浮点数的小数只保留n位, 若后接s(字符串转义符, 如%5.3s)则设定该字符串只显示前n位\n     例子:\n        string1 = &quot;Lua&quot;\n        string2 = &quot;Tutorial&quot;\n        number1 = 10\n        number2 = 20\n        -- 基本字符串格式化\n        print(string.format(&quot;基本格式化 %s %s&quot;,string1,string2))\n        -- 日期格式化\n        date = 2; month = 1; year = 2014\n        print(string.format(&quot;日期格式化 %02d/%02d/%03d&quot;, date, month, year))\n        -- 十进制格式化\n        print(string.format(&quot;%.4f&quot;,1/3))\n4. 字符与整数相互转换  \n     -- 字符转换\n     -- 转换第一个字符\n     print(string.byte(&quot;Lua&quot;))\n     -- 转换第三个字符\n     print(string.byte(&quot;Lua&quot;,3))\n     -- 转换末尾第一个字符\n     print(string.byte(&quot;Lua&quot;,-1))\n     -- 第二个字符\n     print(string.byte(&quot;Lua&quot;,2))\n     -- 转换末尾第二个字符\n     print(string.byte(&quot;Lua&quot;,-2))\n     -- 整数 ASCII 码转换为字符\n     print(string.char(97))   \n</code></pre>\n<h5>字符串–正则表达式</h5>\n<pre><code> Lua 中的匹配模式直接用常规的字符串来描述。 它用于模式匹配函数 string.find, string.gmatch, string.gsub, string.match。\n 你还可以在模式串中使用字符类。\n 字符类指可以匹配一个特定字符集合内任何字符的模式项。比如，字符类%d匹配任意数字。所以你可以使用模式串 '%d%d/%d%d/%d%d%d%d' 搜索 dd/mm/yyyy 格式的日期：\n 下面的表列出了Lua支持的所有字符类：\n 单个字符(除 ^$()%.[]*+-? 外): 与该字符自身配对\n .(点): 与任何字符配对\n %a: 与任何字母配对\n %c: 与任何控制符配对(例如\\n)\n %d: 与任何数字配对\n %l: 与任何小写字母配对\n %p: 与任何标点(punctuation)配对\n %s: 与空白字符配对\n %u: 与任何大写字母配对\n %w: 与任何字母/数字配对\n %x: 与任何十六进制数配对\n %z: 与任何代表0的字符配对\n %x(此处x是非字母非数字字符): 与字符x配对. 主要用来处理表达式中有功能的字符(^$()%.[]*+-?)的配对问题, 例如%%与%配对\n [数个字符类]: 与任何[]中包含的字符类配对. 例如[%w_]与任何字母/数字, 或下划线符号(_)配对\n [^数个字符类]: 与任何不包含在[]中的字符类配对. 例如[^%s]与任何非空白字符配对        \n \n 当上述的字符类用大写书写时, 表示与非此字符类的任何字符配对. 例如, %S表示与任何非空白字符配对.例如，'%A'非字母的字符:\n &gt; print(string.gsub(&quot;hello, up-down!&quot;, &quot;%A&quot;, &quot;.&quot;))\n hello..up.down.    4\n 数字4不是字符串结果的一部分，他是gsub返回的第二个结果，代表发生替换的次数。\n 在模式匹配中有一些特殊字符，他们有特殊的意义，Lua中的特殊字符如下：\n ( ) . % + - * ? [ ^ $\n '%' 用作特殊字符的转义字符，因此 '%.' 匹配点；'%%' 匹配字符 '%'。转义字符 '%'不仅可以用来转义特殊字符，还可以用于所有的非字母的字符。\n  \n  模式条目可以是：\n      单个字符类匹配该类别中任意单个字符；\n      单个字符类跟一个 '*'， 将匹配零或多个该类的字符。 这个条目总是匹配尽可能长的串；\n      单个字符类跟一个 '+'， 将匹配一或更多个该类的字符。 这个条目总是匹配尽可能长的串；\n      单个字符类跟一个 '-'， 将匹配零或更多个该类的字符。 和 '*' 不同， 这个条目总是匹配尽可能短的串；\n      单个字符类跟一个 '?'， 将匹配零或一个该类的字符。 只要有可能，它会匹配一个；\n      %n， 这里的 n 可以从 1 到 9； 这个条目匹配一个等于 n 号捕获物（后面有描述）的子串。\n      %bxy， 这里的 x 和 y 是两个明确的字符； 这个条目匹配以 x 开始 y 结束， 且其中 x 和 y 保持 平衡 的字符串。 意思是，如果从左到右读这个字符串，对每次读到一个 x 就 +1 ，读到一个 y 就 -1， 最终结束处的那个 y 是第一个记数到 0 的 y。 举个例子，条目 %b() 可以匹配到括号平衡的表达式。\n      %f[set]， 指 边境模式； 这个条目会匹配到一个位于 set 内某个字符之前的一个空串， 且这个位置的前一个字符不属于 set 。 集合 set 的含义如前面所述。 匹配出的那个空串之开始和结束点的计算就看成该处有个字符 '\\0' 一样。\n  模式：\n    模式 指一个模式条目的序列。 在模式最前面加上符号 '^' 将锚定从字符串的开始处做匹配。 在模式最后面加上符号 '$' 将使匹配过程锚定到字符串的结尾。 如果 '^' 和 '$' 出现在其它位置，它们均没有特殊含义，只表示自身。\n  捕获：\n    模式可以在内部用小括号括起一个子模式； 这些子模式被称为 捕获物。 当匹配成功时，由 捕获物 匹配到的字符串中的子串被保存起来用于未来的用途。 捕获物以它们左括号的次序来编号。 例如，对于模式 &quot;(a*(.)%w(%s*))&quot; ， 字符串中匹配到 &quot;a*(.)%w(%s*)&quot; 的部分保存在第一个捕获物中 （因此是编号 1 ）； 由 &quot;.&quot; 匹配到的字符是 2 号捕获物， 匹配到 &quot;%s*&quot; 的那部分是 3 号。\n  作为一个特例，空的捕获 () 将捕获到当前字符串的位置（它是一个数字）。 例如，如果将模式 &quot;()aa()&quot; 作用到字符串 &quot;flaaap&quot; 上，将产生两个捕获物： 3 和 5 。\n</code></pre>\n<h4>table(表)</h4>\n<pre><code>在 Lua 里，table 的创获取数据的类型建是通过&quot;构造表达式&quot;来完成，最简单构造表达式是{}，用来创建一个空表\n也可以在表里添加一些数据，直接初始化表:\n1. 初始化表与移除引用\n    -- 创建一个空的 table\n    local tbl1 = {}         \n    -- 直接初始表\n    local tbl2 = {&quot;apple&quot;, &quot;pear&quot;, &quot;orange&quot;, &quot;grape&quot;}\n    -- 初始化表\n    mytable = {} \n    -- 指定值\n    mytable[1]= &quot;Lua&quot;\n    -- 移除引用\n    mytable = nil\n    -- lua 垃圾回收会释放内存\n\n2. -- 创建一个空的 table\n   local tbl1 = {}\n   -- 直接初始表\n   local tbl2 = {&quot;apple&quot;, &quot;pear&quot;, &quot;orange&quot;, &quot;grape&quot;}\n\n3. Lua 中的表（table）其实是一个&quot;关联数组&quot;（associative arrays），数组的索引可以是数字或者是字符串\n  table 不会固定长度大小，有新数据添加时 table 长度会自动增长，没初始的 table 都是 nil。\n  重点: 不同于其他语言的数组把 0 作为数组的初始索引，在 Lua 里表的默认初始索引一般以 1 开始  \n        local tbl = {&quot;apple&quot;, &quot;pear&quot;, &quot;orange&quot;, &quot;grape&quot;}\n        for key, val in pairs(tbl) do\n           print(&quot;Key&quot;, key)\n        end\n4. 索引,对 table 的索引使用方括号 []。Lua 也提供了&quot;.&quot;操作\n    &gt; site = {}\n    &gt; site[&quot;key&quot;] = &quot;www.w3cschool.cc&quot;\n    &gt; print(site[&quot;key&quot;])\n    www.w3cschool.cc\n    &gt; print(site.key)\n    www.w3cschool.cc\n</code></pre>\n<h5>table – 操作</h5>\n<pre><code>1.table.concat (table [, sep [, start [, end]]]):concat是concatenate(连锁, 连接)的缩写. table.concat()函数列出参数中指定table的数组部分从start位置到end位置的所有元素, 元素间以指定的分隔符(sep)隔开。\n2.table.insert (table, [pos,] value):在table的数组部分指定位置(pos)插入值为value的一个元素. pos参数可选, 默认为数组部分末尾.\n3.table.remove (table [, pos]):返回table数组部分位于pos位置的元素. 其后的元素会被前移. pos参数可选, 默认为table长度, 即从最后一个元素删起。\n4.table.sort (table [, comp]):对给定的table进行升序排序\n</code></pre>\n<h5>table – table间连接,table中的插入,移除,排序</h5>\n<pre><code>使用 concat() 方法来连接两个 table\n    fruits = {&quot;banana&quot;,&quot;orange&quot;,&quot;apple&quot;}\n    -- 返回 table 连接后的字符串\n    print(&quot;连接后的字符串 &quot;,table.concat(fruits)\n    -- 指定连接字符\n    print(&quot;连接后的字符串 &quot;,table.concat(fruits,&quot;, &quot;))\n    -- 指定索引来连接 table\n    print(&quot;连接后的字符串 &quot;,table.concat(fruits,&quot;, &quot;, 2,3))\n    \n    fruits = {&quot;banana&quot;,&quot;orange&quot;,&quot;apple&quot;}\n    -- 在末尾插入\n    table.insert(fruits,&quot;mango&quot;)\n    print(&quot;索引为 4 的元素为 &quot;,fruits[4])\n    \n    -- 在索引为 2 的键处插入\n    table.insert(fruits,2,&quot;grapes&quot;)\n    print(&quot;索引为 2 的元素为 &quot;,fruits[2])\n    \n    print(&quot;最后一个元素为 &quot;,fruits[5])\n    table.remove(fruits)\n    print(&quot;移除后最后一个元素为 &quot;,fruits[5])    \n    \n    --排序\n    fruits = {&quot;banana&quot;,&quot;orange&quot;,&quot;apple&quot;,&quot;grapes&quot;}\n    print(&quot;排序前&quot;)\n    for k,v in ipairs(fruits) do\n        print(k,v)\n    end\n    \n    table.sort(fruits)\n    print(&quot;排序后&quot;)\n    for k,v in ipairs(fruits) do\n        print(k,v)\n    end\n</code></pre>\n<h5>table – 数组</h5>\n<pre><code>1. 一维数组\n    array = {&quot;Lua&quot;, &quot;Tutorial&quot;}\n    \n    for i= 0, 2 do\n       print(array[i])\n    end\n2. 多维数组\n     -- 初始化数组\n     array = {}\n     for i=1,3 do\n        array[i] = {}\n           for j=1,3 do\n              array[i][j] = i*j\n           end\n     end\n     \n     -- 访问数组\n     for i=1,3 do\n        for j=1,3 do\n           print(array[i][j])\n        end\n     end   \n</code></pre>\n<h4>function（函数）</h4>\n<pre><code>1.在 Lua 中，函数是被看作是&quot;一类公民（First-Class Value）&quot;\n    function factorial1(n)\n        if n == 0 then\n            return 1\n        else\n            return n * factorial1(n - 1)\n        end\n    end\n    print(factorial1(5))\n    factorial2 = factorial1\n    print(factorial2(5))\n \n2.function 可以以匿名函数（anonymous function）的方式通过参数传递\n    -- function_test2.lua 脚本文件\n    function testFun(tab,fun)\n        for k ,v in pairs(tab) do\n            print(fun(k,v));\n        end\n    end\n    \n    \n    tab={key1=&quot;val1&quot;,key2=&quot;val2&quot;};\n    testFun(tab,\n    function(key,val)--匿名函数\n        return key..&quot;=&quot;..val;\n    end\n    );  \n3. 多返回值\n    Lua函数中，在return后列出要返回的值的列表即可返回多值\n        function maximum (a)\n            local mi = 1             -- 最大值索引\n            local m = a[mi]          -- 最大值\n            for i,val in ipairs(a) do\n               if val &gt; m then\n                   mi = i\n                   m = val\n               end\n            end\n            return m, mi\n        end\n        \n        print(maximum({8,10,23,12,5}))     \n</code></pre>\n<h5>函数定义</h5>\n<pre><code>optional_function_scope function function_name( argument1, argument2, argument3..., argumentn)\n    function_body\n    return result_params_comma_separated\nend\n\noptional_function_scope: 该参数是可选的制定函数是全局函数还是局部函数，未设置该参数默认为全局函数，如果你需要设置函数为局部函数需要使用关键字 local。\nfunction_name: 指定函数名称。\nargument1, argument2, argument3..., argumentn: 函数参数，多个参数以逗号隔开，函数也可以不带参数。\nfunction_body: 函数体，函数中需要执行的代码语句块。\nresult_params_comma_separated: 函数返回值，Lua语言函数可以返回多个值，每个值以逗号隔开。\n</code></pre>\n<h5>函数的可变参数</h5>\n<pre><code>   1. 在函数参数列表中使用三点 ... 表示函数有可变的参数\n        function add(...)  \n        local s = 0  \n          for i, v in ipairs{...} do   --&gt; {...} 表示一个由所有变长参数构成的数组  \n            s = s + v  \n          end  \n          return s  \n        end  \n        print(add(3,4,5,6,7))  ---&gt;25\n   2. select(&quot;#&quot;,...) 来获取可变参数的数量\n            function average(...)\n               result = 0\n               local arg={...}\n               for i,v in ipairs(arg) do\n                  result = result + v\n               end\n               print(&quot;总共传入 &quot; .. select(&quot;#&quot;,...) .. &quot; 个数&quot;)\n               return result/select(&quot;#&quot;,...)\n            end\n            \n            print(&quot;平均值为&quot;,average(10,5,3,4,5,6))\n        \n        在遍历变长参数的时候只需要使用 {…}，然而变长参数可能会包含一些 nil，那么就可以用 select 函数来访问变长参数了：select('#', …) 或者 select(n, …)\n        select('#', …) 返回可变参数的长度\n        select(n, …) 用于访问 n 到 select('#',…) 的参数\n        调用select时，必须传入一个固定实参selector(选择开关)和一系列变长参数。如果selector为数字n,那么select返回它的第n个可变实参，否则只能为字符串&quot;#&quot;,这样select会返回变长参数的总数\n            do  \n                function foo(...)  \n                    for i = 1, select('#', ...) do  --&gt;获取参数总数\n                        local arg = select(i, ...); --&gt;读取参数\n                        print(&quot;arg&quot;, arg);  \n                    end  \n                end  \n              \n                foo(1, 2, 3, 4);  \n            end\n</code></pre>\n<h4>thread(线程)</h4>\n<pre><code>在 Lua 里，最主要的线程是协同程序（coroutine）。\n协程跟线程（thread）差不多，拥有自己独立的栈、局部变量和指令指针，可以跟其他协同程序共享全局变量和其他大部分东西。\n线程跟协程的区别：线程可以同时多个运行，而协程任意时刻只能运行一个，并且处于运行状态的协程只有被挂起（suspend）时才会暂停。\n</code></pre>\n<h4>userdata(自定义类型)</h4>\n<pre><code>userdata 是一种用户自定义数据，用于表示一种由应用程序或 C/C++ 语言库所创建的类型，可以将任意 C/C++ 的任意数据类型的数据（通常是 struct 和 指针）存储到 Lua 变量中调用。\n</code></pre>\n"},{"title":"微服务API网关框架(2)--Nginx的使用","catalog":true,"date":"2018-12-19T08:52:03.000Z","subtitle":null,"header-img":"Demo.png","catagories":["微服务API网关"],"_content":"\n# Nginx\n\n## Nginx命令\n\n### Nginx的基本配置\n    Nginx的主配置文件是：nginx.conf，nginx.conf主要组成如下：\n    \n    # 全局区   有一个工作子进程，一般设置为CPU数 * 核数\n    worker_processes  1; \n    events {\n        # 一般是配置nginx进程与连接的特性\n        # 如1个word能同时允许多少连接，一个子进程最大允许连接1024个连接\n         worker_connections  1024;\n    }\n     # 配置HTTP服务器配置段\n    http {\n        # 配置虚拟主机段\n        server {\n             # 定位，把特殊的路径或文件再次定位。\n             location  {\n                       \n             } \n        }\n         server {\n                       \n         } \n    }\n\n### nginx启动\n    指令：nginx程序   -c   nginx配置文件\n    # /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf\n    \n### nginx重启\n    #cd /usr/local/nginx/sbin\n    ##重启\n    # ./nginx -s reload   \n    进入nginx可执行程序的目录\n    # cd /usr/local/nginx/sbin/\n    # ./nginx -s reload\n    nginx: [error] invalid PID number \"\" in \"/usr/local/nginx/logs/nginx.pid\"\n    重启是建立在nginx服务需要启动\n    \n### nginx停止\n    # ./nginx -s stop \n    # ./nginx -s quit\n    \n    quit 是一个优雅的关闭方式，Nginx在退出前完成已经接受的连接请求\n    stop 是快速关闭，不管有没有正在处理的请求。\n    \n### 重新打开日志\n    # 用于日志切割   \n    # ./nginx -s reopen   \n    \n### nginx检查配置文件\n    检查配置文件是否正确\n    第一种\n    进入nginx可执行程序的目录\n    # cd /usr/local/nginx/sbin/\n    # ./nginx -t\n    \n    第二种\n    # /usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.conf\n\n## Nginx信号控制\n    Nginx支持2种进程模型Single和Master-Worker\n    Single是单进程，一般不适用，\n    Master-Worker是主进程和工作进程模型运行，主进程对工作进程管理。\n    Nginx允许我们通过信号来控制主进程，用信号的方式可以达到不影响现有连接的目的。 \n\n### 信号类型\n    INT，TERM\t\t快速关闭信号\n    QUIT\t\t\t从容关闭信号\n    HUP\t\t\t\t从容重启信号，一般用于修改配置文件后，重启\n    USR1\t\t\t重读日志，一般用于日志的切割\n    USR2\t\t\t平滑升级信号\n    WINCH\t\t\t从容关闭旧进程\n\n    具体语法:\n    kill    -信号选项    nginx的主进程号\n    例：\n    # kill -INT 26661 \n    # kill -HUP 4873\n\n#### Nginx的优雅停止\n    1）nginx停止\n    #  ps -ef | grep nginx 获得进程号\n    \n    第1种从容“优雅”停止\n    # kill -QUIT master进程号\n    # Nginx服务可以正常地处理完当前所有请求再停止服务\n    # 步骤：首先会关闭监听端口，停止接收新的连接，然后把当前正在处理的连接全部处理完，最后再退出进程。\n    \n    第2种快速停止\n    # kill -TERM master进程号\n    # kill -INT master进程号\n    # 快速停止服务时，worker进程与master进程在收到信号后会立刻跳出循环，退出进程。\n    第3种强制停止\n    # pkill -9 nginx\n    # 系统强杀nginx进程\n    \n    2）重启nginx\n    # kill -HUP master进程号\n\n#### Nginx平滑升级\n    原理:把服务器从低版本升级为高版本，强行停止服务器，会影响正在运行的进程。\n         平滑升级不会停掉正在进行中的进程，这些进程会继续处理请求。但不会再接受新请求，这些老的进程在处理完请求之后 会停止。此平滑升级过程中，新开的进程会被处理。\n\n    \n    一）平滑升级\n        进入nginx可执行程序的目录\n             #  cd /usr/local/nginx/sbin/\n             # ./nginx -V  #查看nginx版本\n    \n        1）下载高版本nginx http://nginx.org/download/nginx-1.13.1.tar.gz\n        执行指令\n        #  ./configure\n        # make    #不能执行 make install\n        # cd objs\n        此目录下 有高版本的nginx\n        备份低版本的nginx\n        cp nginx nginx.old\n        执行强制覆盖\n        cp -rfp objs/nginx /usr/local/nginx/sbin\n    \n        测试一下新复制过来文件生效情况：\n        # /usr/local/nginx/sbin/nginx -t\n        # ps -ef | grep nginx\n    \n        2）执行信号平滑升级\n            # kill -USR2 `cat /usr/local/nginx/logs/nginx.pid`  更新配置文件\n            给nginx发送USR2信号后，nginx会将logs/nginx.pid文件重命名为nginx.pid.oldbin，然后用新的可执行文件启动一个新的nginx主进程和对应的工作进程，并新建一个新的nginx.pid保存新的主进程号\n            \n            # ps -ef | grep nginx\n            \n            # ll logs/\n        \n        \n        3）kill -WINCH 旧的主进程号\n            旧的主进程号收到WINCH信号后，将旧进程号管理的旧的工作进程优雅的关闭。即一段时间后旧的工作进程全部关闭，只有新的工作进程在处理请求连接。\n            这时，依然可以恢复到旧的进程服务，因为旧的进程的监听socket还未停止。\n            处理完后，工作进程会自动关闭\n            # ps -ef | grep nginx\n        \n        4）# kill -QUIT `cat /usr/local/nginx/logs/nginx.pid.oldbin` 优雅的关闭\n            给旧的主进程发送QUIT信号后，旧的主进程退出，并移除logs/nginx.pid.oldbin文件，nginx的升级完成。\n        \n        升级完成了，最后在看一下升级后的版本\n    \n        查看\n        ./nginx -V\n        已经平滑升级成功\n    \n    二）中途停止升级，回滚到旧的nginx\n        在步骤(3)时，如果想回到旧的nginx不再升级\n        \n        (1)给旧的主进程号发送HUP命令，此时nginx不重新读取配置文件的情况下重新启动旧主进程的工作进程。\n            kill -HUP 9944 --旧主进程号\n            重启工作进程\n        (2)优雅的关闭新的主进程\n            kill -QUIT 10012  --新主进程号\n\n#### Nginx 用户\n    #以哪个用户，运行nginx应用\n    #nobody是个低权限用户，为了安全\n    #user nobody;\n\n#### Nginx 进程数设置    \n    worker_processes：表示开启nginx的worker进程的个数，nginx启动会开两种进程，master进程用来管理调度，worker进程用来处理请求；\n    上面表示两种设置方法，比如\n    方法一：worker_processes auto;\n    　　表示设置服务器cpu核数匹配开启nginx开启的worker进程数    \n    　　查看cpu核数：cat /proc/cpuinfo    \n    方法二：nginx设置cpu亲和力\n    　　worker_processes 8;    \n    　　worker_cpu_affinity 00000001 00000010 00000100 00001000 00010000 00100000 01000000 10000000;    \n    　　00000001表示启用第一个CPU内核，00000010表示启用第二个CPU内核，以此类推\n    \n    worker_cpu_affinity：表示开启八个进程，第一个进程对应着第一个CPU内核，第二个进程对应着第二个CPU内核，以此类推。\n        这种设置方法更高效，因将每个cpu核提供给固定的worker进程服务，减少cpu上下文切换带来的资源浪费\n    \n    如果服务器cpu有限\n        比如：2核CPU，开启2个进程，设置如下 \n        worker_processes     2;   \n        worker_cpu_affinity 01 10;  \n        比如：4核CPU,开启4个进程，设置如下\n        worker_processes     4;\n        worker_cpu_affinity 0001 0010 0100 1000;\n    \n    8核cpu , worker_processes=8\n    1个worker进程 能够最大打开的文件数（线程数）worker_connections=65535 （参考worker_rlimit_nofile  ---->  linux  ulimit -n）\n    最大的客户端连接数 max_clients = （多少个工作进程数）worker_processes * （1个工作线程的处理线程数）worker_connections    8*65535\n    \n#### Nginx的并发量计算\n    #nginx作为http服务器\n    #请求模型   client <---> nginx\n    #max_clients = worker_processes * worker_connections/2\n    \n    #nginx作为反向代理服务器的时候\n    #请求模型   client <---> nginx  <----> web server\n    #max_clients = worker_processes * worker_connections/4\n    (\n    为什么除以2：该公式基于http 1.1协议，一次请求大多数浏览器发送两次连接，并不是request和response响应占用两个线程（很多人也是这么认为，实际情况：请求是双向的，连接是没有方向的，由上面的图可以看出来)\n    为什么除以4：因nginx作为方向代理，客户端和nginx建立连接，nginx和后端服务器也要建立连接\n    )\n    \n    由此，我们可以计算nginx作为http服务器最大并发量(作为反向代理服务器自己类推)，可以为压测和线上环境的优化提供一些理论依据：\n    单位时间（keepalive_timeout）内nginx最大并发量C\n    C=worker_processes * worker_connections/2=8*65535/2\n    \n    而每秒的并发量CS\n    CS=worker_processes * worker_connections/(2*65)    \n    \n    \n#### Nginx全局错误日志\n    #全局错误日志 \n        #nginx的error_log类型如下（从左到右：debug最详细 crit最少）： \n        #[ debug | info | notice | warn | error | crit ] \n    \n    #例如：error_log logs/nginx_error.log  crit; \n    #解释：日志文件存储在nginx安装目录下的 logs/nginx_error.log ，错误类型为 crit ，也就是记录最少错误信息;\n        error_log  logs/error.log;\n        error_log  logs/notice.log  notice;\n        error_log  logs/info.log  info;\n    \n#### Nginx主进程ID\n    #PID文件，记录当前启动的nginx的进程ID\n        pid        logs/nginx.pid; # 主进程ID存放位置\n        \n#### Nginx的worker进程\n    worker_rlimit_nofile 65535;\n    \n    #这个参数表示worker进程最多能打开的文件句柄数，基于liunx系统ulimit设置\n    #查看系统文件句柄数最大值：ulimit -n\n    #Linux一切皆文件，所有请求过来最终目的访问文件，所以该参数值设置等同于liunx系统ulimit设置为优\n    #可以通过linux命令设置  最大的文件句柄数65535\n\n#### Nginx工作模式与连接数上限\n    events {\n       #网络模型高效(相当于建立索引查找结果)，nginx配置应该启用该参数\n       #但是仅用于linux2.6以上内核,可以大大提高nginx的性能\n       use   epoll;             \n       #该参数表示设置一个worker进程最多开启多少线程数\n       #优化设置应该等同于worker_rlimit_nofile设置值，表明一个线程处理一个http请求，同时可以处理一个文件数，各个模块之间协调合作不等待。\n       worker_connections  65535;\n    }\n                \n#### Nginx负载均衡\n     #设定http服务器，利用它的反向代理功能提供负载均衡支持\n         http {\n              #设定mime类型,类型由mime.type文件定义\n              #MIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来#打开的方式类型，\n              当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开\n             include       /etc/nginx/mime.types;\n             default_type  application/octet-stream;\n             #设定日志格式\n            log_format  main  '[$remote_addr] - [$remote_user] [$time_local] \"$request\" '\n                           '$status $body_bytes_sent \"$http_referer\" '\n                           '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n             access_log    /var/log/nginx/access.log;\n     \n             #sendfile 开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，\n             如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。\n             sendfile        on;\n             tcp_nopush     on; #防止网络阻塞\n             tcp_nodelay        on; #防止网络阻塞\n     \n             #连接超时时间\n             #keepalive_timeout  0;  \n             keepalive_timeout  65; #长连接超时时间，单位是秒\n            \n     \n             #开启gzip压缩\n            gzip  on;\n     \t\tgzip_disable \"MSIE [1-6]\\.\"; # IE6及以下禁止压缩 \n            gzip_min_length 1k; #最小压缩文件大小\n     \t\tgzip_buffers 4 16k; #压缩缓冲区\n     \t\tgzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0）\n     \t\tgzip_comp_level 2; #压缩等级\n     \t\tgzip_types text/plain application/x-javascript text/css application/xml; #压缩类型\n     \t\tgzip_vary on; #给CDN和代理服务器使用，针对相同url，可以根据头信息返回压缩和非压缩副本\n     \n     \n             #设定请求缓冲\n             client_header_buffer_size    1k;   #上传文件大小限制\n             large_client_header_buffers  4 4k;  #设定请求缓存\n     \n     \n             #设定负载均衡的服务器列表\n             upstream mysvr {\n     \t        #weigth参数表示权值，权值越高被分配到的几率越大\n     \t        server 192.168.8.1x:3128 weight=5;\n     \t        server 192.168.8.2x:80  weight=1;\n     \t        server 192.168.8.3x:80  weight=6;\n             }\n     \n             upstream mysvr2 {\n     \t        #weigth参数表示权值，权值越高被分配到的几率越大\n     \t        server 192.168.8.x:80  weight=1;\n     \t        server 192.168.8.x:80  weight=6;\n             }\n     \n             #虚拟主机的配置\n            server {\n                 #侦听80端口\n                 listen       80;\n                 #设置编码\n      \t          #charset koi8-r;\n     \n                 #定义使用www.xx.com访问 域名可以有多个，用空格隔开\n                 server_name  www.xx.com;\n     \n                 #设定本虚拟主机的访问日志\n                 access_log  logs/www.xx.com.access.log  main;\n     \n             #默认请求\n             location / {\n                   root   /root;      #定义服务器的默认网站根目录位置\n                   index index.php index.html index.htm;   #定义首页索引文件的名称\n     \n     \n                  proxy_pass  http://mysvr ;#请求转向mysvr 定义的服务器列表\n     \n                   client_max_body_size 10m;    #允许客户端请求的最大单文件字节数\n                   client_body_buffer_size 128k;  #缓冲区代理缓冲用户端请求的最大字节数，\t\n     \n                  #以下是一些反向代理的配置可删除.\n     \n                   proxy_redirect off;\n     \n                   #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP\n                   proxy_set_header Host $host;\n                   proxy_set_header X-Real-IP $remote_addr;\n                   proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n                   proxy_connect_timeout 90;  #nginx跟后端服务器连接超时时间(代理连接超时)\n                   proxy_send_timeout 90;        #后端服务器数据回传时间(代理发送超时)\n                   proxy_read_timeout 90;         #连接成功后，后端服务器响应时间(代理接收超时)\n                   proxy_buffer_size 4k;             #设置代理服务器（nginx）保存用户头信息的缓冲区大小\n                   proxy_buffers 4 32k;               #proxy_buffers缓冲区，网页平均在32k以下的话，这样设置\n                   proxy_busy_buffers_size 64k;    #高负荷下缓冲大小（proxy_buffers*2）\n                   proxy_temp_file_write_size 64k;  #设定缓存文件夹大小，大于这个值，将从upstream服务器传\n     \n             }\n     \n             # 定义错误提示页面\n             error_page   500 502 503 504 /50x.html; \n                 location = /50x.html {\n                 root   /root;\n             }\n     \n             #本地动静分离反向代理配置\n     \t\t#所有jsp的页面均交由tomcat或resin处理\n     \t\tlocation ~ .(jsp|jspx|do)?$ {\n     \t\t\tproxy_set_header Host $host;\n     \t\t\tproxy_set_header X-Real-IP $remote_addr;\n     \t\t\tproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n     \t\t\tproxy_pass http://127.0.0.1:8080;\n     \t\t}\n     \n             #静态文件，nginx自己处理\n             location ~ ^/(images|javascript|js|css|flash|media|static)/ {\n                 root /var/www/virtual/htdocs;\n                 #过期30天，静态文件不怎么更新，过期可以设大一点，如果频繁更新，则可以设置得小一点。\n                 expires 30d;\n             }\n     \n             #设定查看Nginx状态的地址\n             location /NginxStatus {\n                 stub_status            on;\n                 access_log              on;\n                 auth_basic              \"NginxStatus\";\n                 auth_basic_user_file  conf/htpasswd;\n                 #htpasswd文件的内容可以用apache提供的htpasswd工具来产生。\n             }\n             #禁止访问 .htxxx 文件\n             location ~ /\\.ht {\n                 deny all;\n             }\n     \n             }\n         }\n       \n#### Nginx虚拟主机\n    1）虚拟主机\n    虚拟主机使用的是特殊的软硬件技术，它把一台运行在因特网上的服务器主机分成一台台“虚拟”的主机，每台虚拟主机都可以是一个独立的网站，可以具有独立的域名，\n    具有完整的Intemet服务器功能（WWW、FTP、Email等），同一台主机上的虚拟主机之间是完全独立的。从网站访问者来看，每一台虚拟主机和一台独立的主机完全一样。\n    利用虚拟主机，不用为每个要运行的网站提供一台单独的Nginx服务器或单独运行一组Nginx进程。虚拟主机提供了在同一台服务器、同一组Nginx进程上运行多个网站的功能。\n    \n    2）配置虚拟主机\n    我们先配置在一个nginx中配置一个虚拟主机，编辑nginx.conf配置文件，在http模块中，配置server模块，一个server模块就针对一个虚拟主机。\n    我们模拟一个独立的网站，此网站域名访问为www.server1.com；网站的根目录放到nginx目录下html/server1目录，我们创建一个首页index.html到server1中，编辑index.html\n    <!DOCTYPE html>\n    <html>\n    <head>\n    <title>server1 首页</title>\n    </head>\n    <body>\n    <h1>server1 首页</h1>\n    </body>\n    </html>\n    下面我们回到nginx.conf配置文件中，配置server模块\n    server {\n    listen 80; #监听80端口\n    server_name www.server1.com; #虚拟主机名，可以为域名或ip地址\n    location / { #默认请求路由，以后文章中会重点介绍\n    root html/server1; #网站的根目录\n    index index.html index.htm; #默认首页文件名\n    }\n    }\n    配置完成之后，重启nginx。因为www.server1.com是模拟的，需要在访问的客户端配置一下域名映射，老顾访问的客户端用的是windows系统，\n    所以要到C:\\Windows\\System32\\drivers\\etc\\目录下，编辑hosts文件，增加个映射\n    192.168.5.150 www.server1.com\n    192.168.5.150是老顾的nginx服务器地址，注意编辑hosts要用管理员身份编辑，要不然会报无权限修改错误。\n    打开浏览器，访问www.server1.com\n    \n    \n    3）第一个虚拟主机配置完成，我们再配置一个server2，与server1配置类似，先给server2网站创建一个根目录，nginx目录下html/server2目录，编辑index.html\n    <!DOCTYPE html>\n    <html>\n    <head>\n    <title>server2</title>\n    </head>\n    <body>\n    <h1>server2 首页</h1>\n    </body>\n    </html>\n    再编辑nginx.conf，再增加个server模块，监听还是80端口，但服务名改为www.server2.com\n    server {\n    listen 80; #监听80端口\n    server_name www.server2.com; #虚拟主机名，可以为域名或ip地址\n    location / { #默认请求路由，以后文章中会重点介绍\n        root html/server2; #网站的根目录\n        index index.html index.htm; #默认首页文件名\n    }\n    }\n    重启nginx，不要忘了把hosts再增加个域名映射\n    192.168.5.150 www.server2.com\n    打开浏览器访问www.server2.com,运行结果\n    \n    \n    这样第二个虚拟主机也配置完成。说明一下 再配置server模块是，监听的端口 listen 和 server_name 组合起来是唯一的，\n    如果server_name一样，那么listen监听的端口就不一样；如端口一样，server_name就不一样。这是很好理解的，虚拟主机的请求映射系统才能够判别。\n\n## Nginx日志与日志切割\n\n### 日志文件的格式配置\n    nginx服务器在运行的时候，会有各种操作，操作的信息会记录到日志文件中，日志文件的记录是有格式的。那我们如何设置日志文件的格式呢？\n    使用log_format指令进行配置文件格式\n    nginx的log_format有很多可选的参数用于指示服务器的活动状态，默认的是：\n    log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '    '$status $body_bytes_sent \"$http_referer\" '    '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n    \n    192.168.31.247 - - [11/Mar/2018:16:26:43 +0800] \"GET / HTTP/1.1\" 304 0 \"-\" \"Mozilla/5.0 (Windows NT 10.0; WOW64) \n    AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3350.0 Safari/537.36\" \"-\"\n\n#### 日志相关参数\n    参数                      说明                                         示例\n    $remote_addr             客户端地址                                    211.28.65.253\n    $remote_user             客户端用户名称                                --\n    $time_local              访问时间和时区                                18/Jul/2012:17:00:01 +0800\n    $request                 请求的URI和HTTP协议                           \"GET /article-10000.html HTTP/1.1\"\n    $http_host               请求地址，即浏览器中你输入的地址（IP或域名）     www.wang.com 192.168.100.100\n    $status                  HTTP请求状态                                  200\n    $upstream_status         upstream状态                                  200\n    $body_bytes_sent         发送给客户端文件内容大小                        1547\n    $http_referer            url跳转来源                                   https://www.baidu.com/\n    $http_user_agent         用户终端浏览器等信息                           \"Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; SV1; GTB7.0; .NET4.0C;\n    $ssl_protocol            SSL协议版本                                   TLSv1\n    $ssl_cipher              交换数据中的算法                               RC4-SHA\n    $upstream_addr           后台upstream的地址，即真正提供服务的主机地址     10.10.10.100:80\n    $request_time            整个请求的总时间                               0.205\n    $upstream_response_time  请求过程中，upstream响应时间                    0.002\n    $http_x_forwarded_for    是反向代理服务器转发客户端地址的参数\n    \n    假设将Nginx服务器作为Web服务器，位于负载均衡设备、Squid、Nginx反向代理之后，不能获取到客户端的真实IP地址了。\n    原因是经过反向代理后，由于在客户端和Web服务器之间增加了中间层，因此Web服务器无法直接拿到客户端的IP。\n    通过$remote_addr变量拿到的将是反向代理服务器的IP地址。\n    但是，反向代理服务器在转发请求的HTTP头信息中，可以增加X-Forwarded-For信息，用以记录原有的客户端IP地址和原来客户端请求的服务器地址。\n    这时候，要用log_format指令设置日志格式，让日志记录X-Forearded-For信息中的IP地址，即客户的真实IP。\n    日志文件路径配置\n\n#### access_log指令\n    语法: access_log path [format [buffer=size [flush=time]]];\n    access_log path format gzip[=level] [buffer=size] [flush=time];\n    access_log off;\n    默认值: access_log logs/access.log combined;\n    配置段: \n    gzip压缩等级。\n    buffer设置内存缓存区大小。\n    flush保存在缓存区中的最长时间。\n    不记录日志：access_log off;\n    使用默认combined格式记录日志：access_log logs/access.log 或 access_log logs/access.log combined;\n    值得注意的是，Nginx进程设置的用户和组必须对日志路径有创建文件的权限，否则，会报错。\n    此外，对于每一条日志记录，都将是先打开文件，再写入日志，然后关闭。可以使用open_log_file_cache来设置日志文件缓存(默认是off)。\n\n#### 日志文件切割\n    server1.log   ---->  server1-2018-03-11.log  ---> server1-2018-03-12.log\n                  ----》 server1-2018-03-10.log \n    \n    通过mv命令 把当前log文件重命令\n    再用信号控制指令 发送重读日志指令  产生了新的日志log文件\n    \n    nginx日志默认情况下统统写入到一个文件中，文件会变的越来越大，非常不方便查看分析。\n    以日期来作为日志的切割是比较好的，通常我们是以每日来做统计的。下面来说说nginx日志切割。\n    我们先手动完成日志文件切割\n    到logs目录中，先备份日志文件，在重新生成日志文件\n    mv access.log access_20180124.log\n    kill -USR1 pid进程号   #向 Nginx 主进程发送 USR1 信号。USR1 信号是重新打开日志文件\n\n#### 系统自动切割\n    利用sh脚本的方式执行刚才的手动操作，在每天凌晨执行一个计划任务 调用sh脚本，就完成的系统自动切割日志文件\n    \n    编写脚本\n    在nginx目录下logs目录\n    # touch cutlog.sh脚本\n    # vi cutlog.sh \n    #!/bin/bash\n    LOGS_PATH=/usr/local/nginx/logs\n    YESTERDAY=$(date -d \"yesterday\" +%Y-%m-%d)\n    mv ${LOGS_PATH}/access.log ${LOGS_PATH}/access_${YESTERDAY}.log\n    kill -USR1 $(cat /usr/local/nginx/logs/nginx.pid)   # 向 Nginx 主进程发送 USR1 信号。USR1 信号是重新打开日志文件\n    \n    注意：执行 sed -i 's/\\r$//' cutlog.sh\n    原因：\n    \n        这个文件在Windows 下编辑过，在Windows下每一行结尾是\\n\\r，而Linux下则是\\n\n    \n        sed -i 's/\\r$//' cutlog.sh 会把cutlog.sh中的行尾的\\r替换为空白\n    \n    \n    设置定时任务\n    # vi  /etc/crontab\n    0 0 * * * root /usr/local/nginx/logs/cutlog.sh  \n    表示配置一个定时任务，定时每天00:00以root身份执行脚本/usr/local/nginx/logs/cutlog.sh，实现定时自动分割Nginx日志\n\n## Nginx的Location\n    nginx的location配置详解\n    1）语法规则： location [=|~|~*|^~] /uri/ { … }\n    构成：\n    指令                  前缀                  uri\n    location          [=|~|~*|^~]           /uri\n    \n    路由匹配规则，正则匹配，正则表达式\n    \n    \n    \n    2）location区分普通匹配和正则匹配\n    \n    用前缀 “~” 和 “~*”修饰的为正则匹配\n    ~   前缀表示区分大小写的正则匹配\n    ~*  前缀表示不区分大小写的正则匹配\n    \n    除上面修饰的前缀（“=” 和 “^~”，或没有前缀修饰）都为普通匹配\n    =   前缀表示精确匹配\n    ^~  前缀表示uri以某个常规字符串开头，可以理解为url的普通匹配\n    \n    location作用于server模块,且支持多个location模块\n    server {\n           .........\n            location /p {\n                root   html/p;\n                index  index.html index.htm;\n            }\n            location = /50x.html {\n                root   html;\n            }\n            location / {\n                root   html/server1;\n                index  index.html index.htm;\n            }\n    }\n    在多个location情况下，是按照什么原则进行匹配的呢？\n    \n    3）匹配的原则\n    普通匹配：优先原则---->最大前缀匹配原则; 顺序无关\n    如：\n    server {\n    \tlocation /prefix/ {\n    \t\t#规则A\n    \t}\n    \tlocation /prefix/mid/ {\n    \t\t#规则B\n    \t} \n    }\n    \n    请求url为：/prefix/mid/t.html \n    \n    此请求匹配的是 规则B，是以最大的匹配原则进行的，跟顺序无关\n    \n    ------------------------\n    正则匹配：为顺序匹配，优先原则：谁在前面 就匹配谁；顺序相关\n    如：\n    server {\n    \tlocation ~ \\.(gif|jpg|png|js|css)$ {\n    \t   \t\t#规则C\n    \t}\n    \tlocation ~* \\.png$ {\n    \t   \t\t#规则D\n    \t}\n    }\n    请求http://localhost/1.png,匹配的是规则C，因为规则C在前面，即叫做顺序匹配\n    \n    ----------------\n    如果location有普通匹配也有正则匹配，那匹配的原则为\n    匹配模式及顺序\n    ----带前缀普通匹配 最优先，=前缀优先级最高\n    location = /uri 　　　=开头表示精确匹配，只有完全匹配上才能生效。\n    location ^~ /uri 　　^~ 开头对URL路径进行前缀匹配，并且在正则之前。\n    ----正则匹配\n    location ~ pattern 　~开头表示区分大小写的正则匹配。\n    location ~* pattern 　~*开头表示不区分大小写的正则匹配。\n    ---不带前缀匹配\n    location /uri 　　　　不带任何修饰符，也表示前缀匹配，但是在正则匹配之后。\n    \n    location / 　　　　　通用匹配，任何未匹配到其它location的请求都会匹配到，相当于switch中default。 \n    \n    首先匹配 =，其次匹配^~, 其次是按文件中顺序的正则匹配，不带前缀普通匹配，最后是交给 / 通用匹配。\n    当有匹配成功时候，停止匹配，按当前匹配规则处理请求。\n    \n    例子，有如下匹配规则：\n    location = / {\n                return 200 '规则A';\n            }\n    location = /login {\n                return 200 '规则B';\n            }\n    location ^~ /static/ {\n                return 200 '规则C';\n            }\n    location ~ \\.(gif|jpg|png|js|css)$ {\n                return 200 '规则D';\n            }\n    location ~* \\.js$ {\n                return 200 '规则E';\n            }\t\n    location / {\n                return 200 '规则F';\n    }\n    那么产生的效果如下：\n    访问根目录/， 比如http://localhost/ 将匹配规则A\n    访问 http://localhost/login 将匹配规则B，\n    http://localhost/register 则匹配规则F\n    http://localhost/static/a.html 将匹配规则C\n    http://localhost/a.css, 匹配规则D\n    http://localhost/b.js则优先匹配到 规则D，不会匹配到规则E\n    http://localhost/static/c.js 则优先匹配到 规则C\n    http://localhost/a.JS 则匹配规则E， 而不会匹配规则D，因为规则E不区分大小写。\n    访问 http://localhost/category/id/1111 则最终匹配到规则F，因为以上规则都不匹配，\n    \n    \n    4）在实际场景中，通常至少有三个匹配规则定义，如下：\n    #直接匹配网站根，通过域名访问网站首页比较频繁，使用这个会加速处理。\n    #这里是直接转发给后端应用服务器了，也可以是一个静态首页\n    # 第一个必选规则\n    location = / {\n        .....\n    }\n    # 第二个必选规则是处理静态文件请求，这是nginx作为http服务器的强项\n    # 有两种配置模式，目录匹配或后缀匹配,任选其一或搭配使用\n    location ^~ /static {\n        root /webroot/static/;\n    }\n    location ~* \\.(gif|jpg|jpeg|png|css|js|ico)$ {\n        root /webroot/res/;\n    }\n    #第三个规则就是通用规则，用来转发动态请求到后端应用服务器\n    #非静态文件请求就默认是动态请求，自己根据实际把握\n    #毕竟目前的一些框架的流行，带.php,.jsp后缀的情况很少了\n    location / {\n        .....\n    }\n\n## Nginx负载均衡\n    当一台服务器单位时间内访问量很大的时候，服务器压力就会很大，当达到这台服务器的极限，就会崩溃；怎么解决？\n    可以通过nginx的反向代理设置，添加几台同样功能的服务器 分担压力。\n    \n    nginx实现负载均衡原理，用户访问首先访问到nginx服务器，然后nginx服务器再从应用服务器集群中选择压力比较小的服务器，然后将该访问请求引向该服务器。\n    如应用服务器集群中某一台服务器崩溃，那么从待选择服务器列表中将该服务器删除，也就是说一个服务器崩溃了，那么nginx服务器不会把请求引向到该服务器。\n    \n    upstream mypro {\n        server 192.168.5.140:8080;\n        server 192.168.5.141:8080;\n        xxxxx\n        xxxx\n    }\n    \n    server {\n        listen 80;\n        server_name xxxx;\n        location / {\n            proxy_pass http://mypro;\n        } \n     }\n    \n### 负载均衡方案\n    \n#### 随机轮询\n    upstream mypro {\n        server 192.168.5.140:8080;\n        server 192.168.5.141:8080;\n    }\n    \n#### 权重\n    upstream mypro {\n        server 192.168.5.140:8080 weight=5;\n        server 192.168.5.141:8080 weight=10;\n    }\n    \n#### ip_hash\n    upstream mypro {\n        ip_hash;\n        server 192.168.5.140:8080;\n        server 192.168.5.141:8080;\n    }\n    \n#### 使用方式\n    server {\n        listen       80;\n        server_name  192.168.5.138;\n         location / {\n            proxy_pass http://mypro;\n        }\n    }\n    \n## Nginx拓展模块安装\n    查看nginx安装的现有模块指令\n    /usr/local/nginx/sbin/nginx -V （大写的V）\n    nginx version: nginx/1.13.2\n    built by gcc 4.8.5 20150623 (Red Hat 4.8.5-16) (GCC) \n    configure arguments:\n    \n    1、下载需要的echo模块\n    https://github.com/openresty/echo-nginx-module/tags\n    # wget https://github.com/openresty/echo-nginx-module/archive/v0.61.tar.gz\n    # tar zxvf v0.61.tar.gz\n    # mv echo-nginx-module-0.61 nginx-tools/\n    \n    2、重新编译nginx，安装echo-nginx模块\n    进入nginx源文件，重新编译\n    # ./configure --add-module=nginx安装目录下面/echo-nginx-module-0.61 #安装echo模块(文件夹名echo-nginx-module-0.61)\n    # make #开始编译，但别安装 （make install会直接覆盖安装）\n    \n    3、平滑升级 nginx\n    \n    注意先备份一下之前老的，手动安装一下。\n    # mv /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.old\n    # cp -f objs/nginx /usr/local/nginx/sbin/nginx\n    \n    这里是平滑升级，如是全新安装请执行：make install\n    # make upgrade \n    # make clean （清除编译产生的文件，可以忽略）\n    \n    \n    \n    location /module {\n        echo 'hello world'; \n    }\n    --------------------\n    location /module {\n                echo_exec /set;\n    }\n            \n    location /set {\n        set $foo 'hello world';     #自定义变量\n        echo \"$request_uri\";      #显示nginx全局变量的内容\n        echo $foo;\n    }\n    \n    \n    lua模块：可以在nginx服务中执行lua脚本\n    \n    \n    nginx全局变量\n    $args ：                     #这个变量等于请求行中的参数，同$query_string\n    $content_length ：    #请求头中的Content-length字段。\n    $content_type ：       #请求头中的Content-Type字段。\n    $document_root ：   #当前请求在root指令中指定的值。\n    $host ：                     #请求主机头字段，否则为服务器名称。\n    $http_user_agent ：  #客户端agent信息\n    $http_cookie ：          #客户端cookie信息\n    $limit_rate ：              #这个变量可以限制连接速率。\n    $request_method ：   #客户端请求的动作，通常为GET或POST。\n    $remote_addr ：         #客户端的IP地址。\n    $remote_port ：          #客户端的端口。\n    $remote_user ：         #已经经过Auth Basic Module验证的用户名。\n    $request_filename ： #当前请求的文件路径，由root或alias指令与URI请求生成。\n    $scheme ：                #HTTP方法（如http，https）。\n    $server_protocol ：    #请求使用的协议，通常是HTTP/1.0或HTTP/1.1。\n    $server_addr ：         #服务器地址，在完成一次系统调用后可以确定这个值。\n    $server_name ：       #服务器名称。\n    $server_port ：          #请求到达服务器的端口号。\n    $request_uri ：          #包含请求参数的原始URI，不包含主机名，如：”/foo/bar.php?arg=baz”。\n    $uri ：                        #不带请求参数的当前URI，$uri不包含主机名，如”/foo/bar.html”。\n    $document_uri ：      #与$uri相同\n\n## Nginx的Lua模块\n\n    Nginx的优势\n        Nginx设计为一个主进程多个工作进程的工作模式，每个进程是单线程来处理多个连接，而且每个工作进程采用了非阻塞I/O来处理多个连接，\n        从而减少了线程上下文切换，从而实现了公认的高性能、高并发;因此在生成环境中会通过把CPU绑定给Nginx工作进程从而提升其性能;另外因为单线程工作模式的特点，内存占用就非常少了。 \n        Nginx更改配置重启速度非常快，可以毫秒级，而且支持不停止Nginx进行升级Nginx版本、动态重载Nginx配置。  \n        Nginx模块也是非常多，功能也很强劲，不仅可以作为http负载均衡，Nginx发布1.9.0版本还支持TCP负载均衡，还可以很容易的实现内容缓存、web服务器、反向代理、访问控制等功能。\n        nginx模块：rewrite 经常用到的\n    \n    什么是ngx_lua\n        ngx_lua是Nginx的一个模块，将Lua嵌入到Nginx中，从而可以使用Lua来编写脚本，这样就可以使用Lua编写应用脚本，部署到Nginx中运行，即Nginx变成了一个Web容器;\n        这样开发人员就可以使用Lua语言开发高性能Web应用了。\n        \n        网站开发，也有一个重要的脚步语言，javascript，js文件；；；客户端脚步语言；；；（node.js服务器语言）\n        网站页面进行渲染的时候，可以通过javascript脚本语言 进行一些业务处理\n        <script>\n        function hello(){\n        \talert(\"hello\");\n        }\n        </script>\n        脚本文件，还需要一个javascript引擎---解析javascript脚本语言\n        全部的浏览器 都包含 javascript引擎\n        \n        \n        lua -- javascript  一样的脚本语言\n        lua脚本语言 应用  ----》游戏开发中\n        \n        \n        Lua是一种轻量级、可嵌入式的脚本语言，这样可以非常容易的嵌入到其他语言中使用。另外Lua提供了协程并发，\n        即以同步调用的方式进行异步执行，从而实现并发，比起回调机制的并发来说代码更容易编写和理解，排查问题也会容易。Lua还提供了闭包机制，\n        函数可以作为First Class Value 进行参数传递，另外其实现了标记清除垃圾收集。\n        \n        因为Lua的小巧轻量级，可以在Nginx中嵌入Lua VM，请求的时候创建一个VM，请求结束的时候回收VM。\n        \n        ngx_lua模块的原理：\n        ngx_lua将Lua嵌入Nginx，能够让Nginx运行Lua脚本，而且高并发、非堵塞的处理各种请求。Lua内建协程。这样就能够非常好的将异步回调转换成顺序调用的形式。ngx_lua在Lua中进行的IO操作都会托付给Nginx的事件模型。从而实现非堵塞调用。\n        开发人员能够採用串行的方式编敲代码，ngx_lua会自己主动的在进行堵塞的IO操作时中断。保存上下文；然后将IO操作托付给Nginx事件处理机制。在IO操作完毕后，ngx_lua会恢复上下文，程序继续运行，这些操作都是对用户程序透明的。\n        每一个NginxWorker进程持有一个Lua解释器或者LuaJIT实例，被这个Worker处理的全部请求共享这个实例。\n        \n        每一个请求的Context会被Lua轻量级的协程切割，从而保证各个请求是独立的。 ngx_lua採用“one-coroutine-per-request”的处理模型。对于每一个用户请求，ngx_lua会唤醒一个协程用于执行用户代码处理请求，当请求处理完毕这个协程会被销毁。\n        \n        每一个协程都有一个独立的全局环境（变量空间），继承于全局共享的、仅仅读的“comman data”。所以。被用户代码注入全局空间的不论什么变量都不会影响其它请求的处理。而且这些变量在请求处理完毕后会被释放，\n        这样就保证全部的用户代码都执行在一个“sandbox”（沙箱），这个沙箱与请求具有同样的生命周期。 得益于Lua协程的支持。ngx_lua在处理10000个并发请求时仅仅须要非常少的内存。依据測试，ngx_lua处理每一个请求仅仅须要2KB的内存，\n        假设使用LuaJIT则会更少。所以ngx_lua非常适合用于实现可扩展的、高并发的服务。\n        \n        ngx_lua 模块提供的指令和API\n        \n        三、ngx_lua安装\n        echo模块\n            ngx_lua安装能够通过下载模块源代码，编译Nginx。可是推荐採用openresty。Openresty就是一个打包程序，包括大量的第三方Nginx模块，比方HttpLuaModule，HttpRedis2Module，HttpEchoModule等。省去下载模块。而且安装很方便。        \n            OpenResty将Nginx核心、LuaJIT、许多有用的Lua库和Nginx第三方模块打包在一起;这样开发人员只需要安装OpenResty，不需要了解Nginx核心和写复杂的C/C++模块就可以，只需要使用Lua语言进行Web应用开发了。        \n        \n        OpenResty提供了一些常用的ngx_lua开发模块：如        \n            lua-resty-memcached       \n            lua-resty-mysql        \n            lua-resty-redis        \n            lua-resty-dns        \n            lua-resty-limit-traffic        \n            lua-resty-template       \n        nginx + lua 就可以开发出 一些系统。龙果学院中 有一门课程 就专门应用了这个技术  \n        这些模块涉及到如mysql数据库、redis、限流、模块渲染等常用功能组件;另外也有很多第三方的ngx_lua组件供我们使用，对于大部分应用场景来说现在生态环境中的组件已经足够多了;如果不满足需求也可以自己去写来完成自己的需求。\n        openresty.org/cn官网\n        \n        应用场景\n        应用的公司：奇虎360、京东、百度、魅族、知乎、优酷、新浪这些互联网公司都在使用。\n        业务场景： WAF、有做 CDN 调度、广告系统、消息推送系统，API server 网关\n    \n","source":"_posts/微服务API网关框架-2.md","raw":"---\ntitle: 微服务API网关框架(2)--Nginx的使用\ncatalog: true\ndate: 2018-12-19 16:52:03\nsubtitle:\nheader-img: \"Demo.png\"\ntags:\n- 微服务API网关\ncatagories:\n- 微服务API网关\n---\n\n# Nginx\n\n## Nginx命令\n\n### Nginx的基本配置\n    Nginx的主配置文件是：nginx.conf，nginx.conf主要组成如下：\n    \n    # 全局区   有一个工作子进程，一般设置为CPU数 * 核数\n    worker_processes  1; \n    events {\n        # 一般是配置nginx进程与连接的特性\n        # 如1个word能同时允许多少连接，一个子进程最大允许连接1024个连接\n         worker_connections  1024;\n    }\n     # 配置HTTP服务器配置段\n    http {\n        # 配置虚拟主机段\n        server {\n             # 定位，把特殊的路径或文件再次定位。\n             location  {\n                       \n             } \n        }\n         server {\n                       \n         } \n    }\n\n### nginx启动\n    指令：nginx程序   -c   nginx配置文件\n    # /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf\n    \n### nginx重启\n    #cd /usr/local/nginx/sbin\n    ##重启\n    # ./nginx -s reload   \n    进入nginx可执行程序的目录\n    # cd /usr/local/nginx/sbin/\n    # ./nginx -s reload\n    nginx: [error] invalid PID number \"\" in \"/usr/local/nginx/logs/nginx.pid\"\n    重启是建立在nginx服务需要启动\n    \n### nginx停止\n    # ./nginx -s stop \n    # ./nginx -s quit\n    \n    quit 是一个优雅的关闭方式，Nginx在退出前完成已经接受的连接请求\n    stop 是快速关闭，不管有没有正在处理的请求。\n    \n### 重新打开日志\n    # 用于日志切割   \n    # ./nginx -s reopen   \n    \n### nginx检查配置文件\n    检查配置文件是否正确\n    第一种\n    进入nginx可执行程序的目录\n    # cd /usr/local/nginx/sbin/\n    # ./nginx -t\n    \n    第二种\n    # /usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.conf\n\n## Nginx信号控制\n    Nginx支持2种进程模型Single和Master-Worker\n    Single是单进程，一般不适用，\n    Master-Worker是主进程和工作进程模型运行，主进程对工作进程管理。\n    Nginx允许我们通过信号来控制主进程，用信号的方式可以达到不影响现有连接的目的。 \n\n### 信号类型\n    INT，TERM\t\t快速关闭信号\n    QUIT\t\t\t从容关闭信号\n    HUP\t\t\t\t从容重启信号，一般用于修改配置文件后，重启\n    USR1\t\t\t重读日志，一般用于日志的切割\n    USR2\t\t\t平滑升级信号\n    WINCH\t\t\t从容关闭旧进程\n\n    具体语法:\n    kill    -信号选项    nginx的主进程号\n    例：\n    # kill -INT 26661 \n    # kill -HUP 4873\n\n#### Nginx的优雅停止\n    1）nginx停止\n    #  ps -ef | grep nginx 获得进程号\n    \n    第1种从容“优雅”停止\n    # kill -QUIT master进程号\n    # Nginx服务可以正常地处理完当前所有请求再停止服务\n    # 步骤：首先会关闭监听端口，停止接收新的连接，然后把当前正在处理的连接全部处理完，最后再退出进程。\n    \n    第2种快速停止\n    # kill -TERM master进程号\n    # kill -INT master进程号\n    # 快速停止服务时，worker进程与master进程在收到信号后会立刻跳出循环，退出进程。\n    第3种强制停止\n    # pkill -9 nginx\n    # 系统强杀nginx进程\n    \n    2）重启nginx\n    # kill -HUP master进程号\n\n#### Nginx平滑升级\n    原理:把服务器从低版本升级为高版本，强行停止服务器，会影响正在运行的进程。\n         平滑升级不会停掉正在进行中的进程，这些进程会继续处理请求。但不会再接受新请求，这些老的进程在处理完请求之后 会停止。此平滑升级过程中，新开的进程会被处理。\n\n    \n    一）平滑升级\n        进入nginx可执行程序的目录\n             #  cd /usr/local/nginx/sbin/\n             # ./nginx -V  #查看nginx版本\n    \n        1）下载高版本nginx http://nginx.org/download/nginx-1.13.1.tar.gz\n        执行指令\n        #  ./configure\n        # make    #不能执行 make install\n        # cd objs\n        此目录下 有高版本的nginx\n        备份低版本的nginx\n        cp nginx nginx.old\n        执行强制覆盖\n        cp -rfp objs/nginx /usr/local/nginx/sbin\n    \n        测试一下新复制过来文件生效情况：\n        # /usr/local/nginx/sbin/nginx -t\n        # ps -ef | grep nginx\n    \n        2）执行信号平滑升级\n            # kill -USR2 `cat /usr/local/nginx/logs/nginx.pid`  更新配置文件\n            给nginx发送USR2信号后，nginx会将logs/nginx.pid文件重命名为nginx.pid.oldbin，然后用新的可执行文件启动一个新的nginx主进程和对应的工作进程，并新建一个新的nginx.pid保存新的主进程号\n            \n            # ps -ef | grep nginx\n            \n            # ll logs/\n        \n        \n        3）kill -WINCH 旧的主进程号\n            旧的主进程号收到WINCH信号后，将旧进程号管理的旧的工作进程优雅的关闭。即一段时间后旧的工作进程全部关闭，只有新的工作进程在处理请求连接。\n            这时，依然可以恢复到旧的进程服务，因为旧的进程的监听socket还未停止。\n            处理完后，工作进程会自动关闭\n            # ps -ef | grep nginx\n        \n        4）# kill -QUIT `cat /usr/local/nginx/logs/nginx.pid.oldbin` 优雅的关闭\n            给旧的主进程发送QUIT信号后，旧的主进程退出，并移除logs/nginx.pid.oldbin文件，nginx的升级完成。\n        \n        升级完成了，最后在看一下升级后的版本\n    \n        查看\n        ./nginx -V\n        已经平滑升级成功\n    \n    二）中途停止升级，回滚到旧的nginx\n        在步骤(3)时，如果想回到旧的nginx不再升级\n        \n        (1)给旧的主进程号发送HUP命令，此时nginx不重新读取配置文件的情况下重新启动旧主进程的工作进程。\n            kill -HUP 9944 --旧主进程号\n            重启工作进程\n        (2)优雅的关闭新的主进程\n            kill -QUIT 10012  --新主进程号\n\n#### Nginx 用户\n    #以哪个用户，运行nginx应用\n    #nobody是个低权限用户，为了安全\n    #user nobody;\n\n#### Nginx 进程数设置    \n    worker_processes：表示开启nginx的worker进程的个数，nginx启动会开两种进程，master进程用来管理调度，worker进程用来处理请求；\n    上面表示两种设置方法，比如\n    方法一：worker_processes auto;\n    　　表示设置服务器cpu核数匹配开启nginx开启的worker进程数    \n    　　查看cpu核数：cat /proc/cpuinfo    \n    方法二：nginx设置cpu亲和力\n    　　worker_processes 8;    \n    　　worker_cpu_affinity 00000001 00000010 00000100 00001000 00010000 00100000 01000000 10000000;    \n    　　00000001表示启用第一个CPU内核，00000010表示启用第二个CPU内核，以此类推\n    \n    worker_cpu_affinity：表示开启八个进程，第一个进程对应着第一个CPU内核，第二个进程对应着第二个CPU内核，以此类推。\n        这种设置方法更高效，因将每个cpu核提供给固定的worker进程服务，减少cpu上下文切换带来的资源浪费\n    \n    如果服务器cpu有限\n        比如：2核CPU，开启2个进程，设置如下 \n        worker_processes     2;   \n        worker_cpu_affinity 01 10;  \n        比如：4核CPU,开启4个进程，设置如下\n        worker_processes     4;\n        worker_cpu_affinity 0001 0010 0100 1000;\n    \n    8核cpu , worker_processes=8\n    1个worker进程 能够最大打开的文件数（线程数）worker_connections=65535 （参考worker_rlimit_nofile  ---->  linux  ulimit -n）\n    最大的客户端连接数 max_clients = （多少个工作进程数）worker_processes * （1个工作线程的处理线程数）worker_connections    8*65535\n    \n#### Nginx的并发量计算\n    #nginx作为http服务器\n    #请求模型   client <---> nginx\n    #max_clients = worker_processes * worker_connections/2\n    \n    #nginx作为反向代理服务器的时候\n    #请求模型   client <---> nginx  <----> web server\n    #max_clients = worker_processes * worker_connections/4\n    (\n    为什么除以2：该公式基于http 1.1协议，一次请求大多数浏览器发送两次连接，并不是request和response响应占用两个线程（很多人也是这么认为，实际情况：请求是双向的，连接是没有方向的，由上面的图可以看出来)\n    为什么除以4：因nginx作为方向代理，客户端和nginx建立连接，nginx和后端服务器也要建立连接\n    )\n    \n    由此，我们可以计算nginx作为http服务器最大并发量(作为反向代理服务器自己类推)，可以为压测和线上环境的优化提供一些理论依据：\n    单位时间（keepalive_timeout）内nginx最大并发量C\n    C=worker_processes * worker_connections/2=8*65535/2\n    \n    而每秒的并发量CS\n    CS=worker_processes * worker_connections/(2*65)    \n    \n    \n#### Nginx全局错误日志\n    #全局错误日志 \n        #nginx的error_log类型如下（从左到右：debug最详细 crit最少）： \n        #[ debug | info | notice | warn | error | crit ] \n    \n    #例如：error_log logs/nginx_error.log  crit; \n    #解释：日志文件存储在nginx安装目录下的 logs/nginx_error.log ，错误类型为 crit ，也就是记录最少错误信息;\n        error_log  logs/error.log;\n        error_log  logs/notice.log  notice;\n        error_log  logs/info.log  info;\n    \n#### Nginx主进程ID\n    #PID文件，记录当前启动的nginx的进程ID\n        pid        logs/nginx.pid; # 主进程ID存放位置\n        \n#### Nginx的worker进程\n    worker_rlimit_nofile 65535;\n    \n    #这个参数表示worker进程最多能打开的文件句柄数，基于liunx系统ulimit设置\n    #查看系统文件句柄数最大值：ulimit -n\n    #Linux一切皆文件，所有请求过来最终目的访问文件，所以该参数值设置等同于liunx系统ulimit设置为优\n    #可以通过linux命令设置  最大的文件句柄数65535\n\n#### Nginx工作模式与连接数上限\n    events {\n       #网络模型高效(相当于建立索引查找结果)，nginx配置应该启用该参数\n       #但是仅用于linux2.6以上内核,可以大大提高nginx的性能\n       use   epoll;             \n       #该参数表示设置一个worker进程最多开启多少线程数\n       #优化设置应该等同于worker_rlimit_nofile设置值，表明一个线程处理一个http请求，同时可以处理一个文件数，各个模块之间协调合作不等待。\n       worker_connections  65535;\n    }\n                \n#### Nginx负载均衡\n     #设定http服务器，利用它的反向代理功能提供负载均衡支持\n         http {\n              #设定mime类型,类型由mime.type文件定义\n              #MIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来#打开的方式类型，\n              当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开\n             include       /etc/nginx/mime.types;\n             default_type  application/octet-stream;\n             #设定日志格式\n            log_format  main  '[$remote_addr] - [$remote_user] [$time_local] \"$request\" '\n                           '$status $body_bytes_sent \"$http_referer\" '\n                           '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n             access_log    /var/log/nginx/access.log;\n     \n             #sendfile 开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，\n             如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。\n             sendfile        on;\n             tcp_nopush     on; #防止网络阻塞\n             tcp_nodelay        on; #防止网络阻塞\n     \n             #连接超时时间\n             #keepalive_timeout  0;  \n             keepalive_timeout  65; #长连接超时时间，单位是秒\n            \n     \n             #开启gzip压缩\n            gzip  on;\n     \t\tgzip_disable \"MSIE [1-6]\\.\"; # IE6及以下禁止压缩 \n            gzip_min_length 1k; #最小压缩文件大小\n     \t\tgzip_buffers 4 16k; #压缩缓冲区\n     \t\tgzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0）\n     \t\tgzip_comp_level 2; #压缩等级\n     \t\tgzip_types text/plain application/x-javascript text/css application/xml; #压缩类型\n     \t\tgzip_vary on; #给CDN和代理服务器使用，针对相同url，可以根据头信息返回压缩和非压缩副本\n     \n     \n             #设定请求缓冲\n             client_header_buffer_size    1k;   #上传文件大小限制\n             large_client_header_buffers  4 4k;  #设定请求缓存\n     \n     \n             #设定负载均衡的服务器列表\n             upstream mysvr {\n     \t        #weigth参数表示权值，权值越高被分配到的几率越大\n     \t        server 192.168.8.1x:3128 weight=5;\n     \t        server 192.168.8.2x:80  weight=1;\n     \t        server 192.168.8.3x:80  weight=6;\n             }\n     \n             upstream mysvr2 {\n     \t        #weigth参数表示权值，权值越高被分配到的几率越大\n     \t        server 192.168.8.x:80  weight=1;\n     \t        server 192.168.8.x:80  weight=6;\n             }\n     \n             #虚拟主机的配置\n            server {\n                 #侦听80端口\n                 listen       80;\n                 #设置编码\n      \t          #charset koi8-r;\n     \n                 #定义使用www.xx.com访问 域名可以有多个，用空格隔开\n                 server_name  www.xx.com;\n     \n                 #设定本虚拟主机的访问日志\n                 access_log  logs/www.xx.com.access.log  main;\n     \n             #默认请求\n             location / {\n                   root   /root;      #定义服务器的默认网站根目录位置\n                   index index.php index.html index.htm;   #定义首页索引文件的名称\n     \n     \n                  proxy_pass  http://mysvr ;#请求转向mysvr 定义的服务器列表\n     \n                   client_max_body_size 10m;    #允许客户端请求的最大单文件字节数\n                   client_body_buffer_size 128k;  #缓冲区代理缓冲用户端请求的最大字节数，\t\n     \n                  #以下是一些反向代理的配置可删除.\n     \n                   proxy_redirect off;\n     \n                   #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP\n                   proxy_set_header Host $host;\n                   proxy_set_header X-Real-IP $remote_addr;\n                   proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n                   proxy_connect_timeout 90;  #nginx跟后端服务器连接超时时间(代理连接超时)\n                   proxy_send_timeout 90;        #后端服务器数据回传时间(代理发送超时)\n                   proxy_read_timeout 90;         #连接成功后，后端服务器响应时间(代理接收超时)\n                   proxy_buffer_size 4k;             #设置代理服务器（nginx）保存用户头信息的缓冲区大小\n                   proxy_buffers 4 32k;               #proxy_buffers缓冲区，网页平均在32k以下的话，这样设置\n                   proxy_busy_buffers_size 64k;    #高负荷下缓冲大小（proxy_buffers*2）\n                   proxy_temp_file_write_size 64k;  #设定缓存文件夹大小，大于这个值，将从upstream服务器传\n     \n             }\n     \n             # 定义错误提示页面\n             error_page   500 502 503 504 /50x.html; \n                 location = /50x.html {\n                 root   /root;\n             }\n     \n             #本地动静分离反向代理配置\n     \t\t#所有jsp的页面均交由tomcat或resin处理\n     \t\tlocation ~ .(jsp|jspx|do)?$ {\n     \t\t\tproxy_set_header Host $host;\n     \t\t\tproxy_set_header X-Real-IP $remote_addr;\n     \t\t\tproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n     \t\t\tproxy_pass http://127.0.0.1:8080;\n     \t\t}\n     \n             #静态文件，nginx自己处理\n             location ~ ^/(images|javascript|js|css|flash|media|static)/ {\n                 root /var/www/virtual/htdocs;\n                 #过期30天，静态文件不怎么更新，过期可以设大一点，如果频繁更新，则可以设置得小一点。\n                 expires 30d;\n             }\n     \n             #设定查看Nginx状态的地址\n             location /NginxStatus {\n                 stub_status            on;\n                 access_log              on;\n                 auth_basic              \"NginxStatus\";\n                 auth_basic_user_file  conf/htpasswd;\n                 #htpasswd文件的内容可以用apache提供的htpasswd工具来产生。\n             }\n             #禁止访问 .htxxx 文件\n             location ~ /\\.ht {\n                 deny all;\n             }\n     \n             }\n         }\n       \n#### Nginx虚拟主机\n    1）虚拟主机\n    虚拟主机使用的是特殊的软硬件技术，它把一台运行在因特网上的服务器主机分成一台台“虚拟”的主机，每台虚拟主机都可以是一个独立的网站，可以具有独立的域名，\n    具有完整的Intemet服务器功能（WWW、FTP、Email等），同一台主机上的虚拟主机之间是完全独立的。从网站访问者来看，每一台虚拟主机和一台独立的主机完全一样。\n    利用虚拟主机，不用为每个要运行的网站提供一台单独的Nginx服务器或单独运行一组Nginx进程。虚拟主机提供了在同一台服务器、同一组Nginx进程上运行多个网站的功能。\n    \n    2）配置虚拟主机\n    我们先配置在一个nginx中配置一个虚拟主机，编辑nginx.conf配置文件，在http模块中，配置server模块，一个server模块就针对一个虚拟主机。\n    我们模拟一个独立的网站，此网站域名访问为www.server1.com；网站的根目录放到nginx目录下html/server1目录，我们创建一个首页index.html到server1中，编辑index.html\n    <!DOCTYPE html>\n    <html>\n    <head>\n    <title>server1 首页</title>\n    </head>\n    <body>\n    <h1>server1 首页</h1>\n    </body>\n    </html>\n    下面我们回到nginx.conf配置文件中，配置server模块\n    server {\n    listen 80; #监听80端口\n    server_name www.server1.com; #虚拟主机名，可以为域名或ip地址\n    location / { #默认请求路由，以后文章中会重点介绍\n    root html/server1; #网站的根目录\n    index index.html index.htm; #默认首页文件名\n    }\n    }\n    配置完成之后，重启nginx。因为www.server1.com是模拟的，需要在访问的客户端配置一下域名映射，老顾访问的客户端用的是windows系统，\n    所以要到C:\\Windows\\System32\\drivers\\etc\\目录下，编辑hosts文件，增加个映射\n    192.168.5.150 www.server1.com\n    192.168.5.150是老顾的nginx服务器地址，注意编辑hosts要用管理员身份编辑，要不然会报无权限修改错误。\n    打开浏览器，访问www.server1.com\n    \n    \n    3）第一个虚拟主机配置完成，我们再配置一个server2，与server1配置类似，先给server2网站创建一个根目录，nginx目录下html/server2目录，编辑index.html\n    <!DOCTYPE html>\n    <html>\n    <head>\n    <title>server2</title>\n    </head>\n    <body>\n    <h1>server2 首页</h1>\n    </body>\n    </html>\n    再编辑nginx.conf，再增加个server模块，监听还是80端口，但服务名改为www.server2.com\n    server {\n    listen 80; #监听80端口\n    server_name www.server2.com; #虚拟主机名，可以为域名或ip地址\n    location / { #默认请求路由，以后文章中会重点介绍\n        root html/server2; #网站的根目录\n        index index.html index.htm; #默认首页文件名\n    }\n    }\n    重启nginx，不要忘了把hosts再增加个域名映射\n    192.168.5.150 www.server2.com\n    打开浏览器访问www.server2.com,运行结果\n    \n    \n    这样第二个虚拟主机也配置完成。说明一下 再配置server模块是，监听的端口 listen 和 server_name 组合起来是唯一的，\n    如果server_name一样，那么listen监听的端口就不一样；如端口一样，server_name就不一样。这是很好理解的，虚拟主机的请求映射系统才能够判别。\n\n## Nginx日志与日志切割\n\n### 日志文件的格式配置\n    nginx服务器在运行的时候，会有各种操作，操作的信息会记录到日志文件中，日志文件的记录是有格式的。那我们如何设置日志文件的格式呢？\n    使用log_format指令进行配置文件格式\n    nginx的log_format有很多可选的参数用于指示服务器的活动状态，默认的是：\n    log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '    '$status $body_bytes_sent \"$http_referer\" '    '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n    \n    192.168.31.247 - - [11/Mar/2018:16:26:43 +0800] \"GET / HTTP/1.1\" 304 0 \"-\" \"Mozilla/5.0 (Windows NT 10.0; WOW64) \n    AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3350.0 Safari/537.36\" \"-\"\n\n#### 日志相关参数\n    参数                      说明                                         示例\n    $remote_addr             客户端地址                                    211.28.65.253\n    $remote_user             客户端用户名称                                --\n    $time_local              访问时间和时区                                18/Jul/2012:17:00:01 +0800\n    $request                 请求的URI和HTTP协议                           \"GET /article-10000.html HTTP/1.1\"\n    $http_host               请求地址，即浏览器中你输入的地址（IP或域名）     www.wang.com 192.168.100.100\n    $status                  HTTP请求状态                                  200\n    $upstream_status         upstream状态                                  200\n    $body_bytes_sent         发送给客户端文件内容大小                        1547\n    $http_referer            url跳转来源                                   https://www.baidu.com/\n    $http_user_agent         用户终端浏览器等信息                           \"Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; SV1; GTB7.0; .NET4.0C;\n    $ssl_protocol            SSL协议版本                                   TLSv1\n    $ssl_cipher              交换数据中的算法                               RC4-SHA\n    $upstream_addr           后台upstream的地址，即真正提供服务的主机地址     10.10.10.100:80\n    $request_time            整个请求的总时间                               0.205\n    $upstream_response_time  请求过程中，upstream响应时间                    0.002\n    $http_x_forwarded_for    是反向代理服务器转发客户端地址的参数\n    \n    假设将Nginx服务器作为Web服务器，位于负载均衡设备、Squid、Nginx反向代理之后，不能获取到客户端的真实IP地址了。\n    原因是经过反向代理后，由于在客户端和Web服务器之间增加了中间层，因此Web服务器无法直接拿到客户端的IP。\n    通过$remote_addr变量拿到的将是反向代理服务器的IP地址。\n    但是，反向代理服务器在转发请求的HTTP头信息中，可以增加X-Forwarded-For信息，用以记录原有的客户端IP地址和原来客户端请求的服务器地址。\n    这时候，要用log_format指令设置日志格式，让日志记录X-Forearded-For信息中的IP地址，即客户的真实IP。\n    日志文件路径配置\n\n#### access_log指令\n    语法: access_log path [format [buffer=size [flush=time]]];\n    access_log path format gzip[=level] [buffer=size] [flush=time];\n    access_log off;\n    默认值: access_log logs/access.log combined;\n    配置段: \n    gzip压缩等级。\n    buffer设置内存缓存区大小。\n    flush保存在缓存区中的最长时间。\n    不记录日志：access_log off;\n    使用默认combined格式记录日志：access_log logs/access.log 或 access_log logs/access.log combined;\n    值得注意的是，Nginx进程设置的用户和组必须对日志路径有创建文件的权限，否则，会报错。\n    此外，对于每一条日志记录，都将是先打开文件，再写入日志，然后关闭。可以使用open_log_file_cache来设置日志文件缓存(默认是off)。\n\n#### 日志文件切割\n    server1.log   ---->  server1-2018-03-11.log  ---> server1-2018-03-12.log\n                  ----》 server1-2018-03-10.log \n    \n    通过mv命令 把当前log文件重命令\n    再用信号控制指令 发送重读日志指令  产生了新的日志log文件\n    \n    nginx日志默认情况下统统写入到一个文件中，文件会变的越来越大，非常不方便查看分析。\n    以日期来作为日志的切割是比较好的，通常我们是以每日来做统计的。下面来说说nginx日志切割。\n    我们先手动完成日志文件切割\n    到logs目录中，先备份日志文件，在重新生成日志文件\n    mv access.log access_20180124.log\n    kill -USR1 pid进程号   #向 Nginx 主进程发送 USR1 信号。USR1 信号是重新打开日志文件\n\n#### 系统自动切割\n    利用sh脚本的方式执行刚才的手动操作，在每天凌晨执行一个计划任务 调用sh脚本，就完成的系统自动切割日志文件\n    \n    编写脚本\n    在nginx目录下logs目录\n    # touch cutlog.sh脚本\n    # vi cutlog.sh \n    #!/bin/bash\n    LOGS_PATH=/usr/local/nginx/logs\n    YESTERDAY=$(date -d \"yesterday\" +%Y-%m-%d)\n    mv ${LOGS_PATH}/access.log ${LOGS_PATH}/access_${YESTERDAY}.log\n    kill -USR1 $(cat /usr/local/nginx/logs/nginx.pid)   # 向 Nginx 主进程发送 USR1 信号。USR1 信号是重新打开日志文件\n    \n    注意：执行 sed -i 's/\\r$//' cutlog.sh\n    原因：\n    \n        这个文件在Windows 下编辑过，在Windows下每一行结尾是\\n\\r，而Linux下则是\\n\n    \n        sed -i 's/\\r$//' cutlog.sh 会把cutlog.sh中的行尾的\\r替换为空白\n    \n    \n    设置定时任务\n    # vi  /etc/crontab\n    0 0 * * * root /usr/local/nginx/logs/cutlog.sh  \n    表示配置一个定时任务，定时每天00:00以root身份执行脚本/usr/local/nginx/logs/cutlog.sh，实现定时自动分割Nginx日志\n\n## Nginx的Location\n    nginx的location配置详解\n    1）语法规则： location [=|~|~*|^~] /uri/ { … }\n    构成：\n    指令                  前缀                  uri\n    location          [=|~|~*|^~]           /uri\n    \n    路由匹配规则，正则匹配，正则表达式\n    \n    \n    \n    2）location区分普通匹配和正则匹配\n    \n    用前缀 “~” 和 “~*”修饰的为正则匹配\n    ~   前缀表示区分大小写的正则匹配\n    ~*  前缀表示不区分大小写的正则匹配\n    \n    除上面修饰的前缀（“=” 和 “^~”，或没有前缀修饰）都为普通匹配\n    =   前缀表示精确匹配\n    ^~  前缀表示uri以某个常规字符串开头，可以理解为url的普通匹配\n    \n    location作用于server模块,且支持多个location模块\n    server {\n           .........\n            location /p {\n                root   html/p;\n                index  index.html index.htm;\n            }\n            location = /50x.html {\n                root   html;\n            }\n            location / {\n                root   html/server1;\n                index  index.html index.htm;\n            }\n    }\n    在多个location情况下，是按照什么原则进行匹配的呢？\n    \n    3）匹配的原则\n    普通匹配：优先原则---->最大前缀匹配原则; 顺序无关\n    如：\n    server {\n    \tlocation /prefix/ {\n    \t\t#规则A\n    \t}\n    \tlocation /prefix/mid/ {\n    \t\t#规则B\n    \t} \n    }\n    \n    请求url为：/prefix/mid/t.html \n    \n    此请求匹配的是 规则B，是以最大的匹配原则进行的，跟顺序无关\n    \n    ------------------------\n    正则匹配：为顺序匹配，优先原则：谁在前面 就匹配谁；顺序相关\n    如：\n    server {\n    \tlocation ~ \\.(gif|jpg|png|js|css)$ {\n    \t   \t\t#规则C\n    \t}\n    \tlocation ~* \\.png$ {\n    \t   \t\t#规则D\n    \t}\n    }\n    请求http://localhost/1.png,匹配的是规则C，因为规则C在前面，即叫做顺序匹配\n    \n    ----------------\n    如果location有普通匹配也有正则匹配，那匹配的原则为\n    匹配模式及顺序\n    ----带前缀普通匹配 最优先，=前缀优先级最高\n    location = /uri 　　　=开头表示精确匹配，只有完全匹配上才能生效。\n    location ^~ /uri 　　^~ 开头对URL路径进行前缀匹配，并且在正则之前。\n    ----正则匹配\n    location ~ pattern 　~开头表示区分大小写的正则匹配。\n    location ~* pattern 　~*开头表示不区分大小写的正则匹配。\n    ---不带前缀匹配\n    location /uri 　　　　不带任何修饰符，也表示前缀匹配，但是在正则匹配之后。\n    \n    location / 　　　　　通用匹配，任何未匹配到其它location的请求都会匹配到，相当于switch中default。 \n    \n    首先匹配 =，其次匹配^~, 其次是按文件中顺序的正则匹配，不带前缀普通匹配，最后是交给 / 通用匹配。\n    当有匹配成功时候，停止匹配，按当前匹配规则处理请求。\n    \n    例子，有如下匹配规则：\n    location = / {\n                return 200 '规则A';\n            }\n    location = /login {\n                return 200 '规则B';\n            }\n    location ^~ /static/ {\n                return 200 '规则C';\n            }\n    location ~ \\.(gif|jpg|png|js|css)$ {\n                return 200 '规则D';\n            }\n    location ~* \\.js$ {\n                return 200 '规则E';\n            }\t\n    location / {\n                return 200 '规则F';\n    }\n    那么产生的效果如下：\n    访问根目录/， 比如http://localhost/ 将匹配规则A\n    访问 http://localhost/login 将匹配规则B，\n    http://localhost/register 则匹配规则F\n    http://localhost/static/a.html 将匹配规则C\n    http://localhost/a.css, 匹配规则D\n    http://localhost/b.js则优先匹配到 规则D，不会匹配到规则E\n    http://localhost/static/c.js 则优先匹配到 规则C\n    http://localhost/a.JS 则匹配规则E， 而不会匹配规则D，因为规则E不区分大小写。\n    访问 http://localhost/category/id/1111 则最终匹配到规则F，因为以上规则都不匹配，\n    \n    \n    4）在实际场景中，通常至少有三个匹配规则定义，如下：\n    #直接匹配网站根，通过域名访问网站首页比较频繁，使用这个会加速处理。\n    #这里是直接转发给后端应用服务器了，也可以是一个静态首页\n    # 第一个必选规则\n    location = / {\n        .....\n    }\n    # 第二个必选规则是处理静态文件请求，这是nginx作为http服务器的强项\n    # 有两种配置模式，目录匹配或后缀匹配,任选其一或搭配使用\n    location ^~ /static {\n        root /webroot/static/;\n    }\n    location ~* \\.(gif|jpg|jpeg|png|css|js|ico)$ {\n        root /webroot/res/;\n    }\n    #第三个规则就是通用规则，用来转发动态请求到后端应用服务器\n    #非静态文件请求就默认是动态请求，自己根据实际把握\n    #毕竟目前的一些框架的流行，带.php,.jsp后缀的情况很少了\n    location / {\n        .....\n    }\n\n## Nginx负载均衡\n    当一台服务器单位时间内访问量很大的时候，服务器压力就会很大，当达到这台服务器的极限，就会崩溃；怎么解决？\n    可以通过nginx的反向代理设置，添加几台同样功能的服务器 分担压力。\n    \n    nginx实现负载均衡原理，用户访问首先访问到nginx服务器，然后nginx服务器再从应用服务器集群中选择压力比较小的服务器，然后将该访问请求引向该服务器。\n    如应用服务器集群中某一台服务器崩溃，那么从待选择服务器列表中将该服务器删除，也就是说一个服务器崩溃了，那么nginx服务器不会把请求引向到该服务器。\n    \n    upstream mypro {\n        server 192.168.5.140:8080;\n        server 192.168.5.141:8080;\n        xxxxx\n        xxxx\n    }\n    \n    server {\n        listen 80;\n        server_name xxxx;\n        location / {\n            proxy_pass http://mypro;\n        } \n     }\n    \n### 负载均衡方案\n    \n#### 随机轮询\n    upstream mypro {\n        server 192.168.5.140:8080;\n        server 192.168.5.141:8080;\n    }\n    \n#### 权重\n    upstream mypro {\n        server 192.168.5.140:8080 weight=5;\n        server 192.168.5.141:8080 weight=10;\n    }\n    \n#### ip_hash\n    upstream mypro {\n        ip_hash;\n        server 192.168.5.140:8080;\n        server 192.168.5.141:8080;\n    }\n    \n#### 使用方式\n    server {\n        listen       80;\n        server_name  192.168.5.138;\n         location / {\n            proxy_pass http://mypro;\n        }\n    }\n    \n## Nginx拓展模块安装\n    查看nginx安装的现有模块指令\n    /usr/local/nginx/sbin/nginx -V （大写的V）\n    nginx version: nginx/1.13.2\n    built by gcc 4.8.5 20150623 (Red Hat 4.8.5-16) (GCC) \n    configure arguments:\n    \n    1、下载需要的echo模块\n    https://github.com/openresty/echo-nginx-module/tags\n    # wget https://github.com/openresty/echo-nginx-module/archive/v0.61.tar.gz\n    # tar zxvf v0.61.tar.gz\n    # mv echo-nginx-module-0.61 nginx-tools/\n    \n    2、重新编译nginx，安装echo-nginx模块\n    进入nginx源文件，重新编译\n    # ./configure --add-module=nginx安装目录下面/echo-nginx-module-0.61 #安装echo模块(文件夹名echo-nginx-module-0.61)\n    # make #开始编译，但别安装 （make install会直接覆盖安装）\n    \n    3、平滑升级 nginx\n    \n    注意先备份一下之前老的，手动安装一下。\n    # mv /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.old\n    # cp -f objs/nginx /usr/local/nginx/sbin/nginx\n    \n    这里是平滑升级，如是全新安装请执行：make install\n    # make upgrade \n    # make clean （清除编译产生的文件，可以忽略）\n    \n    \n    \n    location /module {\n        echo 'hello world'; \n    }\n    --------------------\n    location /module {\n                echo_exec /set;\n    }\n            \n    location /set {\n        set $foo 'hello world';     #自定义变量\n        echo \"$request_uri\";      #显示nginx全局变量的内容\n        echo $foo;\n    }\n    \n    \n    lua模块：可以在nginx服务中执行lua脚本\n    \n    \n    nginx全局变量\n    $args ：                     #这个变量等于请求行中的参数，同$query_string\n    $content_length ：    #请求头中的Content-length字段。\n    $content_type ：       #请求头中的Content-Type字段。\n    $document_root ：   #当前请求在root指令中指定的值。\n    $host ：                     #请求主机头字段，否则为服务器名称。\n    $http_user_agent ：  #客户端agent信息\n    $http_cookie ：          #客户端cookie信息\n    $limit_rate ：              #这个变量可以限制连接速率。\n    $request_method ：   #客户端请求的动作，通常为GET或POST。\n    $remote_addr ：         #客户端的IP地址。\n    $remote_port ：          #客户端的端口。\n    $remote_user ：         #已经经过Auth Basic Module验证的用户名。\n    $request_filename ： #当前请求的文件路径，由root或alias指令与URI请求生成。\n    $scheme ：                #HTTP方法（如http，https）。\n    $server_protocol ：    #请求使用的协议，通常是HTTP/1.0或HTTP/1.1。\n    $server_addr ：         #服务器地址，在完成一次系统调用后可以确定这个值。\n    $server_name ：       #服务器名称。\n    $server_port ：          #请求到达服务器的端口号。\n    $request_uri ：          #包含请求参数的原始URI，不包含主机名，如：”/foo/bar.php?arg=baz”。\n    $uri ：                        #不带请求参数的当前URI，$uri不包含主机名，如”/foo/bar.html”。\n    $document_uri ：      #与$uri相同\n\n## Nginx的Lua模块\n\n    Nginx的优势\n        Nginx设计为一个主进程多个工作进程的工作模式，每个进程是单线程来处理多个连接，而且每个工作进程采用了非阻塞I/O来处理多个连接，\n        从而减少了线程上下文切换，从而实现了公认的高性能、高并发;因此在生成环境中会通过把CPU绑定给Nginx工作进程从而提升其性能;另外因为单线程工作模式的特点，内存占用就非常少了。 \n        Nginx更改配置重启速度非常快，可以毫秒级，而且支持不停止Nginx进行升级Nginx版本、动态重载Nginx配置。  \n        Nginx模块也是非常多，功能也很强劲，不仅可以作为http负载均衡，Nginx发布1.9.0版本还支持TCP负载均衡，还可以很容易的实现内容缓存、web服务器、反向代理、访问控制等功能。\n        nginx模块：rewrite 经常用到的\n    \n    什么是ngx_lua\n        ngx_lua是Nginx的一个模块，将Lua嵌入到Nginx中，从而可以使用Lua来编写脚本，这样就可以使用Lua编写应用脚本，部署到Nginx中运行，即Nginx变成了一个Web容器;\n        这样开发人员就可以使用Lua语言开发高性能Web应用了。\n        \n        网站开发，也有一个重要的脚步语言，javascript，js文件；；；客户端脚步语言；；；（node.js服务器语言）\n        网站页面进行渲染的时候，可以通过javascript脚本语言 进行一些业务处理\n        <script>\n        function hello(){\n        \talert(\"hello\");\n        }\n        </script>\n        脚本文件，还需要一个javascript引擎---解析javascript脚本语言\n        全部的浏览器 都包含 javascript引擎\n        \n        \n        lua -- javascript  一样的脚本语言\n        lua脚本语言 应用  ----》游戏开发中\n        \n        \n        Lua是一种轻量级、可嵌入式的脚本语言，这样可以非常容易的嵌入到其他语言中使用。另外Lua提供了协程并发，\n        即以同步调用的方式进行异步执行，从而实现并发，比起回调机制的并发来说代码更容易编写和理解，排查问题也会容易。Lua还提供了闭包机制，\n        函数可以作为First Class Value 进行参数传递，另外其实现了标记清除垃圾收集。\n        \n        因为Lua的小巧轻量级，可以在Nginx中嵌入Lua VM，请求的时候创建一个VM，请求结束的时候回收VM。\n        \n        ngx_lua模块的原理：\n        ngx_lua将Lua嵌入Nginx，能够让Nginx运行Lua脚本，而且高并发、非堵塞的处理各种请求。Lua内建协程。这样就能够非常好的将异步回调转换成顺序调用的形式。ngx_lua在Lua中进行的IO操作都会托付给Nginx的事件模型。从而实现非堵塞调用。\n        开发人员能够採用串行的方式编敲代码，ngx_lua会自己主动的在进行堵塞的IO操作时中断。保存上下文；然后将IO操作托付给Nginx事件处理机制。在IO操作完毕后，ngx_lua会恢复上下文，程序继续运行，这些操作都是对用户程序透明的。\n        每一个NginxWorker进程持有一个Lua解释器或者LuaJIT实例，被这个Worker处理的全部请求共享这个实例。\n        \n        每一个请求的Context会被Lua轻量级的协程切割，从而保证各个请求是独立的。 ngx_lua採用“one-coroutine-per-request”的处理模型。对于每一个用户请求，ngx_lua会唤醒一个协程用于执行用户代码处理请求，当请求处理完毕这个协程会被销毁。\n        \n        每一个协程都有一个独立的全局环境（变量空间），继承于全局共享的、仅仅读的“comman data”。所以。被用户代码注入全局空间的不论什么变量都不会影响其它请求的处理。而且这些变量在请求处理完毕后会被释放，\n        这样就保证全部的用户代码都执行在一个“sandbox”（沙箱），这个沙箱与请求具有同样的生命周期。 得益于Lua协程的支持。ngx_lua在处理10000个并发请求时仅仅须要非常少的内存。依据測试，ngx_lua处理每一个请求仅仅须要2KB的内存，\n        假设使用LuaJIT则会更少。所以ngx_lua非常适合用于实现可扩展的、高并发的服务。\n        \n        ngx_lua 模块提供的指令和API\n        \n        三、ngx_lua安装\n        echo模块\n            ngx_lua安装能够通过下载模块源代码，编译Nginx。可是推荐採用openresty。Openresty就是一个打包程序，包括大量的第三方Nginx模块，比方HttpLuaModule，HttpRedis2Module，HttpEchoModule等。省去下载模块。而且安装很方便。        \n            OpenResty将Nginx核心、LuaJIT、许多有用的Lua库和Nginx第三方模块打包在一起;这样开发人员只需要安装OpenResty，不需要了解Nginx核心和写复杂的C/C++模块就可以，只需要使用Lua语言进行Web应用开发了。        \n        \n        OpenResty提供了一些常用的ngx_lua开发模块：如        \n            lua-resty-memcached       \n            lua-resty-mysql        \n            lua-resty-redis        \n            lua-resty-dns        \n            lua-resty-limit-traffic        \n            lua-resty-template       \n        nginx + lua 就可以开发出 一些系统。龙果学院中 有一门课程 就专门应用了这个技术  \n        这些模块涉及到如mysql数据库、redis、限流、模块渲染等常用功能组件;另外也有很多第三方的ngx_lua组件供我们使用，对于大部分应用场景来说现在生态环境中的组件已经足够多了;如果不满足需求也可以自己去写来完成自己的需求。\n        openresty.org/cn官网\n        \n        应用场景\n        应用的公司：奇虎360、京东、百度、魅族、知乎、优酷、新浪这些互联网公司都在使用。\n        业务场景： WAF、有做 CDN 调度、广告系统、消息推送系统，API server 网关\n    \n","slug":"微服务API网关框架-2","published":1,"updated":"2018-12-20T03:06:44.188Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpw2eyfw000an0ujhz3bxf4f","content":"<h1><span id=\"nginx\">Nginx</span></h1>\n<h2><span id=\"nginx命令\">Nginx命令</span></h2>\n<h3><span id=\"nginx的基本配置\">Nginx的基本配置</span></h3>\n<pre><code>Nginx的主配置文件是：nginx.conf，nginx.conf主要组成如下：\n\n# 全局区   有一个工作子进程，一般设置为CPU数 * 核数\nworker_processes  1; \nevents {\n    # 一般是配置nginx进程与连接的特性\n    # 如1个word能同时允许多少连接，一个子进程最大允许连接1024个连接\n     worker_connections  1024;\n}\n # 配置HTTP服务器配置段\nhttp {\n    # 配置虚拟主机段\n    server {\n         # 定位，把特殊的路径或文件再次定位。\n         location  {\n                   \n         } \n    }\n     server {\n                   \n     } \n}\n</code></pre>\n<h3><span id=\"nginx启动\">nginx启动</span></h3>\n<pre><code>指令：nginx程序   -c   nginx配置文件\n# /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf\n</code></pre>\n<h3><span id=\"nginx重启\">nginx重启</span></h3>\n<pre><code>#cd /usr/local/nginx/sbin\n##重启\n# ./nginx -s reload   \n进入nginx可执行程序的目录\n# cd /usr/local/nginx/sbin/\n# ./nginx -s reload\nnginx: [error] invalid PID number &quot;&quot; in &quot;/usr/local/nginx/logs/nginx.pid&quot;\n重启是建立在nginx服务需要启动\n</code></pre>\n<h3><span id=\"nginx停止\">nginx停止</span></h3>\n<pre><code># ./nginx -s stop \n# ./nginx -s quit\n\nquit 是一个优雅的关闭方式，Nginx在退出前完成已经接受的连接请求\nstop 是快速关闭，不管有没有正在处理的请求。\n</code></pre>\n<h3><span id=\"重新打开日志\">重新打开日志</span></h3>\n<pre><code># 用于日志切割   \n# ./nginx -s reopen   \n</code></pre>\n<h3><span id=\"nginx检查配置文件\">nginx检查配置文件</span></h3>\n<pre><code>检查配置文件是否正确\n第一种\n进入nginx可执行程序的目录\n# cd /usr/local/nginx/sbin/\n# ./nginx -t\n\n第二种\n# /usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.conf\n</code></pre>\n<h2><span id=\"nginx信号控制\">Nginx信号控制</span></h2>\n<pre><code>Nginx支持2种进程模型Single和Master-Worker\nSingle是单进程，一般不适用，\nMaster-Worker是主进程和工作进程模型运行，主进程对工作进程管理。\nNginx允许我们通过信号来控制主进程，用信号的方式可以达到不影响现有连接的目的。 \n</code></pre>\n<h3><span id=\"信号类型\">信号类型</span></h3>\n<pre><code>INT，TERM\t\t快速关闭信号\nQUIT\t\t\t从容关闭信号\nHUP\t\t\t\t从容重启信号，一般用于修改配置文件后，重启\nUSR1\t\t\t重读日志，一般用于日志的切割\nUSR2\t\t\t平滑升级信号\nWINCH\t\t\t从容关闭旧进程\n\n具体语法:\nkill    -信号选项    nginx的主进程号\n例：\n# kill -INT 26661 \n# kill -HUP 4873\n</code></pre>\n<h4><span id=\"nginx的优雅停止\">Nginx的优雅停止</span></h4>\n<pre><code>1）nginx停止\n#  ps -ef | grep nginx 获得进程号\n\n第1种从容“优雅”停止\n# kill -QUIT master进程号\n# Nginx服务可以正常地处理完当前所有请求再停止服务\n# 步骤：首先会关闭监听端口，停止接收新的连接，然后把当前正在处理的连接全部处理完，最后再退出进程。\n\n第2种快速停止\n# kill -TERM master进程号\n# kill -INT master进程号\n# 快速停止服务时，worker进程与master进程在收到信号后会立刻跳出循环，退出进程。\n第3种强制停止\n# pkill -9 nginx\n# 系统强杀nginx进程\n\n2）重启nginx\n# kill -HUP master进程号\n</code></pre>\n<h4><span id=\"nginx平滑升级\">Nginx平滑升级</span></h4>\n<pre><code>原理:把服务器从低版本升级为高版本，强行停止服务器，会影响正在运行的进程。\n     平滑升级不会停掉正在进行中的进程，这些进程会继续处理请求。但不会再接受新请求，这些老的进程在处理完请求之后 会停止。此平滑升级过程中，新开的进程会被处理。\n\n\n一）平滑升级\n    进入nginx可执行程序的目录\n         #  cd /usr/local/nginx/sbin/\n         # ./nginx -V  #查看nginx版本\n\n    1）下载高版本nginx http://nginx.org/download/nginx-1.13.1.tar.gz\n    执行指令\n    #  ./configure\n    # make    #不能执行 make install\n    # cd objs\n    此目录下 有高版本的nginx\n    备份低版本的nginx\n    cp nginx nginx.old\n    执行强制覆盖\n    cp -rfp objs/nginx /usr/local/nginx/sbin\n\n    测试一下新复制过来文件生效情况：\n    # /usr/local/nginx/sbin/nginx -t\n    # ps -ef | grep nginx\n\n    2）执行信号平滑升级\n        # kill -USR2 `cat /usr/local/nginx/logs/nginx.pid`  更新配置文件\n        给nginx发送USR2信号后，nginx会将logs/nginx.pid文件重命名为nginx.pid.oldbin，然后用新的可执行文件启动一个新的nginx主进程和对应的工作进程，并新建一个新的nginx.pid保存新的主进程号\n        \n        # ps -ef | grep nginx\n        \n        # ll logs/\n    \n    \n    3）kill -WINCH 旧的主进程号\n        旧的主进程号收到WINCH信号后，将旧进程号管理的旧的工作进程优雅的关闭。即一段时间后旧的工作进程全部关闭，只有新的工作进程在处理请求连接。\n        这时，依然可以恢复到旧的进程服务，因为旧的进程的监听socket还未停止。\n        处理完后，工作进程会自动关闭\n        # ps -ef | grep nginx\n    \n    4）# kill -QUIT `cat /usr/local/nginx/logs/nginx.pid.oldbin` 优雅的关闭\n        给旧的主进程发送QUIT信号后，旧的主进程退出，并移除logs/nginx.pid.oldbin文件，nginx的升级完成。\n    \n    升级完成了，最后在看一下升级后的版本\n\n    查看\n    ./nginx -V\n    已经平滑升级成功\n\n二）中途停止升级，回滚到旧的nginx\n    在步骤(3)时，如果想回到旧的nginx不再升级\n    \n    (1)给旧的主进程号发送HUP命令，此时nginx不重新读取配置文件的情况下重新启动旧主进程的工作进程。\n        kill -HUP 9944 --旧主进程号\n        重启工作进程\n    (2)优雅的关闭新的主进程\n        kill -QUIT 10012  --新主进程号\n</code></pre>\n<h4><span id=\"nginx-用户\">Nginx 用户</span></h4>\n<pre><code>#以哪个用户，运行nginx应用\n#nobody是个低权限用户，为了安全\n#user nobody;\n</code></pre>\n<h4><span id=\"nginx-进程数设置\">Nginx 进程数设置</span></h4>\n<pre><code>worker_processes：表示开启nginx的worker进程的个数，nginx启动会开两种进程，master进程用来管理调度，worker进程用来处理请求；\n上面表示两种设置方法，比如\n方法一：worker_processes auto;\n　　表示设置服务器cpu核数匹配开启nginx开启的worker进程数    \n　　查看cpu核数：cat /proc/cpuinfo    \n方法二：nginx设置cpu亲和力\n　　worker_processes 8;    \n　　worker_cpu_affinity 00000001 00000010 00000100 00001000 00010000 00100000 01000000 10000000;    \n　　00000001表示启用第一个CPU内核，00000010表示启用第二个CPU内核，以此类推\n\nworker_cpu_affinity：表示开启八个进程，第一个进程对应着第一个CPU内核，第二个进程对应着第二个CPU内核，以此类推。\n    这种设置方法更高效，因将每个cpu核提供给固定的worker进程服务，减少cpu上下文切换带来的资源浪费\n\n如果服务器cpu有限\n    比如：2核CPU，开启2个进程，设置如下 \n    worker_processes     2;   \n    worker_cpu_affinity 01 10;  \n    比如：4核CPU,开启4个进程，设置如下\n    worker_processes     4;\n    worker_cpu_affinity 0001 0010 0100 1000;\n\n8核cpu , worker_processes=8\n1个worker进程 能够最大打开的文件数（线程数）worker_connections=65535 （参考worker_rlimit_nofile  ----&gt;  linux  ulimit -n）\n最大的客户端连接数 max_clients = （多少个工作进程数）worker_processes * （1个工作线程的处理线程数）worker_connections    8*65535\n</code></pre>\n<h4><span id=\"nginx的并发量计算\">Nginx的并发量计算</span></h4>\n<pre><code>#nginx作为http服务器\n#请求模型   client &lt;---&gt; nginx\n#max_clients = worker_processes * worker_connections/2\n\n#nginx作为反向代理服务器的时候\n#请求模型   client &lt;---&gt; nginx  &lt;----&gt; web server\n#max_clients = worker_processes * worker_connections/4\n(\n为什么除以2：该公式基于http 1.1协议，一次请求大多数浏览器发送两次连接，并不是request和response响应占用两个线程（很多人也是这么认为，实际情况：请求是双向的，连接是没有方向的，由上面的图可以看出来)\n为什么除以4：因nginx作为方向代理，客户端和nginx建立连接，nginx和后端服务器也要建立连接\n)\n\n由此，我们可以计算nginx作为http服务器最大并发量(作为反向代理服务器自己类推)，可以为压测和线上环境的优化提供一些理论依据：\n单位时间（keepalive_timeout）内nginx最大并发量C\nC=worker_processes * worker_connections/2=8*65535/2\n\n而每秒的并发量CS\nCS=worker_processes * worker_connections/(2*65)    \n</code></pre>\n<h4><span id=\"nginx全局错误日志\">Nginx全局错误日志</span></h4>\n<pre><code>#全局错误日志 \n    #nginx的error_log类型如下（从左到右：debug最详细 crit最少）： \n    #[ debug | info | notice | warn | error | crit ] \n\n#例如：error_log logs/nginx_error.log  crit; \n#解释：日志文件存储在nginx安装目录下的 logs/nginx_error.log ，错误类型为 crit ，也就是记录最少错误信息;\n    error_log  logs/error.log;\n    error_log  logs/notice.log  notice;\n    error_log  logs/info.log  info;\n</code></pre>\n<h4><span id=\"nginx主进程id\">Nginx主进程ID</span></h4>\n<pre><code>#PID文件，记录当前启动的nginx的进程ID\n    pid        logs/nginx.pid; # 主进程ID存放位置\n</code></pre>\n<h4><span id=\"nginx的worker进程\">Nginx的worker进程</span></h4>\n<pre><code>worker_rlimit_nofile 65535;\n\n#这个参数表示worker进程最多能打开的文件句柄数，基于liunx系统ulimit设置\n#查看系统文件句柄数最大值：ulimit -n\n#Linux一切皆文件，所有请求过来最终目的访问文件，所以该参数值设置等同于liunx系统ulimit设置为优\n#可以通过linux命令设置  最大的文件句柄数65535\n</code></pre>\n<h4><span id=\"nginx工作模式与连接数上限\">Nginx工作模式与连接数上限</span></h4>\n<pre><code>events {\n   #网络模型高效(相当于建立索引查找结果)，nginx配置应该启用该参数\n   #但是仅用于linux2.6以上内核,可以大大提高nginx的性能\n   use   epoll;             \n   #该参数表示设置一个worker进程最多开启多少线程数\n   #优化设置应该等同于worker_rlimit_nofile设置值，表明一个线程处理一个http请求，同时可以处理一个文件数，各个模块之间协调合作不等待。\n   worker_connections  65535;\n}\n</code></pre>\n<h4><span id=\"nginx负载均衡\">Nginx负载均衡</span></h4>\n<pre><code> #设定http服务器，利用它的反向代理功能提供负载均衡支持\n     http {\n          #设定mime类型,类型由mime.type文件定义\n          #MIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来#打开的方式类型，\n          当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开\n         include       /etc/nginx/mime.types;\n         default_type  application/octet-stream;\n         #设定日志格式\n        log_format  main  '[$remote_addr] - [$remote_user] [$time_local] &quot;$request&quot; '\n                       '$status $body_bytes_sent &quot;$http_referer&quot; '\n                       '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;';\n         access_log    /var/log/nginx/access.log;\n \n         #sendfile 开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，\n         如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。\n         sendfile        on;\n         tcp_nopush     on; #防止网络阻塞\n         tcp_nodelay        on; #防止网络阻塞\n \n         #连接超时时间\n         #keepalive_timeout  0;  \n         keepalive_timeout  65; #长连接超时时间，单位是秒\n        \n \n         #开启gzip压缩\n        gzip  on;\n \t\tgzip_disable &quot;MSIE [1-6]\\.&quot;; # IE6及以下禁止压缩 \n        gzip_min_length 1k; #最小压缩文件大小\n \t\tgzip_buffers 4 16k; #压缩缓冲区\n \t\tgzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0）\n \t\tgzip_comp_level 2; #压缩等级\n \t\tgzip_types text/plain application/x-javascript text/css application/xml; #压缩类型\n \t\tgzip_vary on; #给CDN和代理服务器使用，针对相同url，可以根据头信息返回压缩和非压缩副本\n \n \n         #设定请求缓冲\n         client_header_buffer_size    1k;   #上传文件大小限制\n         large_client_header_buffers  4 4k;  #设定请求缓存\n \n \n         #设定负载均衡的服务器列表\n         upstream mysvr {\n \t        #weigth参数表示权值，权值越高被分配到的几率越大\n \t        server 192.168.8.1x:3128 weight=5;\n \t        server 192.168.8.2x:80  weight=1;\n \t        server 192.168.8.3x:80  weight=6;\n         }\n \n         upstream mysvr2 {\n \t        #weigth参数表示权值，权值越高被分配到的几率越大\n \t        server 192.168.8.x:80  weight=1;\n \t        server 192.168.8.x:80  weight=6;\n         }\n \n         #虚拟主机的配置\n        server {\n             #侦听80端口\n             listen       80;\n             #设置编码\n  \t          #charset koi8-r;\n \n             #定义使用www.xx.com访问 域名可以有多个，用空格隔开\n             server_name  www.xx.com;\n \n             #设定本虚拟主机的访问日志\n             access_log  logs/www.xx.com.access.log  main;\n \n         #默认请求\n         location / {\n               root   /root;      #定义服务器的默认网站根目录位置\n               index index.php index.html index.htm;   #定义首页索引文件的名称\n \n \n              proxy_pass  http://mysvr ;#请求转向mysvr 定义的服务器列表\n \n               client_max_body_size 10m;    #允许客户端请求的最大单文件字节数\n               client_body_buffer_size 128k;  #缓冲区代理缓冲用户端请求的最大字节数，\t\n \n              #以下是一些反向代理的配置可删除.\n \n               proxy_redirect off;\n \n               #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP\n               proxy_set_header Host $host;\n               proxy_set_header X-Real-IP $remote_addr;\n               proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n               proxy_connect_timeout 90;  #nginx跟后端服务器连接超时时间(代理连接超时)\n               proxy_send_timeout 90;        #后端服务器数据回传时间(代理发送超时)\n               proxy_read_timeout 90;         #连接成功后，后端服务器响应时间(代理接收超时)\n               proxy_buffer_size 4k;             #设置代理服务器（nginx）保存用户头信息的缓冲区大小\n               proxy_buffers 4 32k;               #proxy_buffers缓冲区，网页平均在32k以下的话，这样设置\n               proxy_busy_buffers_size 64k;    #高负荷下缓冲大小（proxy_buffers*2）\n               proxy_temp_file_write_size 64k;  #设定缓存文件夹大小，大于这个值，将从upstream服务器传\n \n         }\n \n         # 定义错误提示页面\n         error_page   500 502 503 504 /50x.html; \n             location = /50x.html {\n             root   /root;\n         }\n \n         #本地动静分离反向代理配置\n \t\t#所有jsp的页面均交由tomcat或resin处理\n \t\tlocation ~ .(jsp|jspx|do)?$ {\n \t\t\tproxy_set_header Host $host;\n \t\t\tproxy_set_header X-Real-IP $remote_addr;\n \t\t\tproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n \t\t\tproxy_pass http://127.0.0.1:8080;\n \t\t}\n \n         #静态文件，nginx自己处理\n         location ~ ^/(images|javascript|js|css|flash|media|static)/ {\n             root /var/www/virtual/htdocs;\n             #过期30天，静态文件不怎么更新，过期可以设大一点，如果频繁更新，则可以设置得小一点。\n             expires 30d;\n         }\n \n         #设定查看Nginx状态的地址\n         location /NginxStatus {\n             stub_status            on;\n             access_log              on;\n             auth_basic              &quot;NginxStatus&quot;;\n             auth_basic_user_file  conf/htpasswd;\n             #htpasswd文件的内容可以用apache提供的htpasswd工具来产生。\n         }\n         #禁止访问 .htxxx 文件\n         location ~ /\\.ht {\n             deny all;\n         }\n \n         }\n     }\n</code></pre>\n<h4><span id=\"nginx虚拟主机\">Nginx虚拟主机</span></h4>\n<pre><code>1）虚拟主机\n虚拟主机使用的是特殊的软硬件技术，它把一台运行在因特网上的服务器主机分成一台台“虚拟”的主机，每台虚拟主机都可以是一个独立的网站，可以具有独立的域名，\n具有完整的Intemet服务器功能（WWW、FTP、Email等），同一台主机上的虚拟主机之间是完全独立的。从网站访问者来看，每一台虚拟主机和一台独立的主机完全一样。\n利用虚拟主机，不用为每个要运行的网站提供一台单独的Nginx服务器或单独运行一组Nginx进程。虚拟主机提供了在同一台服务器、同一组Nginx进程上运行多个网站的功能。\n\n2）配置虚拟主机\n我们先配置在一个nginx中配置一个虚拟主机，编辑nginx.conf配置文件，在http模块中，配置server模块，一个server模块就针对一个虚拟主机。\n我们模拟一个独立的网站，此网站域名访问为www.server1.com；网站的根目录放到nginx目录下html/server1目录，我们创建一个首页index.html到server1中，编辑index.html\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;server1 首页&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;server1 首页&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n下面我们回到nginx.conf配置文件中，配置server模块\nserver {\nlisten 80; #监听80端口\nserver_name www.server1.com; #虚拟主机名，可以为域名或ip地址\nlocation / { #默认请求路由，以后文章中会重点介绍\nroot html/server1; #网站的根目录\nindex index.html index.htm; #默认首页文件名\n}\n}\n配置完成之后，重启nginx。因为www.server1.com是模拟的，需要在访问的客户端配置一下域名映射，老顾访问的客户端用的是windows系统，\n所以要到C:\\Windows\\System32\\drivers\\etc\\目录下，编辑hosts文件，增加个映射\n192.168.5.150 www.server1.com\n192.168.5.150是老顾的nginx服务器地址，注意编辑hosts要用管理员身份编辑，要不然会报无权限修改错误。\n打开浏览器，访问www.server1.com\n\n\n3）第一个虚拟主机配置完成，我们再配置一个server2，与server1配置类似，先给server2网站创建一个根目录，nginx目录下html/server2目录，编辑index.html\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;server2&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;server2 首页&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n再编辑nginx.conf，再增加个server模块，监听还是80端口，但服务名改为www.server2.com\nserver {\nlisten 80; #监听80端口\nserver_name www.server2.com; #虚拟主机名，可以为域名或ip地址\nlocation / { #默认请求路由，以后文章中会重点介绍\n    root html/server2; #网站的根目录\n    index index.html index.htm; #默认首页文件名\n}\n}\n重启nginx，不要忘了把hosts再增加个域名映射\n192.168.5.150 www.server2.com\n打开浏览器访问www.server2.com,运行结果\n\n\n这样第二个虚拟主机也配置完成。说明一下 再配置server模块是，监听的端口 listen 和 server_name 组合起来是唯一的，\n如果server_name一样，那么listen监听的端口就不一样；如端口一样，server_name就不一样。这是很好理解的，虚拟主机的请求映射系统才能够判别。\n</code></pre>\n<h2><span id=\"nginx日志与日志切割\">Nginx日志与日志切割</span></h2>\n<h3><span id=\"日志文件的格式配置\">日志文件的格式配置</span></h3>\n<pre><code>nginx服务器在运行的时候，会有各种操作，操作的信息会记录到日志文件中，日志文件的记录是有格式的。那我们如何设置日志文件的格式呢？\n使用log_format指令进行配置文件格式\nnginx的log_format有很多可选的参数用于指示服务器的活动状态，默认的是：\nlog_format  main  '$remote_addr - $remote_user [$time_local] &quot;$request&quot; '    '$status $body_bytes_sent &quot;$http_referer&quot; '    '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;';\n\n192.168.31.247 - - [11/Mar/2018:16:26:43 +0800] &quot;GET / HTTP/1.1&quot; 304 0 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) \nAppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3350.0 Safari/537.36&quot; &quot;-&quot;\n</code></pre>\n<h4><span id=\"日志相关参数\">日志相关参数</span></h4>\n<pre><code>参数                      说明                                         示例\n$remote_addr             客户端地址                                    211.28.65.253\n$remote_user             客户端用户名称                                --\n$time_local              访问时间和时区                                18/Jul/2012:17:00:01 +0800\n$request                 请求的URI和HTTP协议                           &quot;GET /article-10000.html HTTP/1.1&quot;\n$http_host               请求地址，即浏览器中你输入的地址（IP或域名）     www.wang.com 192.168.100.100\n$status                  HTTP请求状态                                  200\n$upstream_status         upstream状态                                  200\n$body_bytes_sent         发送给客户端文件内容大小                        1547\n$http_referer            url跳转来源                                   https://www.baidu.com/\n$http_user_agent         用户终端浏览器等信息                           &quot;Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; SV1; GTB7.0; .NET4.0C;\n$ssl_protocol            SSL协议版本                                   TLSv1\n$ssl_cipher              交换数据中的算法                               RC4-SHA\n$upstream_addr           后台upstream的地址，即真正提供服务的主机地址     10.10.10.100:80\n$request_time            整个请求的总时间                               0.205\n$upstream_response_time  请求过程中，upstream响应时间                    0.002\n$http_x_forwarded_for    是反向代理服务器转发客户端地址的参数\n\n假设将Nginx服务器作为Web服务器，位于负载均衡设备、Squid、Nginx反向代理之后，不能获取到客户端的真实IP地址了。\n原因是经过反向代理后，由于在客户端和Web服务器之间增加了中间层，因此Web服务器无法直接拿到客户端的IP。\n通过$remote_addr变量拿到的将是反向代理服务器的IP地址。\n但是，反向代理服务器在转发请求的HTTP头信息中，可以增加X-Forwarded-For信息，用以记录原有的客户端IP地址和原来客户端请求的服务器地址。\n这时候，要用log_format指令设置日志格式，让日志记录X-Forearded-For信息中的IP地址，即客户的真实IP。\n日志文件路径配置\n</code></pre>\n<h4><span id=\"access_log指令\">access_log指令</span></h4>\n<pre><code>语法: access_log path [format [buffer=size [flush=time]]];\naccess_log path format gzip[=level] [buffer=size] [flush=time];\naccess_log off;\n默认值: access_log logs/access.log combined;\n配置段: \ngzip压缩等级。\nbuffer设置内存缓存区大小。\nflush保存在缓存区中的最长时间。\n不记录日志：access_log off;\n使用默认combined格式记录日志：access_log logs/access.log 或 access_log logs/access.log combined;\n值得注意的是，Nginx进程设置的用户和组必须对日志路径有创建文件的权限，否则，会报错。\n此外，对于每一条日志记录，都将是先打开文件，再写入日志，然后关闭。可以使用open_log_file_cache来设置日志文件缓存(默认是off)。\n</code></pre>\n<h4><span id=\"日志文件切割\">日志文件切割</span></h4>\n<pre><code>server1.log   ----&gt;  server1-2018-03-11.log  ---&gt; server1-2018-03-12.log\n              ----》 server1-2018-03-10.log \n\n通过mv命令 把当前log文件重命令\n再用信号控制指令 发送重读日志指令  产生了新的日志log文件\n\nnginx日志默认情况下统统写入到一个文件中，文件会变的越来越大，非常不方便查看分析。\n以日期来作为日志的切割是比较好的，通常我们是以每日来做统计的。下面来说说nginx日志切割。\n我们先手动完成日志文件切割\n到logs目录中，先备份日志文件，在重新生成日志文件\nmv access.log access_20180124.log\nkill -USR1 pid进程号   #向 Nginx 主进程发送 USR1 信号。USR1 信号是重新打开日志文件\n</code></pre>\n<h4><span id=\"系统自动切割\">系统自动切割</span></h4>\n<pre><code>利用sh脚本的方式执行刚才的手动操作，在每天凌晨执行一个计划任务 调用sh脚本，就完成的系统自动切割日志文件\n\n编写脚本\n在nginx目录下logs目录\n# touch cutlog.sh脚本\n# vi cutlog.sh \n#!/bin/bash\nLOGS_PATH=/usr/local/nginx/logs\nYESTERDAY=$(date -d &quot;yesterday&quot; +%Y-%m-%d)\nmv ${LOGS_PATH}/access.log ${LOGS_PATH}/access_${YESTERDAY}.log\nkill -USR1 $(cat /usr/local/nginx/logs/nginx.pid)   # 向 Nginx 主进程发送 USR1 信号。USR1 信号是重新打开日志文件\n\n注意：执行 sed -i 's/\\r$//' cutlog.sh\n原因：\n\n    这个文件在Windows 下编辑过，在Windows下每一行结尾是\\n\\r，而Linux下则是\\n\n\n    sed -i 's/\\r$//' cutlog.sh 会把cutlog.sh中的行尾的\\r替换为空白\n\n\n设置定时任务\n# vi  /etc/crontab\n0 0 * * * root /usr/local/nginx/logs/cutlog.sh  \n表示配置一个定时任务，定时每天00:00以root身份执行脚本/usr/local/nginx/logs/cutlog.sh，实现定时自动分割Nginx日志\n</code></pre>\n<h2><span id=\"nginx的location\">Nginx的Location</span></h2>\n<pre><code>nginx的location配置详解\n1）语法规则： location [=|~|~*|^~] /uri/ { … }\n构成：\n指令                  前缀                  uri\nlocation          [=|~|~*|^~]           /uri\n\n路由匹配规则，正则匹配，正则表达式\n\n\n\n2）location区分普通匹配和正则匹配\n\n用前缀 “~” 和 “~*”修饰的为正则匹配\n~   前缀表示区分大小写的正则匹配\n~*  前缀表示不区分大小写的正则匹配\n\n除上面修饰的前缀（“=” 和 “^~”，或没有前缀修饰）都为普通匹配\n=   前缀表示精确匹配\n^~  前缀表示uri以某个常规字符串开头，可以理解为url的普通匹配\n\nlocation作用于server模块,且支持多个location模块\nserver {\n       .........\n        location /p {\n            root   html/p;\n            index  index.html index.htm;\n        }\n        location = /50x.html {\n            root   html;\n        }\n        location / {\n            root   html/server1;\n            index  index.html index.htm;\n        }\n}\n在多个location情况下，是按照什么原则进行匹配的呢？\n\n3）匹配的原则\n普通匹配：优先原则----&gt;最大前缀匹配原则; 顺序无关\n如：\nserver {\n\tlocation /prefix/ {\n\t\t#规则A\n\t}\n\tlocation /prefix/mid/ {\n\t\t#规则B\n\t} \n}\n\n请求url为：/prefix/mid/t.html \n\n此请求匹配的是 规则B，是以最大的匹配原则进行的，跟顺序无关\n\n------------------------\n正则匹配：为顺序匹配，优先原则：谁在前面 就匹配谁；顺序相关\n如：\nserver {\n\tlocation ~ \\.(gif|jpg|png|js|css)$ {\n\t   \t\t#规则C\n\t}\n\tlocation ~* \\.png$ {\n\t   \t\t#规则D\n\t}\n}\n请求http://localhost/1.png,匹配的是规则C，因为规则C在前面，即叫做顺序匹配\n\n----------------\n如果location有普通匹配也有正则匹配，那匹配的原则为\n匹配模式及顺序\n----带前缀普通匹配 最优先，=前缀优先级最高\nlocation = /uri 　　　=开头表示精确匹配，只有完全匹配上才能生效。\nlocation ^~ /uri 　　^~ 开头对URL路径进行前缀匹配，并且在正则之前。\n----正则匹配\nlocation ~ pattern 　~开头表示区分大小写的正则匹配。\nlocation ~* pattern 　~*开头表示不区分大小写的正则匹配。\n---不带前缀匹配\nlocation /uri 　　　　不带任何修饰符，也表示前缀匹配，但是在正则匹配之后。\n\nlocation / 　　　　　通用匹配，任何未匹配到其它location的请求都会匹配到，相当于switch中default。 \n\n首先匹配 =，其次匹配^~, 其次是按文件中顺序的正则匹配，不带前缀普通匹配，最后是交给 / 通用匹配。\n当有匹配成功时候，停止匹配，按当前匹配规则处理请求。\n\n例子，有如下匹配规则：\nlocation = / {\n            return 200 '规则A';\n        }\nlocation = /login {\n            return 200 '规则B';\n        }\nlocation ^~ /static/ {\n            return 200 '规则C';\n        }\nlocation ~ \\.(gif|jpg|png|js|css)$ {\n            return 200 '规则D';\n        }\nlocation ~* \\.js$ {\n            return 200 '规则E';\n        }\t\nlocation / {\n            return 200 '规则F';\n}\n那么产生的效果如下：\n访问根目录/， 比如http://localhost/ 将匹配规则A\n访问 http://localhost/login 将匹配规则B，\nhttp://localhost/register 则匹配规则F\nhttp://localhost/static/a.html 将匹配规则C\nhttp://localhost/a.css, 匹配规则D\nhttp://localhost/b.js则优先匹配到 规则D，不会匹配到规则E\nhttp://localhost/static/c.js 则优先匹配到 规则C\nhttp://localhost/a.JS 则匹配规则E， 而不会匹配规则D，因为规则E不区分大小写。\n访问 http://localhost/category/id/1111 则最终匹配到规则F，因为以上规则都不匹配，\n\n\n4）在实际场景中，通常至少有三个匹配规则定义，如下：\n#直接匹配网站根，通过域名访问网站首页比较频繁，使用这个会加速处理。\n#这里是直接转发给后端应用服务器了，也可以是一个静态首页\n# 第一个必选规则\nlocation = / {\n    .....\n}\n# 第二个必选规则是处理静态文件请求，这是nginx作为http服务器的强项\n# 有两种配置模式，目录匹配或后缀匹配,任选其一或搭配使用\nlocation ^~ /static {\n    root /webroot/static/;\n}\nlocation ~* \\.(gif|jpg|jpeg|png|css|js|ico)$ {\n    root /webroot/res/;\n}\n#第三个规则就是通用规则，用来转发动态请求到后端应用服务器\n#非静态文件请求就默认是动态请求，自己根据实际把握\n#毕竟目前的一些框架的流行，带.php,.jsp后缀的情况很少了\nlocation / {\n    .....\n}\n</code></pre>\n<h2><span id=\"nginx负载均衡\">Nginx负载均衡</span></h2>\n<pre><code>当一台服务器单位时间内访问量很大的时候，服务器压力就会很大，当达到这台服务器的极限，就会崩溃；怎么解决？\n可以通过nginx的反向代理设置，添加几台同样功能的服务器 分担压力。\n\nnginx实现负载均衡原理，用户访问首先访问到nginx服务器，然后nginx服务器再从应用服务器集群中选择压力比较小的服务器，然后将该访问请求引向该服务器。\n如应用服务器集群中某一台服务器崩溃，那么从待选择服务器列表中将该服务器删除，也就是说一个服务器崩溃了，那么nginx服务器不会把请求引向到该服务器。\n\nupstream mypro {\n    server 192.168.5.140:8080;\n    server 192.168.5.141:8080;\n    xxxxx\n    xxxx\n}\n\nserver {\n    listen 80;\n    server_name xxxx;\n    location / {\n        proxy_pass http://mypro;\n    } \n }\n</code></pre>\n<h3><span id=\"负载均衡方案\">负载均衡方案</span></h3>\n<h4><span id=\"随机轮询\">随机轮询</span></h4>\n<pre><code>upstream mypro {\n    server 192.168.5.140:8080;\n    server 192.168.5.141:8080;\n}\n</code></pre>\n<h4><span id=\"权重\">权重</span></h4>\n<pre><code>upstream mypro {\n    server 192.168.5.140:8080 weight=5;\n    server 192.168.5.141:8080 weight=10;\n}\n</code></pre>\n<h4><span id=\"ip_hash\">ip_hash</span></h4>\n<pre><code>upstream mypro {\n    ip_hash;\n    server 192.168.5.140:8080;\n    server 192.168.5.141:8080;\n}\n</code></pre>\n<h4><span id=\"使用方式\">使用方式</span></h4>\n<pre><code>server {\n    listen       80;\n    server_name  192.168.5.138;\n     location / {\n        proxy_pass http://mypro;\n    }\n}\n</code></pre>\n<h2><span id=\"nginx拓展模块安装\">Nginx拓展模块安装</span></h2>\n<pre><code>查看nginx安装的现有模块指令\n/usr/local/nginx/sbin/nginx -V （大写的V）\nnginx version: nginx/1.13.2\nbuilt by gcc 4.8.5 20150623 (Red Hat 4.8.5-16) (GCC) \nconfigure arguments:\n\n1、下载需要的echo模块\nhttps://github.com/openresty/echo-nginx-module/tags\n# wget https://github.com/openresty/echo-nginx-module/archive/v0.61.tar.gz\n# tar zxvf v0.61.tar.gz\n# mv echo-nginx-module-0.61 nginx-tools/\n\n2、重新编译nginx，安装echo-nginx模块\n进入nginx源文件，重新编译\n# ./configure --add-module=nginx安装目录下面/echo-nginx-module-0.61 #安装echo模块(文件夹名echo-nginx-module-0.61)\n# make #开始编译，但别安装 （make install会直接覆盖安装）\n\n3、平滑升级 nginx\n\n注意先备份一下之前老的，手动安装一下。\n# mv /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.old\n# cp -f objs/nginx /usr/local/nginx/sbin/nginx\n\n这里是平滑升级，如是全新安装请执行：make install\n# make upgrade \n# make clean （清除编译产生的文件，可以忽略）\n\n\n\nlocation /module {\n    echo 'hello world'; \n}\n--------------------\nlocation /module {\n            echo_exec /set;\n}\n        \nlocation /set {\n    set $foo 'hello world';     #自定义变量\n    echo &quot;$request_uri&quot;;      #显示nginx全局变量的内容\n    echo $foo;\n}\n\n\nlua模块：可以在nginx服务中执行lua脚本\n\n\nnginx全局变量\n$args ：                     #这个变量等于请求行中的参数，同$query_string\n$content_length ：    #请求头中的Content-length字段。\n$content_type ：       #请求头中的Content-Type字段。\n$document_root ：   #当前请求在root指令中指定的值。\n$host ：                     #请求主机头字段，否则为服务器名称。\n$http_user_agent ：  #客户端agent信息\n$http_cookie ：          #客户端cookie信息\n$limit_rate ：              #这个变量可以限制连接速率。\n$request_method ：   #客户端请求的动作，通常为GET或POST。\n$remote_addr ：         #客户端的IP地址。\n$remote_port ：          #客户端的端口。\n$remote_user ：         #已经经过Auth Basic Module验证的用户名。\n$request_filename ： #当前请求的文件路径，由root或alias指令与URI请求生成。\n$scheme ：                #HTTP方法（如http，https）。\n$server_protocol ：    #请求使用的协议，通常是HTTP/1.0或HTTP/1.1。\n$server_addr ：         #服务器地址，在完成一次系统调用后可以确定这个值。\n$server_name ：       #服务器名称。\n$server_port ：          #请求到达服务器的端口号。\n$request_uri ：          #包含请求参数的原始URI，不包含主机名，如：”/foo/bar.php?arg=baz”。\n$uri ：                        #不带请求参数的当前URI，$uri不包含主机名，如”/foo/bar.html”。\n$document_uri ：      #与$uri相同\n</code></pre>\n<h2><span id=\"nginx的lua模块\">Nginx的Lua模块</span></h2>\n<pre><code>Nginx的优势\n    Nginx设计为一个主进程多个工作进程的工作模式，每个进程是单线程来处理多个连接，而且每个工作进程采用了非阻塞I/O来处理多个连接，\n    从而减少了线程上下文切换，从而实现了公认的高性能、高并发;因此在生成环境中会通过把CPU绑定给Nginx工作进程从而提升其性能;另外因为单线程工作模式的特点，内存占用就非常少了。 \n    Nginx更改配置重启速度非常快，可以毫秒级，而且支持不停止Nginx进行升级Nginx版本、动态重载Nginx配置。  \n    Nginx模块也是非常多，功能也很强劲，不仅可以作为http负载均衡，Nginx发布1.9.0版本还支持TCP负载均衡，还可以很容易的实现内容缓存、web服务器、反向代理、访问控制等功能。\n    nginx模块：rewrite 经常用到的\n\n什么是ngx_lua\n    ngx_lua是Nginx的一个模块，将Lua嵌入到Nginx中，从而可以使用Lua来编写脚本，这样就可以使用Lua编写应用脚本，部署到Nginx中运行，即Nginx变成了一个Web容器;\n    这样开发人员就可以使用Lua语言开发高性能Web应用了。\n    \n    网站开发，也有一个重要的脚步语言，javascript，js文件；；；客户端脚步语言；；；（node.js服务器语言）\n    网站页面进行渲染的时候，可以通过javascript脚本语言 进行一些业务处理\n    &lt;script&gt;\n    function hello(){\n    \talert(&quot;hello&quot;);\n    }\n    &lt;/script&gt;\n    脚本文件，还需要一个javascript引擎---解析javascript脚本语言\n    全部的浏览器 都包含 javascript引擎\n    \n    \n    lua -- javascript  一样的脚本语言\n    lua脚本语言 应用  ----》游戏开发中\n    \n    \n    Lua是一种轻量级、可嵌入式的脚本语言，这样可以非常容易的嵌入到其他语言中使用。另外Lua提供了协程并发，\n    即以同步调用的方式进行异步执行，从而实现并发，比起回调机制的并发来说代码更容易编写和理解，排查问题也会容易。Lua还提供了闭包机制，\n    函数可以作为First Class Value 进行参数传递，另外其实现了标记清除垃圾收集。\n    \n    因为Lua的小巧轻量级，可以在Nginx中嵌入Lua VM，请求的时候创建一个VM，请求结束的时候回收VM。\n    \n    ngx_lua模块的原理：\n    ngx_lua将Lua嵌入Nginx，能够让Nginx运行Lua脚本，而且高并发、非堵塞的处理各种请求。Lua内建协程。这样就能够非常好的将异步回调转换成顺序调用的形式。ngx_lua在Lua中进行的IO操作都会托付给Nginx的事件模型。从而实现非堵塞调用。\n    开发人员能够採用串行的方式编敲代码，ngx_lua会自己主动的在进行堵塞的IO操作时中断。保存上下文；然后将IO操作托付给Nginx事件处理机制。在IO操作完毕后，ngx_lua会恢复上下文，程序继续运行，这些操作都是对用户程序透明的。\n    每一个NginxWorker进程持有一个Lua解释器或者LuaJIT实例，被这个Worker处理的全部请求共享这个实例。\n    \n    每一个请求的Context会被Lua轻量级的协程切割，从而保证各个请求是独立的。 ngx_lua採用“one-coroutine-per-request”的处理模型。对于每一个用户请求，ngx_lua会唤醒一个协程用于执行用户代码处理请求，当请求处理完毕这个协程会被销毁。\n    \n    每一个协程都有一个独立的全局环境（变量空间），继承于全局共享的、仅仅读的“comman data”。所以。被用户代码注入全局空间的不论什么变量都不会影响其它请求的处理。而且这些变量在请求处理完毕后会被释放，\n    这样就保证全部的用户代码都执行在一个“sandbox”（沙箱），这个沙箱与请求具有同样的生命周期。 得益于Lua协程的支持。ngx_lua在处理10000个并发请求时仅仅须要非常少的内存。依据測试，ngx_lua处理每一个请求仅仅须要2KB的内存，\n    假设使用LuaJIT则会更少。所以ngx_lua非常适合用于实现可扩展的、高并发的服务。\n    \n    ngx_lua 模块提供的指令和API\n    \n    三、ngx_lua安装\n    echo模块\n        ngx_lua安装能够通过下载模块源代码，编译Nginx。可是推荐採用openresty。Openresty就是一个打包程序，包括大量的第三方Nginx模块，比方HttpLuaModule，HttpRedis2Module，HttpEchoModule等。省去下载模块。而且安装很方便。        \n        OpenResty将Nginx核心、LuaJIT、许多有用的Lua库和Nginx第三方模块打包在一起;这样开发人员只需要安装OpenResty，不需要了解Nginx核心和写复杂的C/C++模块就可以，只需要使用Lua语言进行Web应用开发了。        \n    \n    OpenResty提供了一些常用的ngx_lua开发模块：如        \n        lua-resty-memcached       \n        lua-resty-mysql        \n        lua-resty-redis        \n        lua-resty-dns        \n        lua-resty-limit-traffic        \n        lua-resty-template       \n    nginx + lua 就可以开发出 一些系统。龙果学院中 有一门课程 就专门应用了这个技术  \n    这些模块涉及到如mysql数据库、redis、限流、模块渲染等常用功能组件;另外也有很多第三方的ngx_lua组件供我们使用，对于大部分应用场景来说现在生态环境中的组件已经足够多了;如果不满足需求也可以自己去写来完成自己的需求。\n    openresty.org/cn官网\n    \n    应用场景\n    应用的公司：奇虎360、京东、百度、魅族、知乎、优酷、新浪这些互联网公司都在使用。\n    业务场景： WAF、有做 CDN 调度、广告系统、消息推送系统，API server 网关\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1>Nginx</h1>\n<h2>Nginx命令</h2>\n<h3>Nginx的基本配置</h3>\n<pre><code>Nginx的主配置文件是：nginx.conf，nginx.conf主要组成如下：\n\n# 全局区   有一个工作子进程，一般设置为CPU数 * 核数\nworker_processes  1; \nevents {\n    # 一般是配置nginx进程与连接的特性\n    # 如1个word能同时允许多少连接，一个子进程最大允许连接1024个连接\n     worker_connections  1024;\n}\n # 配置HTTP服务器配置段\nhttp {\n    # 配置虚拟主机段\n    server {\n         # 定位，把特殊的路径或文件再次定位。\n         location  {\n                   \n         } \n    }\n     server {\n                   \n     } \n}\n</code></pre>\n<h3>nginx启动</h3>\n<pre><code>指令：nginx程序   -c   nginx配置文件\n# /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf\n</code></pre>\n<h3>nginx重启</h3>\n<pre><code>#cd /usr/local/nginx/sbin\n##重启\n# ./nginx -s reload   \n进入nginx可执行程序的目录\n# cd /usr/local/nginx/sbin/\n# ./nginx -s reload\nnginx: [error] invalid PID number &quot;&quot; in &quot;/usr/local/nginx/logs/nginx.pid&quot;\n重启是建立在nginx服务需要启动\n</code></pre>\n<h3>nginx停止</h3>\n<pre><code># ./nginx -s stop \n# ./nginx -s quit\n\nquit 是一个优雅的关闭方式，Nginx在退出前完成已经接受的连接请求\nstop 是快速关闭，不管有没有正在处理的请求。\n</code></pre>\n<h3>重新打开日志</h3>\n<pre><code># 用于日志切割   \n# ./nginx -s reopen   \n</code></pre>\n<h3>nginx检查配置文件</h3>\n<pre><code>检查配置文件是否正确\n第一种\n进入nginx可执行程序的目录\n# cd /usr/local/nginx/sbin/\n# ./nginx -t\n\n第二种\n# /usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.conf\n</code></pre>\n<h2>Nginx信号控制</h2>\n<pre><code>Nginx支持2种进程模型Single和Master-Worker\nSingle是单进程，一般不适用，\nMaster-Worker是主进程和工作进程模型运行，主进程对工作进程管理。\nNginx允许我们通过信号来控制主进程，用信号的方式可以达到不影响现有连接的目的。 \n</code></pre>\n<h3>信号类型</h3>\n<pre><code>INT，TERM\t\t快速关闭信号\nQUIT\t\t\t从容关闭信号\nHUP\t\t\t\t从容重启信号，一般用于修改配置文件后，重启\nUSR1\t\t\t重读日志，一般用于日志的切割\nUSR2\t\t\t平滑升级信号\nWINCH\t\t\t从容关闭旧进程\n\n具体语法:\nkill    -信号选项    nginx的主进程号\n例：\n# kill -INT 26661 \n# kill -HUP 4873\n</code></pre>\n<h4>Nginx的优雅停止</h4>\n<pre><code>1）nginx停止\n#  ps -ef | grep nginx 获得进程号\n\n第1种从容“优雅”停止\n# kill -QUIT master进程号\n# Nginx服务可以正常地处理完当前所有请求再停止服务\n# 步骤：首先会关闭监听端口，停止接收新的连接，然后把当前正在处理的连接全部处理完，最后再退出进程。\n\n第2种快速停止\n# kill -TERM master进程号\n# kill -INT master进程号\n# 快速停止服务时，worker进程与master进程在收到信号后会立刻跳出循环，退出进程。\n第3种强制停止\n# pkill -9 nginx\n# 系统强杀nginx进程\n\n2）重启nginx\n# kill -HUP master进程号\n</code></pre>\n<h4>Nginx平滑升级</h4>\n<pre><code>原理:把服务器从低版本升级为高版本，强行停止服务器，会影响正在运行的进程。\n     平滑升级不会停掉正在进行中的进程，这些进程会继续处理请求。但不会再接受新请求，这些老的进程在处理完请求之后 会停止。此平滑升级过程中，新开的进程会被处理。\n\n\n一）平滑升级\n    进入nginx可执行程序的目录\n         #  cd /usr/local/nginx/sbin/\n         # ./nginx -V  #查看nginx版本\n\n    1）下载高版本nginx http://nginx.org/download/nginx-1.13.1.tar.gz\n    执行指令\n    #  ./configure\n    # make    #不能执行 make install\n    # cd objs\n    此目录下 有高版本的nginx\n    备份低版本的nginx\n    cp nginx nginx.old\n    执行强制覆盖\n    cp -rfp objs/nginx /usr/local/nginx/sbin\n\n    测试一下新复制过来文件生效情况：\n    # /usr/local/nginx/sbin/nginx -t\n    # ps -ef | grep nginx\n\n    2）执行信号平滑升级\n        # kill -USR2 `cat /usr/local/nginx/logs/nginx.pid`  更新配置文件\n        给nginx发送USR2信号后，nginx会将logs/nginx.pid文件重命名为nginx.pid.oldbin，然后用新的可执行文件启动一个新的nginx主进程和对应的工作进程，并新建一个新的nginx.pid保存新的主进程号\n        \n        # ps -ef | grep nginx\n        \n        # ll logs/\n    \n    \n    3）kill -WINCH 旧的主进程号\n        旧的主进程号收到WINCH信号后，将旧进程号管理的旧的工作进程优雅的关闭。即一段时间后旧的工作进程全部关闭，只有新的工作进程在处理请求连接。\n        这时，依然可以恢复到旧的进程服务，因为旧的进程的监听socket还未停止。\n        处理完后，工作进程会自动关闭\n        # ps -ef | grep nginx\n    \n    4）# kill -QUIT `cat /usr/local/nginx/logs/nginx.pid.oldbin` 优雅的关闭\n        给旧的主进程发送QUIT信号后，旧的主进程退出，并移除logs/nginx.pid.oldbin文件，nginx的升级完成。\n    \n    升级完成了，最后在看一下升级后的版本\n\n    查看\n    ./nginx -V\n    已经平滑升级成功\n\n二）中途停止升级，回滚到旧的nginx\n    在步骤(3)时，如果想回到旧的nginx不再升级\n    \n    (1)给旧的主进程号发送HUP命令，此时nginx不重新读取配置文件的情况下重新启动旧主进程的工作进程。\n        kill -HUP 9944 --旧主进程号\n        重启工作进程\n    (2)优雅的关闭新的主进程\n        kill -QUIT 10012  --新主进程号\n</code></pre>\n<h4>Nginx 用户</h4>\n<pre><code>#以哪个用户，运行nginx应用\n#nobody是个低权限用户，为了安全\n#user nobody;\n</code></pre>\n<h4>Nginx 进程数设置</h4>\n<pre><code>worker_processes：表示开启nginx的worker进程的个数，nginx启动会开两种进程，master进程用来管理调度，worker进程用来处理请求；\n上面表示两种设置方法，比如\n方法一：worker_processes auto;\n　　表示设置服务器cpu核数匹配开启nginx开启的worker进程数    \n　　查看cpu核数：cat /proc/cpuinfo    \n方法二：nginx设置cpu亲和力\n　　worker_processes 8;    \n　　worker_cpu_affinity 00000001 00000010 00000100 00001000 00010000 00100000 01000000 10000000;    \n　　00000001表示启用第一个CPU内核，00000010表示启用第二个CPU内核，以此类推\n\nworker_cpu_affinity：表示开启八个进程，第一个进程对应着第一个CPU内核，第二个进程对应着第二个CPU内核，以此类推。\n    这种设置方法更高效，因将每个cpu核提供给固定的worker进程服务，减少cpu上下文切换带来的资源浪费\n\n如果服务器cpu有限\n    比如：2核CPU，开启2个进程，设置如下 \n    worker_processes     2;   \n    worker_cpu_affinity 01 10;  \n    比如：4核CPU,开启4个进程，设置如下\n    worker_processes     4;\n    worker_cpu_affinity 0001 0010 0100 1000;\n\n8核cpu , worker_processes=8\n1个worker进程 能够最大打开的文件数（线程数）worker_connections=65535 （参考worker_rlimit_nofile  ----&gt;  linux  ulimit -n）\n最大的客户端连接数 max_clients = （多少个工作进程数）worker_processes * （1个工作线程的处理线程数）worker_connections    8*65535\n</code></pre>\n<h4>Nginx的并发量计算</h4>\n<pre><code>#nginx作为http服务器\n#请求模型   client &lt;---&gt; nginx\n#max_clients = worker_processes * worker_connections/2\n\n#nginx作为反向代理服务器的时候\n#请求模型   client &lt;---&gt; nginx  &lt;----&gt; web server\n#max_clients = worker_processes * worker_connections/4\n(\n为什么除以2：该公式基于http 1.1协议，一次请求大多数浏览器发送两次连接，并不是request和response响应占用两个线程（很多人也是这么认为，实际情况：请求是双向的，连接是没有方向的，由上面的图可以看出来)\n为什么除以4：因nginx作为方向代理，客户端和nginx建立连接，nginx和后端服务器也要建立连接\n)\n\n由此，我们可以计算nginx作为http服务器最大并发量(作为反向代理服务器自己类推)，可以为压测和线上环境的优化提供一些理论依据：\n单位时间（keepalive_timeout）内nginx最大并发量C\nC=worker_processes * worker_connections/2=8*65535/2\n\n而每秒的并发量CS\nCS=worker_processes * worker_connections/(2*65)    \n</code></pre>\n<h4>Nginx全局错误日志</h4>\n<pre><code>#全局错误日志 \n    #nginx的error_log类型如下（从左到右：debug最详细 crit最少）： \n    #[ debug | info | notice | warn | error | crit ] \n\n#例如：error_log logs/nginx_error.log  crit; \n#解释：日志文件存储在nginx安装目录下的 logs/nginx_error.log ，错误类型为 crit ，也就是记录最少错误信息;\n    error_log  logs/error.log;\n    error_log  logs/notice.log  notice;\n    error_log  logs/info.log  info;\n</code></pre>\n<h4>Nginx主进程ID</h4>\n<pre><code>#PID文件，记录当前启动的nginx的进程ID\n    pid        logs/nginx.pid; # 主进程ID存放位置\n</code></pre>\n<h4>Nginx的worker进程</h4>\n<pre><code>worker_rlimit_nofile 65535;\n\n#这个参数表示worker进程最多能打开的文件句柄数，基于liunx系统ulimit设置\n#查看系统文件句柄数最大值：ulimit -n\n#Linux一切皆文件，所有请求过来最终目的访问文件，所以该参数值设置等同于liunx系统ulimit设置为优\n#可以通过linux命令设置  最大的文件句柄数65535\n</code></pre>\n<h4>Nginx工作模式与连接数上限</h4>\n<pre><code>events {\n   #网络模型高效(相当于建立索引查找结果)，nginx配置应该启用该参数\n   #但是仅用于linux2.6以上内核,可以大大提高nginx的性能\n   use   epoll;             \n   #该参数表示设置一个worker进程最多开启多少线程数\n   #优化设置应该等同于worker_rlimit_nofile设置值，表明一个线程处理一个http请求，同时可以处理一个文件数，各个模块之间协调合作不等待。\n   worker_connections  65535;\n}\n</code></pre>\n<h4>Nginx负载均衡</h4>\n<pre><code> #设定http服务器，利用它的反向代理功能提供负载均衡支持\n     http {\n          #设定mime类型,类型由mime.type文件定义\n          #MIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来#打开的方式类型，\n          当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开\n         include       /etc/nginx/mime.types;\n         default_type  application/octet-stream;\n         #设定日志格式\n        log_format  main  '[$remote_addr] - [$remote_user] [$time_local] &quot;$request&quot; '\n                       '$status $body_bytes_sent &quot;$http_referer&quot; '\n                       '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;';\n         access_log    /var/log/nginx/access.log;\n \n         #sendfile 开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，\n         如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。\n         sendfile        on;\n         tcp_nopush     on; #防止网络阻塞\n         tcp_nodelay        on; #防止网络阻塞\n \n         #连接超时时间\n         #keepalive_timeout  0;  \n         keepalive_timeout  65; #长连接超时时间，单位是秒\n        \n \n         #开启gzip压缩\n        gzip  on;\n \t\tgzip_disable &quot;MSIE [1-6]\\.&quot;; # IE6及以下禁止压缩 \n        gzip_min_length 1k; #最小压缩文件大小\n \t\tgzip_buffers 4 16k; #压缩缓冲区\n \t\tgzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0）\n \t\tgzip_comp_level 2; #压缩等级\n \t\tgzip_types text/plain application/x-javascript text/css application/xml; #压缩类型\n \t\tgzip_vary on; #给CDN和代理服务器使用，针对相同url，可以根据头信息返回压缩和非压缩副本\n \n \n         #设定请求缓冲\n         client_header_buffer_size    1k;   #上传文件大小限制\n         large_client_header_buffers  4 4k;  #设定请求缓存\n \n \n         #设定负载均衡的服务器列表\n         upstream mysvr {\n \t        #weigth参数表示权值，权值越高被分配到的几率越大\n \t        server 192.168.8.1x:3128 weight=5;\n \t        server 192.168.8.2x:80  weight=1;\n \t        server 192.168.8.3x:80  weight=6;\n         }\n \n         upstream mysvr2 {\n \t        #weigth参数表示权值，权值越高被分配到的几率越大\n \t        server 192.168.8.x:80  weight=1;\n \t        server 192.168.8.x:80  weight=6;\n         }\n \n         #虚拟主机的配置\n        server {\n             #侦听80端口\n             listen       80;\n             #设置编码\n  \t          #charset koi8-r;\n \n             #定义使用www.xx.com访问 域名可以有多个，用空格隔开\n             server_name  www.xx.com;\n \n             #设定本虚拟主机的访问日志\n             access_log  logs/www.xx.com.access.log  main;\n \n         #默认请求\n         location / {\n               root   /root;      #定义服务器的默认网站根目录位置\n               index index.php index.html index.htm;   #定义首页索引文件的名称\n \n \n              proxy_pass  http://mysvr ;#请求转向mysvr 定义的服务器列表\n \n               client_max_body_size 10m;    #允许客户端请求的最大单文件字节数\n               client_body_buffer_size 128k;  #缓冲区代理缓冲用户端请求的最大字节数，\t\n \n              #以下是一些反向代理的配置可删除.\n \n               proxy_redirect off;\n \n               #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP\n               proxy_set_header Host $host;\n               proxy_set_header X-Real-IP $remote_addr;\n               proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n               proxy_connect_timeout 90;  #nginx跟后端服务器连接超时时间(代理连接超时)\n               proxy_send_timeout 90;        #后端服务器数据回传时间(代理发送超时)\n               proxy_read_timeout 90;         #连接成功后，后端服务器响应时间(代理接收超时)\n               proxy_buffer_size 4k;             #设置代理服务器（nginx）保存用户头信息的缓冲区大小\n               proxy_buffers 4 32k;               #proxy_buffers缓冲区，网页平均在32k以下的话，这样设置\n               proxy_busy_buffers_size 64k;    #高负荷下缓冲大小（proxy_buffers*2）\n               proxy_temp_file_write_size 64k;  #设定缓存文件夹大小，大于这个值，将从upstream服务器传\n \n         }\n \n         # 定义错误提示页面\n         error_page   500 502 503 504 /50x.html; \n             location = /50x.html {\n             root   /root;\n         }\n \n         #本地动静分离反向代理配置\n \t\t#所有jsp的页面均交由tomcat或resin处理\n \t\tlocation ~ .(jsp|jspx|do)?$ {\n \t\t\tproxy_set_header Host $host;\n \t\t\tproxy_set_header X-Real-IP $remote_addr;\n \t\t\tproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n \t\t\tproxy_pass http://127.0.0.1:8080;\n \t\t}\n \n         #静态文件，nginx自己处理\n         location ~ ^/(images|javascript|js|css|flash|media|static)/ {\n             root /var/www/virtual/htdocs;\n             #过期30天，静态文件不怎么更新，过期可以设大一点，如果频繁更新，则可以设置得小一点。\n             expires 30d;\n         }\n \n         #设定查看Nginx状态的地址\n         location /NginxStatus {\n             stub_status            on;\n             access_log              on;\n             auth_basic              &quot;NginxStatus&quot;;\n             auth_basic_user_file  conf/htpasswd;\n             #htpasswd文件的内容可以用apache提供的htpasswd工具来产生。\n         }\n         #禁止访问 .htxxx 文件\n         location ~ /\\.ht {\n             deny all;\n         }\n \n         }\n     }\n</code></pre>\n<h4>Nginx虚拟主机</h4>\n<pre><code>1）虚拟主机\n虚拟主机使用的是特殊的软硬件技术，它把一台运行在因特网上的服务器主机分成一台台“虚拟”的主机，每台虚拟主机都可以是一个独立的网站，可以具有独立的域名，\n具有完整的Intemet服务器功能（WWW、FTP、Email等），同一台主机上的虚拟主机之间是完全独立的。从网站访问者来看，每一台虚拟主机和一台独立的主机完全一样。\n利用虚拟主机，不用为每个要运行的网站提供一台单独的Nginx服务器或单独运行一组Nginx进程。虚拟主机提供了在同一台服务器、同一组Nginx进程上运行多个网站的功能。\n\n2）配置虚拟主机\n我们先配置在一个nginx中配置一个虚拟主机，编辑nginx.conf配置文件，在http模块中，配置server模块，一个server模块就针对一个虚拟主机。\n我们模拟一个独立的网站，此网站域名访问为www.server1.com；网站的根目录放到nginx目录下html/server1目录，我们创建一个首页index.html到server1中，编辑index.html\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;server1 首页&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;server1 首页&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n下面我们回到nginx.conf配置文件中，配置server模块\nserver {\nlisten 80; #监听80端口\nserver_name www.server1.com; #虚拟主机名，可以为域名或ip地址\nlocation / { #默认请求路由，以后文章中会重点介绍\nroot html/server1; #网站的根目录\nindex index.html index.htm; #默认首页文件名\n}\n}\n配置完成之后，重启nginx。因为www.server1.com是模拟的，需要在访问的客户端配置一下域名映射，老顾访问的客户端用的是windows系统，\n所以要到C:\\Windows\\System32\\drivers\\etc\\目录下，编辑hosts文件，增加个映射\n192.168.5.150 www.server1.com\n192.168.5.150是老顾的nginx服务器地址，注意编辑hosts要用管理员身份编辑，要不然会报无权限修改错误。\n打开浏览器，访问www.server1.com\n\n\n3）第一个虚拟主机配置完成，我们再配置一个server2，与server1配置类似，先给server2网站创建一个根目录，nginx目录下html/server2目录，编辑index.html\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;server2&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;server2 首页&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n再编辑nginx.conf，再增加个server模块，监听还是80端口，但服务名改为www.server2.com\nserver {\nlisten 80; #监听80端口\nserver_name www.server2.com; #虚拟主机名，可以为域名或ip地址\nlocation / { #默认请求路由，以后文章中会重点介绍\n    root html/server2; #网站的根目录\n    index index.html index.htm; #默认首页文件名\n}\n}\n重启nginx，不要忘了把hosts再增加个域名映射\n192.168.5.150 www.server2.com\n打开浏览器访问www.server2.com,运行结果\n\n\n这样第二个虚拟主机也配置完成。说明一下 再配置server模块是，监听的端口 listen 和 server_name 组合起来是唯一的，\n如果server_name一样，那么listen监听的端口就不一样；如端口一样，server_name就不一样。这是很好理解的，虚拟主机的请求映射系统才能够判别。\n</code></pre>\n<h2>Nginx日志与日志切割</h2>\n<h3>日志文件的格式配置</h3>\n<pre><code>nginx服务器在运行的时候，会有各种操作，操作的信息会记录到日志文件中，日志文件的记录是有格式的。那我们如何设置日志文件的格式呢？\n使用log_format指令进行配置文件格式\nnginx的log_format有很多可选的参数用于指示服务器的活动状态，默认的是：\nlog_format  main  '$remote_addr - $remote_user [$time_local] &quot;$request&quot; '    '$status $body_bytes_sent &quot;$http_referer&quot; '    '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;';\n\n192.168.31.247 - - [11/Mar/2018:16:26:43 +0800] &quot;GET / HTTP/1.1&quot; 304 0 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) \nAppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3350.0 Safari/537.36&quot; &quot;-&quot;\n</code></pre>\n<h4>日志相关参数</h4>\n<pre><code>参数                      说明                                         示例\n$remote_addr             客户端地址                                    211.28.65.253\n$remote_user             客户端用户名称                                --\n$time_local              访问时间和时区                                18/Jul/2012:17:00:01 +0800\n$request                 请求的URI和HTTP协议                           &quot;GET /article-10000.html HTTP/1.1&quot;\n$http_host               请求地址，即浏览器中你输入的地址（IP或域名）     www.wang.com 192.168.100.100\n$status                  HTTP请求状态                                  200\n$upstream_status         upstream状态                                  200\n$body_bytes_sent         发送给客户端文件内容大小                        1547\n$http_referer            url跳转来源                                   https://www.baidu.com/\n$http_user_agent         用户终端浏览器等信息                           &quot;Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; SV1; GTB7.0; .NET4.0C;\n$ssl_protocol            SSL协议版本                                   TLSv1\n$ssl_cipher              交换数据中的算法                               RC4-SHA\n$upstream_addr           后台upstream的地址，即真正提供服务的主机地址     10.10.10.100:80\n$request_time            整个请求的总时间                               0.205\n$upstream_response_time  请求过程中，upstream响应时间                    0.002\n$http_x_forwarded_for    是反向代理服务器转发客户端地址的参数\n\n假设将Nginx服务器作为Web服务器，位于负载均衡设备、Squid、Nginx反向代理之后，不能获取到客户端的真实IP地址了。\n原因是经过反向代理后，由于在客户端和Web服务器之间增加了中间层，因此Web服务器无法直接拿到客户端的IP。\n通过$remote_addr变量拿到的将是反向代理服务器的IP地址。\n但是，反向代理服务器在转发请求的HTTP头信息中，可以增加X-Forwarded-For信息，用以记录原有的客户端IP地址和原来客户端请求的服务器地址。\n这时候，要用log_format指令设置日志格式，让日志记录X-Forearded-For信息中的IP地址，即客户的真实IP。\n日志文件路径配置\n</code></pre>\n<h4>access_log指令</h4>\n<pre><code>语法: access_log path [format [buffer=size [flush=time]]];\naccess_log path format gzip[=level] [buffer=size] [flush=time];\naccess_log off;\n默认值: access_log logs/access.log combined;\n配置段: \ngzip压缩等级。\nbuffer设置内存缓存区大小。\nflush保存在缓存区中的最长时间。\n不记录日志：access_log off;\n使用默认combined格式记录日志：access_log logs/access.log 或 access_log logs/access.log combined;\n值得注意的是，Nginx进程设置的用户和组必须对日志路径有创建文件的权限，否则，会报错。\n此外，对于每一条日志记录，都将是先打开文件，再写入日志，然后关闭。可以使用open_log_file_cache来设置日志文件缓存(默认是off)。\n</code></pre>\n<h4>日志文件切割</h4>\n<pre><code>server1.log   ----&gt;  server1-2018-03-11.log  ---&gt; server1-2018-03-12.log\n              ----》 server1-2018-03-10.log \n\n通过mv命令 把当前log文件重命令\n再用信号控制指令 发送重读日志指令  产生了新的日志log文件\n\nnginx日志默认情况下统统写入到一个文件中，文件会变的越来越大，非常不方便查看分析。\n以日期来作为日志的切割是比较好的，通常我们是以每日来做统计的。下面来说说nginx日志切割。\n我们先手动完成日志文件切割\n到logs目录中，先备份日志文件，在重新生成日志文件\nmv access.log access_20180124.log\nkill -USR1 pid进程号   #向 Nginx 主进程发送 USR1 信号。USR1 信号是重新打开日志文件\n</code></pre>\n<h4>系统自动切割</h4>\n<pre><code>利用sh脚本的方式执行刚才的手动操作，在每天凌晨执行一个计划任务 调用sh脚本，就完成的系统自动切割日志文件\n\n编写脚本\n在nginx目录下logs目录\n# touch cutlog.sh脚本\n# vi cutlog.sh \n#!/bin/bash\nLOGS_PATH=/usr/local/nginx/logs\nYESTERDAY=$(date -d &quot;yesterday&quot; +%Y-%m-%d)\nmv ${LOGS_PATH}/access.log ${LOGS_PATH}/access_${YESTERDAY}.log\nkill -USR1 $(cat /usr/local/nginx/logs/nginx.pid)   # 向 Nginx 主进程发送 USR1 信号。USR1 信号是重新打开日志文件\n\n注意：执行 sed -i 's/\\r$//' cutlog.sh\n原因：\n\n    这个文件在Windows 下编辑过，在Windows下每一行结尾是\\n\\r，而Linux下则是\\n\n\n    sed -i 's/\\r$//' cutlog.sh 会把cutlog.sh中的行尾的\\r替换为空白\n\n\n设置定时任务\n# vi  /etc/crontab\n0 0 * * * root /usr/local/nginx/logs/cutlog.sh  \n表示配置一个定时任务，定时每天00:00以root身份执行脚本/usr/local/nginx/logs/cutlog.sh，实现定时自动分割Nginx日志\n</code></pre>\n<h2>Nginx的Location</h2>\n<pre><code>nginx的location配置详解\n1）语法规则： location [=|~|~*|^~] /uri/ { … }\n构成：\n指令                  前缀                  uri\nlocation          [=|~|~*|^~]           /uri\n\n路由匹配规则，正则匹配，正则表达式\n\n\n\n2）location区分普通匹配和正则匹配\n\n用前缀 “~” 和 “~*”修饰的为正则匹配\n~   前缀表示区分大小写的正则匹配\n~*  前缀表示不区分大小写的正则匹配\n\n除上面修饰的前缀（“=” 和 “^~”，或没有前缀修饰）都为普通匹配\n=   前缀表示精确匹配\n^~  前缀表示uri以某个常规字符串开头，可以理解为url的普通匹配\n\nlocation作用于server模块,且支持多个location模块\nserver {\n       .........\n        location /p {\n            root   html/p;\n            index  index.html index.htm;\n        }\n        location = /50x.html {\n            root   html;\n        }\n        location / {\n            root   html/server1;\n            index  index.html index.htm;\n        }\n}\n在多个location情况下，是按照什么原则进行匹配的呢？\n\n3）匹配的原则\n普通匹配：优先原则----&gt;最大前缀匹配原则; 顺序无关\n如：\nserver {\n\tlocation /prefix/ {\n\t\t#规则A\n\t}\n\tlocation /prefix/mid/ {\n\t\t#规则B\n\t} \n}\n\n请求url为：/prefix/mid/t.html \n\n此请求匹配的是 规则B，是以最大的匹配原则进行的，跟顺序无关\n\n------------------------\n正则匹配：为顺序匹配，优先原则：谁在前面 就匹配谁；顺序相关\n如：\nserver {\n\tlocation ~ \\.(gif|jpg|png|js|css)$ {\n\t   \t\t#规则C\n\t}\n\tlocation ~* \\.png$ {\n\t   \t\t#规则D\n\t}\n}\n请求http://localhost/1.png,匹配的是规则C，因为规则C在前面，即叫做顺序匹配\n\n----------------\n如果location有普通匹配也有正则匹配，那匹配的原则为\n匹配模式及顺序\n----带前缀普通匹配 最优先，=前缀优先级最高\nlocation = /uri 　　　=开头表示精确匹配，只有完全匹配上才能生效。\nlocation ^~ /uri 　　^~ 开头对URL路径进行前缀匹配，并且在正则之前。\n----正则匹配\nlocation ~ pattern 　~开头表示区分大小写的正则匹配。\nlocation ~* pattern 　~*开头表示不区分大小写的正则匹配。\n---不带前缀匹配\nlocation /uri 　　　　不带任何修饰符，也表示前缀匹配，但是在正则匹配之后。\n\nlocation / 　　　　　通用匹配，任何未匹配到其它location的请求都会匹配到，相当于switch中default。 \n\n首先匹配 =，其次匹配^~, 其次是按文件中顺序的正则匹配，不带前缀普通匹配，最后是交给 / 通用匹配。\n当有匹配成功时候，停止匹配，按当前匹配规则处理请求。\n\n例子，有如下匹配规则：\nlocation = / {\n            return 200 '规则A';\n        }\nlocation = /login {\n            return 200 '规则B';\n        }\nlocation ^~ /static/ {\n            return 200 '规则C';\n        }\nlocation ~ \\.(gif|jpg|png|js|css)$ {\n            return 200 '规则D';\n        }\nlocation ~* \\.js$ {\n            return 200 '规则E';\n        }\t\nlocation / {\n            return 200 '规则F';\n}\n那么产生的效果如下：\n访问根目录/， 比如http://localhost/ 将匹配规则A\n访问 http://localhost/login 将匹配规则B，\nhttp://localhost/register 则匹配规则F\nhttp://localhost/static/a.html 将匹配规则C\nhttp://localhost/a.css, 匹配规则D\nhttp://localhost/b.js则优先匹配到 规则D，不会匹配到规则E\nhttp://localhost/static/c.js 则优先匹配到 规则C\nhttp://localhost/a.JS 则匹配规则E， 而不会匹配规则D，因为规则E不区分大小写。\n访问 http://localhost/category/id/1111 则最终匹配到规则F，因为以上规则都不匹配，\n\n\n4）在实际场景中，通常至少有三个匹配规则定义，如下：\n#直接匹配网站根，通过域名访问网站首页比较频繁，使用这个会加速处理。\n#这里是直接转发给后端应用服务器了，也可以是一个静态首页\n# 第一个必选规则\nlocation = / {\n    .....\n}\n# 第二个必选规则是处理静态文件请求，这是nginx作为http服务器的强项\n# 有两种配置模式，目录匹配或后缀匹配,任选其一或搭配使用\nlocation ^~ /static {\n    root /webroot/static/;\n}\nlocation ~* \\.(gif|jpg|jpeg|png|css|js|ico)$ {\n    root /webroot/res/;\n}\n#第三个规则就是通用规则，用来转发动态请求到后端应用服务器\n#非静态文件请求就默认是动态请求，自己根据实际把握\n#毕竟目前的一些框架的流行，带.php,.jsp后缀的情况很少了\nlocation / {\n    .....\n}\n</code></pre>\n<h2>Nginx负载均衡</h2>\n<pre><code>当一台服务器单位时间内访问量很大的时候，服务器压力就会很大，当达到这台服务器的极限，就会崩溃；怎么解决？\n可以通过nginx的反向代理设置，添加几台同样功能的服务器 分担压力。\n\nnginx实现负载均衡原理，用户访问首先访问到nginx服务器，然后nginx服务器再从应用服务器集群中选择压力比较小的服务器，然后将该访问请求引向该服务器。\n如应用服务器集群中某一台服务器崩溃，那么从待选择服务器列表中将该服务器删除，也就是说一个服务器崩溃了，那么nginx服务器不会把请求引向到该服务器。\n\nupstream mypro {\n    server 192.168.5.140:8080;\n    server 192.168.5.141:8080;\n    xxxxx\n    xxxx\n}\n\nserver {\n    listen 80;\n    server_name xxxx;\n    location / {\n        proxy_pass http://mypro;\n    } \n }\n</code></pre>\n<h3>负载均衡方案</h3>\n<h4>随机轮询</h4>\n<pre><code>upstream mypro {\n    server 192.168.5.140:8080;\n    server 192.168.5.141:8080;\n}\n</code></pre>\n<h4>权重</h4>\n<pre><code>upstream mypro {\n    server 192.168.5.140:8080 weight=5;\n    server 192.168.5.141:8080 weight=10;\n}\n</code></pre>\n<h4>ip_hash</h4>\n<pre><code>upstream mypro {\n    ip_hash;\n    server 192.168.5.140:8080;\n    server 192.168.5.141:8080;\n}\n</code></pre>\n<h4>使用方式</h4>\n<pre><code>server {\n    listen       80;\n    server_name  192.168.5.138;\n     location / {\n        proxy_pass http://mypro;\n    }\n}\n</code></pre>\n<h2>Nginx拓展模块安装</h2>\n<pre><code>查看nginx安装的现有模块指令\n/usr/local/nginx/sbin/nginx -V （大写的V）\nnginx version: nginx/1.13.2\nbuilt by gcc 4.8.5 20150623 (Red Hat 4.8.5-16) (GCC) \nconfigure arguments:\n\n1、下载需要的echo模块\nhttps://github.com/openresty/echo-nginx-module/tags\n# wget https://github.com/openresty/echo-nginx-module/archive/v0.61.tar.gz\n# tar zxvf v0.61.tar.gz\n# mv echo-nginx-module-0.61 nginx-tools/\n\n2、重新编译nginx，安装echo-nginx模块\n进入nginx源文件，重新编译\n# ./configure --add-module=nginx安装目录下面/echo-nginx-module-0.61 #安装echo模块(文件夹名echo-nginx-module-0.61)\n# make #开始编译，但别安装 （make install会直接覆盖安装）\n\n3、平滑升级 nginx\n\n注意先备份一下之前老的，手动安装一下。\n# mv /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.old\n# cp -f objs/nginx /usr/local/nginx/sbin/nginx\n\n这里是平滑升级，如是全新安装请执行：make install\n# make upgrade \n# make clean （清除编译产生的文件，可以忽略）\n\n\n\nlocation /module {\n    echo 'hello world'; \n}\n--------------------\nlocation /module {\n            echo_exec /set;\n}\n        \nlocation /set {\n    set $foo 'hello world';     #自定义变量\n    echo &quot;$request_uri&quot;;      #显示nginx全局变量的内容\n    echo $foo;\n}\n\n\nlua模块：可以在nginx服务中执行lua脚本\n\n\nnginx全局变量\n$args ：                     #这个变量等于请求行中的参数，同$query_string\n$content_length ：    #请求头中的Content-length字段。\n$content_type ：       #请求头中的Content-Type字段。\n$document_root ：   #当前请求在root指令中指定的值。\n$host ：                     #请求主机头字段，否则为服务器名称。\n$http_user_agent ：  #客户端agent信息\n$http_cookie ：          #客户端cookie信息\n$limit_rate ：              #这个变量可以限制连接速率。\n$request_method ：   #客户端请求的动作，通常为GET或POST。\n$remote_addr ：         #客户端的IP地址。\n$remote_port ：          #客户端的端口。\n$remote_user ：         #已经经过Auth Basic Module验证的用户名。\n$request_filename ： #当前请求的文件路径，由root或alias指令与URI请求生成。\n$scheme ：                #HTTP方法（如http，https）。\n$server_protocol ：    #请求使用的协议，通常是HTTP/1.0或HTTP/1.1。\n$server_addr ：         #服务器地址，在完成一次系统调用后可以确定这个值。\n$server_name ：       #服务器名称。\n$server_port ：          #请求到达服务器的端口号。\n$request_uri ：          #包含请求参数的原始URI，不包含主机名，如：”/foo/bar.php?arg=baz”。\n$uri ：                        #不带请求参数的当前URI，$uri不包含主机名，如”/foo/bar.html”。\n$document_uri ：      #与$uri相同\n</code></pre>\n<h2>Nginx的Lua模块</h2>\n<pre><code>Nginx的优势\n    Nginx设计为一个主进程多个工作进程的工作模式，每个进程是单线程来处理多个连接，而且每个工作进程采用了非阻塞I/O来处理多个连接，\n    从而减少了线程上下文切换，从而实现了公认的高性能、高并发;因此在生成环境中会通过把CPU绑定给Nginx工作进程从而提升其性能;另外因为单线程工作模式的特点，内存占用就非常少了。 \n    Nginx更改配置重启速度非常快，可以毫秒级，而且支持不停止Nginx进行升级Nginx版本、动态重载Nginx配置。  \n    Nginx模块也是非常多，功能也很强劲，不仅可以作为http负载均衡，Nginx发布1.9.0版本还支持TCP负载均衡，还可以很容易的实现内容缓存、web服务器、反向代理、访问控制等功能。\n    nginx模块：rewrite 经常用到的\n\n什么是ngx_lua\n    ngx_lua是Nginx的一个模块，将Lua嵌入到Nginx中，从而可以使用Lua来编写脚本，这样就可以使用Lua编写应用脚本，部署到Nginx中运行，即Nginx变成了一个Web容器;\n    这样开发人员就可以使用Lua语言开发高性能Web应用了。\n    \n    网站开发，也有一个重要的脚步语言，javascript，js文件；；；客户端脚步语言；；；（node.js服务器语言）\n    网站页面进行渲染的时候，可以通过javascript脚本语言 进行一些业务处理\n    &lt;script&gt;\n    function hello(){\n    \talert(&quot;hello&quot;);\n    }\n    &lt;/script&gt;\n    脚本文件，还需要一个javascript引擎---解析javascript脚本语言\n    全部的浏览器 都包含 javascript引擎\n    \n    \n    lua -- javascript  一样的脚本语言\n    lua脚本语言 应用  ----》游戏开发中\n    \n    \n    Lua是一种轻量级、可嵌入式的脚本语言，这样可以非常容易的嵌入到其他语言中使用。另外Lua提供了协程并发，\n    即以同步调用的方式进行异步执行，从而实现并发，比起回调机制的并发来说代码更容易编写和理解，排查问题也会容易。Lua还提供了闭包机制，\n    函数可以作为First Class Value 进行参数传递，另外其实现了标记清除垃圾收集。\n    \n    因为Lua的小巧轻量级，可以在Nginx中嵌入Lua VM，请求的时候创建一个VM，请求结束的时候回收VM。\n    \n    ngx_lua模块的原理：\n    ngx_lua将Lua嵌入Nginx，能够让Nginx运行Lua脚本，而且高并发、非堵塞的处理各种请求。Lua内建协程。这样就能够非常好的将异步回调转换成顺序调用的形式。ngx_lua在Lua中进行的IO操作都会托付给Nginx的事件模型。从而实现非堵塞调用。\n    开发人员能够採用串行的方式编敲代码，ngx_lua会自己主动的在进行堵塞的IO操作时中断。保存上下文；然后将IO操作托付给Nginx事件处理机制。在IO操作完毕后，ngx_lua会恢复上下文，程序继续运行，这些操作都是对用户程序透明的。\n    每一个NginxWorker进程持有一个Lua解释器或者LuaJIT实例，被这个Worker处理的全部请求共享这个实例。\n    \n    每一个请求的Context会被Lua轻量级的协程切割，从而保证各个请求是独立的。 ngx_lua採用“one-coroutine-per-request”的处理模型。对于每一个用户请求，ngx_lua会唤醒一个协程用于执行用户代码处理请求，当请求处理完毕这个协程会被销毁。\n    \n    每一个协程都有一个独立的全局环境（变量空间），继承于全局共享的、仅仅读的“comman data”。所以。被用户代码注入全局空间的不论什么变量都不会影响其它请求的处理。而且这些变量在请求处理完毕后会被释放，\n    这样就保证全部的用户代码都执行在一个“sandbox”（沙箱），这个沙箱与请求具有同样的生命周期。 得益于Lua协程的支持。ngx_lua在处理10000个并发请求时仅仅须要非常少的内存。依据測试，ngx_lua处理每一个请求仅仅须要2KB的内存，\n    假设使用LuaJIT则会更少。所以ngx_lua非常适合用于实现可扩展的、高并发的服务。\n    \n    ngx_lua 模块提供的指令和API\n    \n    三、ngx_lua安装\n    echo模块\n        ngx_lua安装能够通过下载模块源代码，编译Nginx。可是推荐採用openresty。Openresty就是一个打包程序，包括大量的第三方Nginx模块，比方HttpLuaModule，HttpRedis2Module，HttpEchoModule等。省去下载模块。而且安装很方便。        \n        OpenResty将Nginx核心、LuaJIT、许多有用的Lua库和Nginx第三方模块打包在一起;这样开发人员只需要安装OpenResty，不需要了解Nginx核心和写复杂的C/C++模块就可以，只需要使用Lua语言进行Web应用开发了。        \n    \n    OpenResty提供了一些常用的ngx_lua开发模块：如        \n        lua-resty-memcached       \n        lua-resty-mysql        \n        lua-resty-redis        \n        lua-resty-dns        \n        lua-resty-limit-traffic        \n        lua-resty-template       \n    nginx + lua 就可以开发出 一些系统。龙果学院中 有一门课程 就专门应用了这个技术  \n    这些模块涉及到如mysql数据库、redis、限流、模块渲染等常用功能组件;另外也有很多第三方的ngx_lua组件供我们使用，对于大部分应用场景来说现在生态环境中的组件已经足够多了;如果不满足需求也可以自己去写来完成自己的需求。\n    openresty.org/cn官网\n    \n    应用场景\n    应用的公司：奇虎360、京东、百度、魅族、知乎、优酷、新浪这些互联网公司都在使用。\n    业务场景： WAF、有做 CDN 调度、广告系统、消息推送系统，API server 网关\n</code></pre>\n"},{"title":"微服务API网关框架(4)--运算符,循环,迭代器与流程控制","catalog":true,"date":"2018-12-20T03:40:17.000Z","subtitle":null,"header-img":"Demo.png","catagories":["微服务API网关"],"_content":"\n## 运算符\n    Lua提供了以下几种运算符类型:\n        算术运算符\n        关系运算符\n        逻辑运算符\n        其他运算符 (..,#)\n    \n### 算术运算符\n    操作符         描述          实例\n    +              加法          A + B 输出结果 30\n    -              减法          A - B 输出结果 -10\n    *              乘法          A * B 输出结果 200\n    /              除法          B / A w输出结果 2\n    %              取余          B % A 输出结果 0\n    ^              乘幂          A^2 输出结果 100\n    -              负号          -A 输出结果v -10\n\n### 关系运算符\n    操作符          描述\t                                                                        实例\n    ==              等于，检测两个值是否相等，相等返回 true，否则返回 false\t                    (A == B) 为 false。\n    ~=              不等于，检测两个值是否相等，相等返回 false，否则返回 true\t                    (A ~= B) 为 true。\n    >               大于，如果左边的值大于右边的值，返回 true，否则返回 false\t                    (A > B) 为 false。\n    <               小于，如果左边的值大于右边的值，返回 false，否则返回 true\t                    (A < B) 为 true。\n    >=              大于等于，如果左边的值大于等于右边的值，返回 true，否则返回 false\t            (A >= B) 返回 false。\n    <=              小于等于， 如果左边的值小于等于右边的值，返回 true，否则返回 false\t        (A <= B) 返回 true。     \n\n### 逻辑运算符\n    操作符\t        描述                                                                 实例\n    and             逻辑与操作符。 若 A 为 false，则返回 A，否则返回 B。\t                 (A and B) 为 false。\n    or              逻辑或操作符。 若 A 为 true，则返回 A，否则返回 B。\t                 (A or B) 为 true。\n    not             逻辑非操作符。与逻辑运算结果相反，如果条件为 true，逻辑非为 false。    not(A and B) 为 true。\n\n### 运算符优先级\n    从高到低的顺序：\n        ^\n        not    - (unary)\n        *      /\n        +      -\n        ..\n        <      >      <=     >=     ~=     ==\n        and\n        or\n        \n## 循环\n    1. while 循环\t在条件为 true 时，让程序重复地执行某些语句。执行语句前会先检查条件是否为 true。\n        while(condition)\n        do\n           statements\n        end\n        var 从 exp1 变化到 exp2，每次变化以 exp3 为步长递增 var，并执行一次 \"执行体\"。exp3 是可选的，如果不指定，默认为1。\n        \n        例子:\n            for i=1,f(x) do\n                print(i)\n            end\n             \n            for i=10,1,-1 do\n                print(i)\n            end\n    2. for 循环\t重复执行指定语句，重复次数可在 for 语句中控制。\n        (1)数值for循环\n            for var=exp1,exp2,exp3 do  \n                <执行体>  \n            end  \n        (2)泛型for循环   \n            a = {\"one\", \"two\", \"three\"}\n            for i, v in ipairs(a) do\n                print(i, v)\n            end \n    3. repeat...until\t重复执行循环，直到 指定的条件为真时为止\n        repeat\n           statements\n        until( condition )\n        \n        例子：\n            --[ 变量定义 --]\n            a = 10\n            --[ 执行循环 --]\n            repeat\n               print(\"a的值为:\", a)\n               a = a + 1\n            until( a > 15 )  \n    4. 循环嵌套\t可以在循环内嵌套一个或多个循环语句（while do ... end;for ... do ... end;repeat ... until;）\n    5. 无限循环\n        while( true )\n        do\n           print(\"循环将永远执行下去\")\n        end\n    6. break 用于退出当前循环或语句\n        例子：\n            --[ 定义变量 --]\n            a = 10\n            --[ while 循环 --]\n            while( a < 20 )\n            do\n               print(\"a 的值为:\", a)\n               a=a+1\n               if( a > 15)\n               then\n                  --[ 使用 break 语句终止循环 --]\n                  break\n               end\n            end    \n            \n## 迭代器\n    1. 泛型 for 迭代器\n        泛型 for 在自己内部保存迭代函数，实际上它保存三个值：迭代函数、状态常量、控制变量。\n        泛型 for 迭代器提供了集合的 key/value 对，语法格式如下：\n        for k, v in pairs(t) do\n            print(k, v)\n        end\n        \n        array = {\"Lua\", \"Tutorial\"}\n        \n        for key,value in ipairs(array) \n        do\n           print(key, value)\n        end\n        \n    2. 无状态的迭代器\n        无状态的迭代器是指不保留任何状态的迭代器，因此在循环中我们可以利用无状态迭代器避免创建闭包花费额外的代价。\n        每一次迭代，迭代函数都是用两个变量（状态常量和控制变量）的值作为参数被调用，一个无状态的迭代器只利用这两个值可以获取下一个元素。\n        这种无状态迭代器的典型的简单的例子是ipairs，它遍历数组的每一个元素。\n        以下实例我们使用了一个简单的函数来实现迭代器，实现 数字 n 的平方：\n        function square(iteratorMaxCount,currentNumber)\n           if currentNumber<iteratorMaxCount\n           then\n              currentNumber = currentNumber+1\n           return currentNumber, currentNumber*currentNumber\n           end\n        end\n        \n        for i,n in square,3,0\n        do\n           print(i,n)\n        end   \n        \n        简单例子:\n            function iter (a, i)\n                i = i + 1\n                local v = a[i]\n                if v then\n                   return i, v\n                end\n            end\n             \n            function ipairs (a)\n                return iter, a, 0\n            end   \n     \n    3.多状态的迭代器\n         很多情况下，迭代器需要保存多个状态信息而不是简单的状态常量和控制变量，最简单的方法是使用闭包，还有一种方法就是将所有的状态信息封装到table内，将table作为迭代器的状态常量，因为这种情况下可以将所有的信息存放在table内，所以迭代函数通常不需要第二个参数。\n         array = {\"Lua\", \"Tutorial\"}\n         \n         function elementIterator (collection)\n            local index = 0\n            local count = #collection\n            -- 闭包函数\n            return function ()\n               index = index + 1\n               if index <= count\n               then\n                  --  返回迭代器的当前元素\n                  return collection[index]\n               end\n            end\n         end\n         \n         for element in elementIterator(array)\n         do\n            print(element)\n         end\n                      \n## 流程控制\n    1.if 语句\tif 语句 由一个布尔表达式作为条件判断，其后紧跟其他语句组成。\n        if(布尔表达式)\n        then\n           --[ 在布尔表达式为 true 时执行的语句 --]\n        end\n    2.if...else 语句\tif 语句 可以与 else 语句搭配使用, 在 if 条件表达式为 false 时执行 else 语句代码。\n        格式一：\n            if(布尔表达式)\n            then\n               --[ 布尔表达式为 true 时执行该语句块 --]\n            else\n               --[ 布尔表达式为 false 时执行该语句块 --]\n            end\n        \n        格式二：\n            if( 布尔表达式 1)\n            then\n               --[ 在布尔表达式 1 为 true 时执行该语句块 --]\n            \n            elseif( 布尔表达式 2)\n            then\n               --[ 在布尔表达式 2 为 true 时执行该语句块 --]\n            \n            elseif( 布尔表达式 3)\n            then\n               --[ 在布尔表达式 3 为 true 时执行该语句块 --]\n            else \n               --[ 如果以上布尔表达式都不为 true 则执行该语句块 --]\n            end\n    3.if 嵌套语句\t你可以在if 或 else if中使用一个或多个 if 或 else if 语句 。\n        if( 布尔表达式 1)\n        then\n           --[ 布尔表达式 1 为 true 时执行该语句块 --]\n           if(布尔表达式 2)\n           then\n              --[ 布尔表达式 2 为 true 时执行该语句块 --]\n           end\n        end\n","source":"_posts/微服务API网关框架-4.md","raw":"---\ntitle: 微服务API网关框架(4)--运算符,循环,迭代器与流程控制\ncatalog: true\ndate: 2018-12-20 11:40:17\nsubtitle:\nheader-img: \"Demo.png\"\ntags:\n- 微服务API网关\ncatagories:\n- 微服务API网关\n---\n\n## 运算符\n    Lua提供了以下几种运算符类型:\n        算术运算符\n        关系运算符\n        逻辑运算符\n        其他运算符 (..,#)\n    \n### 算术运算符\n    操作符         描述          实例\n    +              加法          A + B 输出结果 30\n    -              减法          A - B 输出结果 -10\n    *              乘法          A * B 输出结果 200\n    /              除法          B / A w输出结果 2\n    %              取余          B % A 输出结果 0\n    ^              乘幂          A^2 输出结果 100\n    -              负号          -A 输出结果v -10\n\n### 关系运算符\n    操作符          描述\t                                                                        实例\n    ==              等于，检测两个值是否相等，相等返回 true，否则返回 false\t                    (A == B) 为 false。\n    ~=              不等于，检测两个值是否相等，相等返回 false，否则返回 true\t                    (A ~= B) 为 true。\n    >               大于，如果左边的值大于右边的值，返回 true，否则返回 false\t                    (A > B) 为 false。\n    <               小于，如果左边的值大于右边的值，返回 false，否则返回 true\t                    (A < B) 为 true。\n    >=              大于等于，如果左边的值大于等于右边的值，返回 true，否则返回 false\t            (A >= B) 返回 false。\n    <=              小于等于， 如果左边的值小于等于右边的值，返回 true，否则返回 false\t        (A <= B) 返回 true。     \n\n### 逻辑运算符\n    操作符\t        描述                                                                 实例\n    and             逻辑与操作符。 若 A 为 false，则返回 A，否则返回 B。\t                 (A and B) 为 false。\n    or              逻辑或操作符。 若 A 为 true，则返回 A，否则返回 B。\t                 (A or B) 为 true。\n    not             逻辑非操作符。与逻辑运算结果相反，如果条件为 true，逻辑非为 false。    not(A and B) 为 true。\n\n### 运算符优先级\n    从高到低的顺序：\n        ^\n        not    - (unary)\n        *      /\n        +      -\n        ..\n        <      >      <=     >=     ~=     ==\n        and\n        or\n        \n## 循环\n    1. while 循环\t在条件为 true 时，让程序重复地执行某些语句。执行语句前会先检查条件是否为 true。\n        while(condition)\n        do\n           statements\n        end\n        var 从 exp1 变化到 exp2，每次变化以 exp3 为步长递增 var，并执行一次 \"执行体\"。exp3 是可选的，如果不指定，默认为1。\n        \n        例子:\n            for i=1,f(x) do\n                print(i)\n            end\n             \n            for i=10,1,-1 do\n                print(i)\n            end\n    2. for 循环\t重复执行指定语句，重复次数可在 for 语句中控制。\n        (1)数值for循环\n            for var=exp1,exp2,exp3 do  \n                <执行体>  \n            end  \n        (2)泛型for循环   \n            a = {\"one\", \"two\", \"three\"}\n            for i, v in ipairs(a) do\n                print(i, v)\n            end \n    3. repeat...until\t重复执行循环，直到 指定的条件为真时为止\n        repeat\n           statements\n        until( condition )\n        \n        例子：\n            --[ 变量定义 --]\n            a = 10\n            --[ 执行循环 --]\n            repeat\n               print(\"a的值为:\", a)\n               a = a + 1\n            until( a > 15 )  \n    4. 循环嵌套\t可以在循环内嵌套一个或多个循环语句（while do ... end;for ... do ... end;repeat ... until;）\n    5. 无限循环\n        while( true )\n        do\n           print(\"循环将永远执行下去\")\n        end\n    6. break 用于退出当前循环或语句\n        例子：\n            --[ 定义变量 --]\n            a = 10\n            --[ while 循环 --]\n            while( a < 20 )\n            do\n               print(\"a 的值为:\", a)\n               a=a+1\n               if( a > 15)\n               then\n                  --[ 使用 break 语句终止循环 --]\n                  break\n               end\n            end    \n            \n## 迭代器\n    1. 泛型 for 迭代器\n        泛型 for 在自己内部保存迭代函数，实际上它保存三个值：迭代函数、状态常量、控制变量。\n        泛型 for 迭代器提供了集合的 key/value 对，语法格式如下：\n        for k, v in pairs(t) do\n            print(k, v)\n        end\n        \n        array = {\"Lua\", \"Tutorial\"}\n        \n        for key,value in ipairs(array) \n        do\n           print(key, value)\n        end\n        \n    2. 无状态的迭代器\n        无状态的迭代器是指不保留任何状态的迭代器，因此在循环中我们可以利用无状态迭代器避免创建闭包花费额外的代价。\n        每一次迭代，迭代函数都是用两个变量（状态常量和控制变量）的值作为参数被调用，一个无状态的迭代器只利用这两个值可以获取下一个元素。\n        这种无状态迭代器的典型的简单的例子是ipairs，它遍历数组的每一个元素。\n        以下实例我们使用了一个简单的函数来实现迭代器，实现 数字 n 的平方：\n        function square(iteratorMaxCount,currentNumber)\n           if currentNumber<iteratorMaxCount\n           then\n              currentNumber = currentNumber+1\n           return currentNumber, currentNumber*currentNumber\n           end\n        end\n        \n        for i,n in square,3,0\n        do\n           print(i,n)\n        end   \n        \n        简单例子:\n            function iter (a, i)\n                i = i + 1\n                local v = a[i]\n                if v then\n                   return i, v\n                end\n            end\n             \n            function ipairs (a)\n                return iter, a, 0\n            end   \n     \n    3.多状态的迭代器\n         很多情况下，迭代器需要保存多个状态信息而不是简单的状态常量和控制变量，最简单的方法是使用闭包，还有一种方法就是将所有的状态信息封装到table内，将table作为迭代器的状态常量，因为这种情况下可以将所有的信息存放在table内，所以迭代函数通常不需要第二个参数。\n         array = {\"Lua\", \"Tutorial\"}\n         \n         function elementIterator (collection)\n            local index = 0\n            local count = #collection\n            -- 闭包函数\n            return function ()\n               index = index + 1\n               if index <= count\n               then\n                  --  返回迭代器的当前元素\n                  return collection[index]\n               end\n            end\n         end\n         \n         for element in elementIterator(array)\n         do\n            print(element)\n         end\n                      \n## 流程控制\n    1.if 语句\tif 语句 由一个布尔表达式作为条件判断，其后紧跟其他语句组成。\n        if(布尔表达式)\n        then\n           --[ 在布尔表达式为 true 时执行的语句 --]\n        end\n    2.if...else 语句\tif 语句 可以与 else 语句搭配使用, 在 if 条件表达式为 false 时执行 else 语句代码。\n        格式一：\n            if(布尔表达式)\n            then\n               --[ 布尔表达式为 true 时执行该语句块 --]\n            else\n               --[ 布尔表达式为 false 时执行该语句块 --]\n            end\n        \n        格式二：\n            if( 布尔表达式 1)\n            then\n               --[ 在布尔表达式 1 为 true 时执行该语句块 --]\n            \n            elseif( 布尔表达式 2)\n            then\n               --[ 在布尔表达式 2 为 true 时执行该语句块 --]\n            \n            elseif( 布尔表达式 3)\n            then\n               --[ 在布尔表达式 3 为 true 时执行该语句块 --]\n            else \n               --[ 如果以上布尔表达式都不为 true 则执行该语句块 --]\n            end\n    3.if 嵌套语句\t你可以在if 或 else if中使用一个或多个 if 或 else if 语句 。\n        if( 布尔表达式 1)\n        then\n           --[ 布尔表达式 1 为 true 时执行该语句块 --]\n           if(布尔表达式 2)\n           then\n              --[ 布尔表达式 2 为 true 时执行该语句块 --]\n           end\n        end\n","slug":"微服务API网关框架-4","published":1,"updated":"2018-12-20T06:26:54.503Z","_id":"cjpw2eyh3000on0ujc440506d","comments":1,"layout":"post","photos":[],"link":"","content":"<h2><span id=\"运算符\">运算符</span></h2>\n<pre><code>Lua提供了以下几种运算符类型:\n    算术运算符\n    关系运算符\n    逻辑运算符\n    其他运算符 (..,#)\n</code></pre>\n<h3><span id=\"算术运算符\">算术运算符</span></h3>\n<pre><code>操作符         描述          实例\n+              加法          A + B 输出结果 30\n-              减法          A - B 输出结果 -10\n*              乘法          A * B 输出结果 200\n/              除法          B / A w输出结果 2\n%              取余          B % A 输出结果 0\n^              乘幂          A^2 输出结果 100\n-              负号          -A 输出结果v -10\n</code></pre>\n<h3><span id=\"关系运算符\">关系运算符</span></h3>\n<pre><code>操作符          描述\t                                                                        实例\n==              等于，检测两个值是否相等，相等返回 true，否则返回 false\t                    (A == B) 为 false。\n~=              不等于，检测两个值是否相等，相等返回 false，否则返回 true\t                    (A ~= B) 为 true。\n&gt;               大于，如果左边的值大于右边的值，返回 true，否则返回 false\t                    (A &gt; B) 为 false。\n&lt;               小于，如果左边的值大于右边的值，返回 false，否则返回 true\t                    (A &lt; B) 为 true。\n&gt;=              大于等于，如果左边的值大于等于右边的值，返回 true，否则返回 false\t            (A &gt;= B) 返回 false。\n&lt;=              小于等于， 如果左边的值小于等于右边的值，返回 true，否则返回 false\t        (A &lt;= B) 返回 true。     \n</code></pre>\n<h3><span id=\"逻辑运算符\">逻辑运算符</span></h3>\n<pre><code>操作符\t        描述                                                                 实例\nand             逻辑与操作符。 若 A 为 false，则返回 A，否则返回 B。\t                 (A and B) 为 false。\nor              逻辑或操作符。 若 A 为 true，则返回 A，否则返回 B。\t                 (A or B) 为 true。\nnot             逻辑非操作符。与逻辑运算结果相反，如果条件为 true，逻辑非为 false。    not(A and B) 为 true。\n</code></pre>\n<h3><span id=\"运算符优先级\">运算符优先级</span></h3>\n<pre><code>从高到低的顺序：\n    ^\n    not    - (unary)\n    *      /\n    +      -\n    ..\n    &lt;      &gt;      &lt;=     &gt;=     ~=     ==\n    and\n    or\n</code></pre>\n<h2><span id=\"循环\">循环</span></h2>\n<pre><code>1. while 循环\t在条件为 true 时，让程序重复地执行某些语句。执行语句前会先检查条件是否为 true。\n    while(condition)\n    do\n       statements\n    end\n    var 从 exp1 变化到 exp2，每次变化以 exp3 为步长递增 var，并执行一次 &quot;执行体&quot;。exp3 是可选的，如果不指定，默认为1。\n    \n    例子:\n        for i=1,f(x) do\n            print(i)\n        end\n         \n        for i=10,1,-1 do\n            print(i)\n        end\n2. for 循环\t重复执行指定语句，重复次数可在 for 语句中控制。\n    (1)数值for循环\n        for var=exp1,exp2,exp3 do  \n            &lt;执行体&gt;  \n        end  \n    (2)泛型for循环   \n        a = {&quot;one&quot;, &quot;two&quot;, &quot;three&quot;}\n        for i, v in ipairs(a) do\n            print(i, v)\n        end \n3. repeat...until\t重复执行循环，直到 指定的条件为真时为止\n    repeat\n       statements\n    until( condition )\n    \n    例子：\n        --[ 变量定义 --]\n        a = 10\n        --[ 执行循环 --]\n        repeat\n           print(&quot;a的值为:&quot;, a)\n           a = a + 1\n        until( a &gt; 15 )  \n4. 循环嵌套\t可以在循环内嵌套一个或多个循环语句（while do ... end;for ... do ... end;repeat ... until;）\n5. 无限循环\n    while( true )\n    do\n       print(&quot;循环将永远执行下去&quot;)\n    end\n6. break 用于退出当前循环或语句\n    例子：\n        --[ 定义变量 --]\n        a = 10\n        --[ while 循环 --]\n        while( a &lt; 20 )\n        do\n           print(&quot;a 的值为:&quot;, a)\n           a=a+1\n           if( a &gt; 15)\n           then\n              --[ 使用 break 语句终止循环 --]\n              break\n           end\n        end    \n</code></pre>\n<h2><span id=\"迭代器\">迭代器</span></h2>\n<pre><code>1. 泛型 for 迭代器\n    泛型 for 在自己内部保存迭代函数，实际上它保存三个值：迭代函数、状态常量、控制变量。\n    泛型 for 迭代器提供了集合的 key/value 对，语法格式如下：\n    for k, v in pairs(t) do\n        print(k, v)\n    end\n    \n    array = {&quot;Lua&quot;, &quot;Tutorial&quot;}\n    \n    for key,value in ipairs(array) \n    do\n       print(key, value)\n    end\n    \n2. 无状态的迭代器\n    无状态的迭代器是指不保留任何状态的迭代器，因此在循环中我们可以利用无状态迭代器避免创建闭包花费额外的代价。\n    每一次迭代，迭代函数都是用两个变量（状态常量和控制变量）的值作为参数被调用，一个无状态的迭代器只利用这两个值可以获取下一个元素。\n    这种无状态迭代器的典型的简单的例子是ipairs，它遍历数组的每一个元素。\n    以下实例我们使用了一个简单的函数来实现迭代器，实现 数字 n 的平方：\n    function square(iteratorMaxCount,currentNumber)\n       if currentNumber&lt;iteratorMaxCount\n       then\n          currentNumber = currentNumber+1\n       return currentNumber, currentNumber*currentNumber\n       end\n    end\n    \n    for i,n in square,3,0\n    do\n       print(i,n)\n    end   \n    \n    简单例子:\n        function iter (a, i)\n            i = i + 1\n            local v = a[i]\n            if v then\n               return i, v\n            end\n        end\n         \n        function ipairs (a)\n            return iter, a, 0\n        end   \n \n3.多状态的迭代器\n     很多情况下，迭代器需要保存多个状态信息而不是简单的状态常量和控制变量，最简单的方法是使用闭包，还有一种方法就是将所有的状态信息封装到table内，将table作为迭代器的状态常量，因为这种情况下可以将所有的信息存放在table内，所以迭代函数通常不需要第二个参数。\n     array = {&quot;Lua&quot;, &quot;Tutorial&quot;}\n     \n     function elementIterator (collection)\n        local index = 0\n        local count = #collection\n        -- 闭包函数\n        return function ()\n           index = index + 1\n           if index &lt;= count\n           then\n              --  返回迭代器的当前元素\n              return collection[index]\n           end\n        end\n     end\n     \n     for element in elementIterator(array)\n     do\n        print(element)\n     end\n</code></pre>\n<h2><span id=\"流程控制\">流程控制</span></h2>\n<pre><code>1.if 语句\tif 语句 由一个布尔表达式作为条件判断，其后紧跟其他语句组成。\n    if(布尔表达式)\n    then\n       --[ 在布尔表达式为 true 时执行的语句 --]\n    end\n2.if...else 语句\tif 语句 可以与 else 语句搭配使用, 在 if 条件表达式为 false 时执行 else 语句代码。\n    格式一：\n        if(布尔表达式)\n        then\n           --[ 布尔表达式为 true 时执行该语句块 --]\n        else\n           --[ 布尔表达式为 false 时执行该语句块 --]\n        end\n    \n    格式二：\n        if( 布尔表达式 1)\n        then\n           --[ 在布尔表达式 1 为 true 时执行该语句块 --]\n        \n        elseif( 布尔表达式 2)\n        then\n           --[ 在布尔表达式 2 为 true 时执行该语句块 --]\n        \n        elseif( 布尔表达式 3)\n        then\n           --[ 在布尔表达式 3 为 true 时执行该语句块 --]\n        else \n           --[ 如果以上布尔表达式都不为 true 则执行该语句块 --]\n        end\n3.if 嵌套语句\t你可以在if 或 else if中使用一个或多个 if 或 else if 语句 。\n    if( 布尔表达式 1)\n    then\n       --[ 布尔表达式 1 为 true 时执行该语句块 --]\n       if(布尔表达式 2)\n       then\n          --[ 布尔表达式 2 为 true 时执行该语句块 --]\n       end\n    end\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2>运算符</h2>\n<pre><code>Lua提供了以下几种运算符类型:\n    算术运算符\n    关系运算符\n    逻辑运算符\n    其他运算符 (..,#)\n</code></pre>\n<h3>算术运算符</h3>\n<pre><code>操作符         描述          实例\n+              加法          A + B 输出结果 30\n-              减法          A - B 输出结果 -10\n*              乘法          A * B 输出结果 200\n/              除法          B / A w输出结果 2\n%              取余          B % A 输出结果 0\n^              乘幂          A^2 输出结果 100\n-              负号          -A 输出结果v -10\n</code></pre>\n<h3>关系运算符</h3>\n<pre><code>操作符          描述\t                                                                        实例\n==              等于，检测两个值是否相等，相等返回 true，否则返回 false\t                    (A == B) 为 false。\n~=              不等于，检测两个值是否相等，相等返回 false，否则返回 true\t                    (A ~= B) 为 true。\n&gt;               大于，如果左边的值大于右边的值，返回 true，否则返回 false\t                    (A &gt; B) 为 false。\n&lt;               小于，如果左边的值大于右边的值，返回 false，否则返回 true\t                    (A &lt; B) 为 true。\n&gt;=              大于等于，如果左边的值大于等于右边的值，返回 true，否则返回 false\t            (A &gt;= B) 返回 false。\n&lt;=              小于等于， 如果左边的值小于等于右边的值，返回 true，否则返回 false\t        (A &lt;= B) 返回 true。     \n</code></pre>\n<h3>逻辑运算符</h3>\n<pre><code>操作符\t        描述                                                                 实例\nand             逻辑与操作符。 若 A 为 false，则返回 A，否则返回 B。\t                 (A and B) 为 false。\nor              逻辑或操作符。 若 A 为 true，则返回 A，否则返回 B。\t                 (A or B) 为 true。\nnot             逻辑非操作符。与逻辑运算结果相反，如果条件为 true，逻辑非为 false。    not(A and B) 为 true。\n</code></pre>\n<h3>运算符优先级</h3>\n<pre><code>从高到低的顺序：\n    ^\n    not    - (unary)\n    *      /\n    +      -\n    ..\n    &lt;      &gt;      &lt;=     &gt;=     ~=     ==\n    and\n    or\n</code></pre>\n<h2>循环</h2>\n<pre><code>1. while 循环\t在条件为 true 时，让程序重复地执行某些语句。执行语句前会先检查条件是否为 true。\n    while(condition)\n    do\n       statements\n    end\n    var 从 exp1 变化到 exp2，每次变化以 exp3 为步长递增 var，并执行一次 &quot;执行体&quot;。exp3 是可选的，如果不指定，默认为1。\n    \n    例子:\n        for i=1,f(x) do\n            print(i)\n        end\n         \n        for i=10,1,-1 do\n            print(i)\n        end\n2. for 循环\t重复执行指定语句，重复次数可在 for 语句中控制。\n    (1)数值for循环\n        for var=exp1,exp2,exp3 do  \n            &lt;执行体&gt;  \n        end  \n    (2)泛型for循环   \n        a = {&quot;one&quot;, &quot;two&quot;, &quot;three&quot;}\n        for i, v in ipairs(a) do\n            print(i, v)\n        end \n3. repeat...until\t重复执行循环，直到 指定的条件为真时为止\n    repeat\n       statements\n    until( condition )\n    \n    例子：\n        --[ 变量定义 --]\n        a = 10\n        --[ 执行循环 --]\n        repeat\n           print(&quot;a的值为:&quot;, a)\n           a = a + 1\n        until( a &gt; 15 )  \n4. 循环嵌套\t可以在循环内嵌套一个或多个循环语句（while do ... end;for ... do ... end;repeat ... until;）\n5. 无限循环\n    while( true )\n    do\n       print(&quot;循环将永远执行下去&quot;)\n    end\n6. break 用于退出当前循环或语句\n    例子：\n        --[ 定义变量 --]\n        a = 10\n        --[ while 循环 --]\n        while( a &lt; 20 )\n        do\n           print(&quot;a 的值为:&quot;, a)\n           a=a+1\n           if( a &gt; 15)\n           then\n              --[ 使用 break 语句终止循环 --]\n              break\n           end\n        end    \n</code></pre>\n<h2>迭代器</h2>\n<pre><code>1. 泛型 for 迭代器\n    泛型 for 在自己内部保存迭代函数，实际上它保存三个值：迭代函数、状态常量、控制变量。\n    泛型 for 迭代器提供了集合的 key/value 对，语法格式如下：\n    for k, v in pairs(t) do\n        print(k, v)\n    end\n    \n    array = {&quot;Lua&quot;, &quot;Tutorial&quot;}\n    \n    for key,value in ipairs(array) \n    do\n       print(key, value)\n    end\n    \n2. 无状态的迭代器\n    无状态的迭代器是指不保留任何状态的迭代器，因此在循环中我们可以利用无状态迭代器避免创建闭包花费额外的代价。\n    每一次迭代，迭代函数都是用两个变量（状态常量和控制变量）的值作为参数被调用，一个无状态的迭代器只利用这两个值可以获取下一个元素。\n    这种无状态迭代器的典型的简单的例子是ipairs，它遍历数组的每一个元素。\n    以下实例我们使用了一个简单的函数来实现迭代器，实现 数字 n 的平方：\n    function square(iteratorMaxCount,currentNumber)\n       if currentNumber&lt;iteratorMaxCount\n       then\n          currentNumber = currentNumber+1\n       return currentNumber, currentNumber*currentNumber\n       end\n    end\n    \n    for i,n in square,3,0\n    do\n       print(i,n)\n    end   \n    \n    简单例子:\n        function iter (a, i)\n            i = i + 1\n            local v = a[i]\n            if v then\n               return i, v\n            end\n        end\n         \n        function ipairs (a)\n            return iter, a, 0\n        end   \n \n3.多状态的迭代器\n     很多情况下，迭代器需要保存多个状态信息而不是简单的状态常量和控制变量，最简单的方法是使用闭包，还有一种方法就是将所有的状态信息封装到table内，将table作为迭代器的状态常量，因为这种情况下可以将所有的信息存放在table内，所以迭代函数通常不需要第二个参数。\n     array = {&quot;Lua&quot;, &quot;Tutorial&quot;}\n     \n     function elementIterator (collection)\n        local index = 0\n        local count = #collection\n        -- 闭包函数\n        return function ()\n           index = index + 1\n           if index &lt;= count\n           then\n              --  返回迭代器的当前元素\n              return collection[index]\n           end\n        end\n     end\n     \n     for element in elementIterator(array)\n     do\n        print(element)\n     end\n</code></pre>\n<h2>流程控制</h2>\n<pre><code>1.if 语句\tif 语句 由一个布尔表达式作为条件判断，其后紧跟其他语句组成。\n    if(布尔表达式)\n    then\n       --[ 在布尔表达式为 true 时执行的语句 --]\n    end\n2.if...else 语句\tif 语句 可以与 else 语句搭配使用, 在 if 条件表达式为 false 时执行 else 语句代码。\n    格式一：\n        if(布尔表达式)\n        then\n           --[ 布尔表达式为 true 时执行该语句块 --]\n        else\n           --[ 布尔表达式为 false 时执行该语句块 --]\n        end\n    \n    格式二：\n        if( 布尔表达式 1)\n        then\n           --[ 在布尔表达式 1 为 true 时执行该语句块 --]\n        \n        elseif( 布尔表达式 2)\n        then\n           --[ 在布尔表达式 2 为 true 时执行该语句块 --]\n        \n        elseif( 布尔表达式 3)\n        then\n           --[ 在布尔表达式 3 为 true 时执行该语句块 --]\n        else \n           --[ 如果以上布尔表达式都不为 true 则执行该语句块 --]\n        end\n3.if 嵌套语句\t你可以在if 或 else if中使用一个或多个 if 或 else if 语句 。\n    if( 布尔表达式 1)\n    then\n       --[ 布尔表达式 1 为 true 时执行该语句块 --]\n       if(布尔表达式 2)\n       then\n          --[ 布尔表达式 2 为 true 时执行该语句块 --]\n       end\n    end\n</code></pre>\n"},{"title":"微服务API网关框架(5)--模块与包,元表(Metatable)，协程，文件I/O，错误处理,面向对象与数据库访问","catalog":true,"date":"2018-12-20T03:40:23.000Z","subtitle":null,"header-img":"Demo.png","catagories":["微服务API网关"],"_content":"\n## 模块与包\n    Lua 加入了标准的模块管理机制，可以把一些公用的代码放在一个文件里，以 API 接口的形式在其他地方调用，有利于代码的重用和降低代码耦合度。\n    Lua 的模块是由变量、函数等已知元素组成的 table，因此创建一个模块很简单，就是创建一个 table，然后把需要导出的常量、函数放入其中，最后返回这个 table 就行。\n    demo:\n       -- 文件名为 module.lua\n       -- 定义一个名为 module 的模块\n       module = {}\n        \n       -- 定义一个常量\n       module.constant = \"这是一个常量\"\n        \n       -- 定义一个函数\n       function module.func1()\n           io.write(\"这是一个公有函数！\\n\")\n       end\n        \n       local function func2()\n           print(\"这是一个私有函数！\")\n       end\n        \n       function module.func3()\n           func2()\n       end\n        \n       return module\n    \n    模块引用\n        require 函数\n        Lua提供了一个名为require的函数用来加载模块。要加载一个模块，只需要简单地调用就可以了。\n        \n        require(\"<模块名>\")\n        或者\n        require \"<模块名>\"\n        \n        -- test_module.lua 文件\n        -- module 模块为上文提到到 module.lua\n        require(\"module\")\n         \n        print(module.constant)\n         \n        module.func3()\n        \n    加载机制\n        加载模块路径\n        对于自定义的模块，模块文件不是放在哪个文件目录都行，函数 require 有它自己的文件路径加载策略，它会尝试从 Lua 文件或 C 程序库中加载模块。\n        require 用于搜索 Lua 文件的路径是存放在全局变量 package.path 中，当 Lua 启动后，会以环境变量 LUA_PATH 的值来初始这个环境变量。如果没有找到该环境变量，则使用一个编译时定义的默认路径来初始化。\n        当然，如果没有 LUA_PATH 这个环境变量，也可以自定义设置，在当前用户根目录下打开 .profile 文件（没有则创建，打开 .bashrc 文件也可以），例如把 \"~/lua/\" 路径加入 LUA_PATH 环境变量里：\n            #LUA_PATH\n            export LUA_PATH=\"~/lua/?.lua;;\"   \n        文件路径以 \";\" 号分隔，最后的 2 个 \";;\" 表示新加的路径后面加上原来的默认路径。\n\n    C语言包（非重点）-- 参考：http://www.runoob.com/lua/lua-modules-packages.html\n       Lua和C是很容易结合的，使用C为Lua写包。 \n       与Lua中写包不同，C包在使用以前必须首先加载并连接，在大多数系统中最容易的实现方式是通过动态连接库机制。\n       Lua在一个叫loadlib的函数内提供了所有的动态连接的功能。这个函数有两个参数:库的绝对路径和初始化函数。\n    \n## 元表(Metatable)\n    http://www.runoob.com/lua/lua-metatables.html\n    \n\n## 协程\n    http://www.runoob.com/lua/lua-coroutine.html\n\n## 文件I/O\n    http://www.runoob.com/lua/lua-file-io.html\n\n## 错误处理\n    错误种类\n        1. 语法错误\n            语法错误通常是由于对程序的组件（如运算符、表达式）使用不当引起的\n        2. 运行错误\n            运行错误是程序可以正常执行，但是会输出报错信息\n\n    错误处理\n       使用两个函数：assert 和 error 来处理错误\n       assert函数:\n           local function add(a,b)\n              assert(type(a) == \"number\", \"a 不是一个数字\")\n              assert(type(b) == \"number\", \"b 不是一个数字\")\n              return a+b\n           end\n           add(10)\n           \n           执行以上程序会出现如下错误：\n           lua: test.lua:3: b 不是一个数字\n           stack traceback:\n               [C]: in function 'assert'\n               test.lua:3: in local 'add'\n               test.lua:6: in main chunk\n               [C]: in ?         \n        \n       现象:实例中assert首先检查第一个参数，若没问题，assert不做任何事情；否则，assert以第二个参数作为错误信息抛出     \n\n       error函数:\n         格式: error (message [, level])\n            功能：终止正在执行的函数，并返回message的内容作为错误信息(error函数永远都不会返回)\n            通常情况下，error会附加一些错误位置的信息到message头部。\n            Level参数指示获得错误的位置:\n            Level=1[默认]：为调用error位置(文件+行号)\n            Level=2：指出哪个调用error的函数的函数\n            Level=0:不添加错误位置信息      \n\n    pcall 和 xpcall、debug(非重点内容)\n      Lua中处理错误，可以使用函数pcall（protected call）来包装需要执行的代码。\n      pcall接收一个函数和要传递给后者的参数，并执行，执行结果：有错误、无错误；返回值true或者或false, errorinfo\n          if pcall(function_name,...) then\n          -- 没有错误\n          else\n          -- 一些错误\n          end\n        简单例子:\n            > =pcall(function(i) print(i) end, 33)\n            33\n            true\n            > =pcall(function(i) print(i) error('error..') end, 33)\n            33\n            false        stdin:1: error..        \n        \n        pcall以一种\"保护模式\"来调用第一个参数，因此pcall可以捕获函数执行中的任何错误。\n        通常在错误发生时，希望落得更多的调试信息，而不只是发生错误的位置。但pcall返回时，它已经销毁了调用桟的部分内容。\n        Lua提供了xpcall函数，xpcall接收第二个参数——一个错误处理函数，当错误发生时，Lua会在调用桟展开（unwind）前调用错误处理函数，于是就可以在这个函数中使用debug库来获取关于错误的额外信息了。\n        debug库提供了两个通用的错误处理函数，返回的调试内容会多一点:\n        debug.debug：提供一个Lua提示符，让用户来检查错误的原因\n        debug.traceback：根据调用桟来构建一个扩展的错误消息\n\n## 面向对象\n    面向对象的特征: 封装 继承 多态（lua没有多态）\n    \n    封装\n        Lua中的表不仅在某种意义上是一种对象。像对象一样，表也有状态（成员变量）；也有与对象的值独立的本性，特别是拥有两个不同值的对象（table）代表两个不同的对象；一个对象在不同的时候也可以有不同的值，但他始终是一个对象；与对象类似，表的生命周期与其由什么创建、在哪创建没有关系。对象有他们的成员函数，表也有：\n           Account = {balance = 0}\n           function Account.withdraw (v)\n               Account.balance = Account.balance - v\n           end \n           \n        简单完整实例\n           -- Meta class\n           Shape = {area = 0}\n           \n           -- 基础类方法 new -- 创建对象\n           function Shape:new (o,side)\n             o = o or {}\n             setmetatable(o, self)\n             self.__index = self\n             side = side or 0\n             self.area = side*side;\n             return o\n           end\n           \n           -- 基础类方法 printArea\n           function Shape:printArea ()\n             print(\"面积为 \",self.area) -- 访问属性\n           end\n           \n           -- 创建对象\n           myshape = Shape:new(nil,10)\n           \n           myshape:printArea()   -- 访问成员函数\n    \n    继承\n        继承是指一个对象直接使用另一对象的属性和方法\n             -- Meta class\n            Shape = {area = 0}\n            -- 基础类方法 new\n            function Shape:new (o,side)\n              o = o or {}\n              setmetatable(o, self)\n              self.__index = self\n              side = side or 0\n              self.area = side*side;\n              return o\n            end\n            -- 基础类方法 printArea\n            function Shape:printArea ()\n              print(\"面积为 \",self.area)\n            end\n            \n            -- 创建对象\n            myshape = Shape:new(nil,10)\n            myshape:printArea()\n            \n            Square = Shape:new()\n            -- 派生类方法 new\n            function Square:new (o,side)\n              o = o or Shape:new(o,side)\n              setmetatable(o, self)\n              self.__index = self\n              return o\n            end\n            \n            -- 派生类方法 printArea\n            function Square:printArea ()\n              print(\"正方形面积为 \",self.area)\n            end\n            \n            -- 创建对象\n            mysquare = Square:new(nil,10)\n            mysquare:printArea()\n            \n            Rectangle = Shape:new()\n            -- 派生类方法 new\n            function Rectangle:new (o,length,breadth)\n              o = o or Shape:new(o)\n              setmetatable(o, self)\n              self.__index = self\n              self.area = length * breadth\n              return o\n            end\n            \n            -- 派生类方法 printArea\n            function Rectangle:printArea ()\n              print(\"矩形面积为 \",self.area)\n            end\n            \n            -- 创建对象\n            myrectangle = Rectangle:new(nil,10,20)\n            myrectangle:printArea()\n            \n    重写\n        -- 派生类方法 printArea\n        function Square:printArea ()\n          print(\"正方形面积 \",self.area)\n        end        \n\n## 数据库访问\n    Lua 连接MySql 数据库\n    \n    require \"luasql.mysql\"\n    \n    --创建环境对象\n    env = luasql.mysql()\n    \n    --连接数据库\n    conn = env:connect(\"数据库名\",\"用户名\",\"密码\",\"IP地址\",端口)\n    \n    --设置数据库的编码格式\n    conn:execute\"SET NAMES UTF8\"\n    \n    --执行数据库操作\n    cur = conn:execute(\"select * from role\")\n    \n    row = cur:fetch({},\"a\")\n    \n    --文件对象的创建\n    file = io.open(\"role.txt\",\"w+\");\n    \n    while row do\n        var = string.format(\"%d %s\\n\", row.id, row.name)\n    \n        print(var)\n    \n        file:write(var)\n    \n        row = cur:fetch(row,\"a\")\n    end\n    \n    \n    file:close()  --关闭文件对象\n    conn:close()  --关闭数据库连接\n    env:close()   --关闭数据库环境    \n","source":"_posts/微服务API网关框架-5.md","raw":"---\ntitle: 微服务API网关框架(5)--模块与包,元表(Metatable)，协程，文件I/O，错误处理,面向对象与数据库访问\ncatalog: true\ndate: 2018-12-20 11:40:23\nsubtitle:\nheader-img: \"Demo.png\"\ntags:\n- 微服务API网关\ncatagories:\n- 微服务API网关\n---\n\n## 模块与包\n    Lua 加入了标准的模块管理机制，可以把一些公用的代码放在一个文件里，以 API 接口的形式在其他地方调用，有利于代码的重用和降低代码耦合度。\n    Lua 的模块是由变量、函数等已知元素组成的 table，因此创建一个模块很简单，就是创建一个 table，然后把需要导出的常量、函数放入其中，最后返回这个 table 就行。\n    demo:\n       -- 文件名为 module.lua\n       -- 定义一个名为 module 的模块\n       module = {}\n        \n       -- 定义一个常量\n       module.constant = \"这是一个常量\"\n        \n       -- 定义一个函数\n       function module.func1()\n           io.write(\"这是一个公有函数！\\n\")\n       end\n        \n       local function func2()\n           print(\"这是一个私有函数！\")\n       end\n        \n       function module.func3()\n           func2()\n       end\n        \n       return module\n    \n    模块引用\n        require 函数\n        Lua提供了一个名为require的函数用来加载模块。要加载一个模块，只需要简单地调用就可以了。\n        \n        require(\"<模块名>\")\n        或者\n        require \"<模块名>\"\n        \n        -- test_module.lua 文件\n        -- module 模块为上文提到到 module.lua\n        require(\"module\")\n         \n        print(module.constant)\n         \n        module.func3()\n        \n    加载机制\n        加载模块路径\n        对于自定义的模块，模块文件不是放在哪个文件目录都行，函数 require 有它自己的文件路径加载策略，它会尝试从 Lua 文件或 C 程序库中加载模块。\n        require 用于搜索 Lua 文件的路径是存放在全局变量 package.path 中，当 Lua 启动后，会以环境变量 LUA_PATH 的值来初始这个环境变量。如果没有找到该环境变量，则使用一个编译时定义的默认路径来初始化。\n        当然，如果没有 LUA_PATH 这个环境变量，也可以自定义设置，在当前用户根目录下打开 .profile 文件（没有则创建，打开 .bashrc 文件也可以），例如把 \"~/lua/\" 路径加入 LUA_PATH 环境变量里：\n            #LUA_PATH\n            export LUA_PATH=\"~/lua/?.lua;;\"   \n        文件路径以 \";\" 号分隔，最后的 2 个 \";;\" 表示新加的路径后面加上原来的默认路径。\n\n    C语言包（非重点）-- 参考：http://www.runoob.com/lua/lua-modules-packages.html\n       Lua和C是很容易结合的，使用C为Lua写包。 \n       与Lua中写包不同，C包在使用以前必须首先加载并连接，在大多数系统中最容易的实现方式是通过动态连接库机制。\n       Lua在一个叫loadlib的函数内提供了所有的动态连接的功能。这个函数有两个参数:库的绝对路径和初始化函数。\n    \n## 元表(Metatable)\n    http://www.runoob.com/lua/lua-metatables.html\n    \n\n## 协程\n    http://www.runoob.com/lua/lua-coroutine.html\n\n## 文件I/O\n    http://www.runoob.com/lua/lua-file-io.html\n\n## 错误处理\n    错误种类\n        1. 语法错误\n            语法错误通常是由于对程序的组件（如运算符、表达式）使用不当引起的\n        2. 运行错误\n            运行错误是程序可以正常执行，但是会输出报错信息\n\n    错误处理\n       使用两个函数：assert 和 error 来处理错误\n       assert函数:\n           local function add(a,b)\n              assert(type(a) == \"number\", \"a 不是一个数字\")\n              assert(type(b) == \"number\", \"b 不是一个数字\")\n              return a+b\n           end\n           add(10)\n           \n           执行以上程序会出现如下错误：\n           lua: test.lua:3: b 不是一个数字\n           stack traceback:\n               [C]: in function 'assert'\n               test.lua:3: in local 'add'\n               test.lua:6: in main chunk\n               [C]: in ?         \n        \n       现象:实例中assert首先检查第一个参数，若没问题，assert不做任何事情；否则，assert以第二个参数作为错误信息抛出     \n\n       error函数:\n         格式: error (message [, level])\n            功能：终止正在执行的函数，并返回message的内容作为错误信息(error函数永远都不会返回)\n            通常情况下，error会附加一些错误位置的信息到message头部。\n            Level参数指示获得错误的位置:\n            Level=1[默认]：为调用error位置(文件+行号)\n            Level=2：指出哪个调用error的函数的函数\n            Level=0:不添加错误位置信息      \n\n    pcall 和 xpcall、debug(非重点内容)\n      Lua中处理错误，可以使用函数pcall（protected call）来包装需要执行的代码。\n      pcall接收一个函数和要传递给后者的参数，并执行，执行结果：有错误、无错误；返回值true或者或false, errorinfo\n          if pcall(function_name,...) then\n          -- 没有错误\n          else\n          -- 一些错误\n          end\n        简单例子:\n            > =pcall(function(i) print(i) end, 33)\n            33\n            true\n            > =pcall(function(i) print(i) error('error..') end, 33)\n            33\n            false        stdin:1: error..        \n        \n        pcall以一种\"保护模式\"来调用第一个参数，因此pcall可以捕获函数执行中的任何错误。\n        通常在错误发生时，希望落得更多的调试信息，而不只是发生错误的位置。但pcall返回时，它已经销毁了调用桟的部分内容。\n        Lua提供了xpcall函数，xpcall接收第二个参数——一个错误处理函数，当错误发生时，Lua会在调用桟展开（unwind）前调用错误处理函数，于是就可以在这个函数中使用debug库来获取关于错误的额外信息了。\n        debug库提供了两个通用的错误处理函数，返回的调试内容会多一点:\n        debug.debug：提供一个Lua提示符，让用户来检查错误的原因\n        debug.traceback：根据调用桟来构建一个扩展的错误消息\n\n## 面向对象\n    面向对象的特征: 封装 继承 多态（lua没有多态）\n    \n    封装\n        Lua中的表不仅在某种意义上是一种对象。像对象一样，表也有状态（成员变量）；也有与对象的值独立的本性，特别是拥有两个不同值的对象（table）代表两个不同的对象；一个对象在不同的时候也可以有不同的值，但他始终是一个对象；与对象类似，表的生命周期与其由什么创建、在哪创建没有关系。对象有他们的成员函数，表也有：\n           Account = {balance = 0}\n           function Account.withdraw (v)\n               Account.balance = Account.balance - v\n           end \n           \n        简单完整实例\n           -- Meta class\n           Shape = {area = 0}\n           \n           -- 基础类方法 new -- 创建对象\n           function Shape:new (o,side)\n             o = o or {}\n             setmetatable(o, self)\n             self.__index = self\n             side = side or 0\n             self.area = side*side;\n             return o\n           end\n           \n           -- 基础类方法 printArea\n           function Shape:printArea ()\n             print(\"面积为 \",self.area) -- 访问属性\n           end\n           \n           -- 创建对象\n           myshape = Shape:new(nil,10)\n           \n           myshape:printArea()   -- 访问成员函数\n    \n    继承\n        继承是指一个对象直接使用另一对象的属性和方法\n             -- Meta class\n            Shape = {area = 0}\n            -- 基础类方法 new\n            function Shape:new (o,side)\n              o = o or {}\n              setmetatable(o, self)\n              self.__index = self\n              side = side or 0\n              self.area = side*side;\n              return o\n            end\n            -- 基础类方法 printArea\n            function Shape:printArea ()\n              print(\"面积为 \",self.area)\n            end\n            \n            -- 创建对象\n            myshape = Shape:new(nil,10)\n            myshape:printArea()\n            \n            Square = Shape:new()\n            -- 派生类方法 new\n            function Square:new (o,side)\n              o = o or Shape:new(o,side)\n              setmetatable(o, self)\n              self.__index = self\n              return o\n            end\n            \n            -- 派生类方法 printArea\n            function Square:printArea ()\n              print(\"正方形面积为 \",self.area)\n            end\n            \n            -- 创建对象\n            mysquare = Square:new(nil,10)\n            mysquare:printArea()\n            \n            Rectangle = Shape:new()\n            -- 派生类方法 new\n            function Rectangle:new (o,length,breadth)\n              o = o or Shape:new(o)\n              setmetatable(o, self)\n              self.__index = self\n              self.area = length * breadth\n              return o\n            end\n            \n            -- 派生类方法 printArea\n            function Rectangle:printArea ()\n              print(\"矩形面积为 \",self.area)\n            end\n            \n            -- 创建对象\n            myrectangle = Rectangle:new(nil,10,20)\n            myrectangle:printArea()\n            \n    重写\n        -- 派生类方法 printArea\n        function Square:printArea ()\n          print(\"正方形面积 \",self.area)\n        end        \n\n## 数据库访问\n    Lua 连接MySql 数据库\n    \n    require \"luasql.mysql\"\n    \n    --创建环境对象\n    env = luasql.mysql()\n    \n    --连接数据库\n    conn = env:connect(\"数据库名\",\"用户名\",\"密码\",\"IP地址\",端口)\n    \n    --设置数据库的编码格式\n    conn:execute\"SET NAMES UTF8\"\n    \n    --执行数据库操作\n    cur = conn:execute(\"select * from role\")\n    \n    row = cur:fetch({},\"a\")\n    \n    --文件对象的创建\n    file = io.open(\"role.txt\",\"w+\");\n    \n    while row do\n        var = string.format(\"%d %s\\n\", row.id, row.name)\n    \n        print(var)\n    \n        file:write(var)\n    \n        row = cur:fetch(row,\"a\")\n    end\n    \n    \n    file:close()  --关闭文件对象\n    conn:close()  --关闭数据库连接\n    env:close()   --关闭数据库环境    \n","slug":"微服务API网关框架-5","published":1,"updated":"2018-12-20T06:27:48.927Z","_id":"cjpw2eyh6000qn0ujoi3vpzq8","comments":1,"layout":"post","photos":[],"link":"","content":"<h2><span id=\"模块与包\">模块与包</span></h2>\n<pre><code>Lua 加入了标准的模块管理机制，可以把一些公用的代码放在一个文件里，以 API 接口的形式在其他地方调用，有利于代码的重用和降低代码耦合度。\nLua 的模块是由变量、函数等已知元素组成的 table，因此创建一个模块很简单，就是创建一个 table，然后把需要导出的常量、函数放入其中，最后返回这个 table 就行。\ndemo:\n   -- 文件名为 module.lua\n   -- 定义一个名为 module 的模块\n   module = {}\n    \n   -- 定义一个常量\n   module.constant = &quot;这是一个常量&quot;\n    \n   -- 定义一个函数\n   function module.func1()\n       io.write(&quot;这是一个公有函数！\\n&quot;)\n   end\n    \n   local function func2()\n       print(&quot;这是一个私有函数！&quot;)\n   end\n    \n   function module.func3()\n       func2()\n   end\n    \n   return module\n\n模块引用\n    require 函数\n    Lua提供了一个名为require的函数用来加载模块。要加载一个模块，只需要简单地调用就可以了。\n    \n    require(&quot;&lt;模块名&gt;&quot;)\n    或者\n    require &quot;&lt;模块名&gt;&quot;\n    \n    -- test_module.lua 文件\n    -- module 模块为上文提到到 module.lua\n    require(&quot;module&quot;)\n     \n    print(module.constant)\n     \n    module.func3()\n    \n加载机制\n    加载模块路径\n    对于自定义的模块，模块文件不是放在哪个文件目录都行，函数 require 有它自己的文件路径加载策略，它会尝试从 Lua 文件或 C 程序库中加载模块。\n    require 用于搜索 Lua 文件的路径是存放在全局变量 package.path 中，当 Lua 启动后，会以环境变量 LUA_PATH 的值来初始这个环境变量。如果没有找到该环境变量，则使用一个编译时定义的默认路径来初始化。\n    当然，如果没有 LUA_PATH 这个环境变量，也可以自定义设置，在当前用户根目录下打开 .profile 文件（没有则创建，打开 .bashrc 文件也可以），例如把 &quot;~/lua/&quot; 路径加入 LUA_PATH 环境变量里：\n        #LUA_PATH\n        export LUA_PATH=&quot;~/lua/?.lua;;&quot;   \n    文件路径以 &quot;;&quot; 号分隔，最后的 2 个 &quot;;;&quot; 表示新加的路径后面加上原来的默认路径。\n\nC语言包（非重点）-- 参考：http://www.runoob.com/lua/lua-modules-packages.html\n   Lua和C是很容易结合的，使用C为Lua写包。 \n   与Lua中写包不同，C包在使用以前必须首先加载并连接，在大多数系统中最容易的实现方式是通过动态连接库机制。\n   Lua在一个叫loadlib的函数内提供了所有的动态连接的功能。这个函数有两个参数:库的绝对路径和初始化函数。\n</code></pre>\n<h2><span id=\"元表metatable\">元表(Metatable)</span></h2>\n<pre><code>http://www.runoob.com/lua/lua-metatables.html\n</code></pre>\n<h2><span id=\"协程\">协程</span></h2>\n<pre><code>http://www.runoob.com/lua/lua-coroutine.html\n</code></pre>\n<h2><span id=\"文件io\">文件I/O</span></h2>\n<pre><code>http://www.runoob.com/lua/lua-file-io.html\n</code></pre>\n<h2><span id=\"错误处理\">错误处理</span></h2>\n<pre><code>错误种类\n    1. 语法错误\n        语法错误通常是由于对程序的组件（如运算符、表达式）使用不当引起的\n    2. 运行错误\n        运行错误是程序可以正常执行，但是会输出报错信息\n\n错误处理\n   使用两个函数：assert 和 error 来处理错误\n   assert函数:\n       local function add(a,b)\n          assert(type(a) == &quot;number&quot;, &quot;a 不是一个数字&quot;)\n          assert(type(b) == &quot;number&quot;, &quot;b 不是一个数字&quot;)\n          return a+b\n       end\n       add(10)\n       \n       执行以上程序会出现如下错误：\n       lua: test.lua:3: b 不是一个数字\n       stack traceback:\n           [C]: in function 'assert'\n           test.lua:3: in local 'add'\n           test.lua:6: in main chunk\n           [C]: in ?         \n    \n   现象:实例中assert首先检查第一个参数，若没问题，assert不做任何事情；否则，assert以第二个参数作为错误信息抛出     \n\n   error函数:\n     格式: error (message [, level])\n        功能：终止正在执行的函数，并返回message的内容作为错误信息(error函数永远都不会返回)\n        通常情况下，error会附加一些错误位置的信息到message头部。\n        Level参数指示获得错误的位置:\n        Level=1[默认]：为调用error位置(文件+行号)\n        Level=2：指出哪个调用error的函数的函数\n        Level=0:不添加错误位置信息      \n\npcall 和 xpcall、debug(非重点内容)\n  Lua中处理错误，可以使用函数pcall（protected call）来包装需要执行的代码。\n  pcall接收一个函数和要传递给后者的参数，并执行，执行结果：有错误、无错误；返回值true或者或false, errorinfo\n      if pcall(function_name,...) then\n      -- 没有错误\n      else\n      -- 一些错误\n      end\n    简单例子:\n        &gt; =pcall(function(i) print(i) end, 33)\n        33\n        true\n        &gt; =pcall(function(i) print(i) error('error..') end, 33)\n        33\n        false        stdin:1: error..        \n    \n    pcall以一种&quot;保护模式&quot;来调用第一个参数，因此pcall可以捕获函数执行中的任何错误。\n    通常在错误发生时，希望落得更多的调试信息，而不只是发生错误的位置。但pcall返回时，它已经销毁了调用桟的部分内容。\n    Lua提供了xpcall函数，xpcall接收第二个参数——一个错误处理函数，当错误发生时，Lua会在调用桟展开（unwind）前调用错误处理函数，于是就可以在这个函数中使用debug库来获取关于错误的额外信息了。\n    debug库提供了两个通用的错误处理函数，返回的调试内容会多一点:\n    debug.debug：提供一个Lua提示符，让用户来检查错误的原因\n    debug.traceback：根据调用桟来构建一个扩展的错误消息\n</code></pre>\n<h2><span id=\"面向对象\">面向对象</span></h2>\n<pre><code>面向对象的特征: 封装 继承 多态（lua没有多态）\n\n封装\n    Lua中的表不仅在某种意义上是一种对象。像对象一样，表也有状态（成员变量）；也有与对象的值独立的本性，特别是拥有两个不同值的对象（table）代表两个不同的对象；一个对象在不同的时候也可以有不同的值，但他始终是一个对象；与对象类似，表的生命周期与其由什么创建、在哪创建没有关系。对象有他们的成员函数，表也有：\n       Account = {balance = 0}\n       function Account.withdraw (v)\n           Account.balance = Account.balance - v\n       end \n       \n    简单完整实例\n       -- Meta class\n       Shape = {area = 0}\n       \n       -- 基础类方法 new -- 创建对象\n       function Shape:new (o,side)\n         o = o or {}\n         setmetatable(o, self)\n         self.__index = self\n         side = side or 0\n         self.area = side*side;\n         return o\n       end\n       \n       -- 基础类方法 printArea\n       function Shape:printArea ()\n         print(&quot;面积为 &quot;,self.area) -- 访问属性\n       end\n       \n       -- 创建对象\n       myshape = Shape:new(nil,10)\n       \n       myshape:printArea()   -- 访问成员函数\n\n继承\n    继承是指一个对象直接使用另一对象的属性和方法\n         -- Meta class\n        Shape = {area = 0}\n        -- 基础类方法 new\n        function Shape:new (o,side)\n          o = o or {}\n          setmetatable(o, self)\n          self.__index = self\n          side = side or 0\n          self.area = side*side;\n          return o\n        end\n        -- 基础类方法 printArea\n        function Shape:printArea ()\n          print(&quot;面积为 &quot;,self.area)\n        end\n        \n        -- 创建对象\n        myshape = Shape:new(nil,10)\n        myshape:printArea()\n        \n        Square = Shape:new()\n        -- 派生类方法 new\n        function Square:new (o,side)\n          o = o or Shape:new(o,side)\n          setmetatable(o, self)\n          self.__index = self\n          return o\n        end\n        \n        -- 派生类方法 printArea\n        function Square:printArea ()\n          print(&quot;正方形面积为 &quot;,self.area)\n        end\n        \n        -- 创建对象\n        mysquare = Square:new(nil,10)\n        mysquare:printArea()\n        \n        Rectangle = Shape:new()\n        -- 派生类方法 new\n        function Rectangle:new (o,length,breadth)\n          o = o or Shape:new(o)\n          setmetatable(o, self)\n          self.__index = self\n          self.area = length * breadth\n          return o\n        end\n        \n        -- 派生类方法 printArea\n        function Rectangle:printArea ()\n          print(&quot;矩形面积为 &quot;,self.area)\n        end\n        \n        -- 创建对象\n        myrectangle = Rectangle:new(nil,10,20)\n        myrectangle:printArea()\n        \n重写\n    -- 派生类方法 printArea\n    function Square:printArea ()\n      print(&quot;正方形面积 &quot;,self.area)\n    end        \n</code></pre>\n<h2><span id=\"数据库访问\">数据库访问</span></h2>\n<pre><code>Lua 连接MySql 数据库\n\nrequire &quot;luasql.mysql&quot;\n\n--创建环境对象\nenv = luasql.mysql()\n\n--连接数据库\nconn = env:connect(&quot;数据库名&quot;,&quot;用户名&quot;,&quot;密码&quot;,&quot;IP地址&quot;,端口)\n\n--设置数据库的编码格式\nconn:execute&quot;SET NAMES UTF8&quot;\n\n--执行数据库操作\ncur = conn:execute(&quot;select * from role&quot;)\n\nrow = cur:fetch({},&quot;a&quot;)\n\n--文件对象的创建\nfile = io.open(&quot;role.txt&quot;,&quot;w+&quot;);\n\nwhile row do\n    var = string.format(&quot;%d %s\\n&quot;, row.id, row.name)\n\n    print(var)\n\n    file:write(var)\n\n    row = cur:fetch(row,&quot;a&quot;)\nend\n\n\nfile:close()  --关闭文件对象\nconn:close()  --关闭数据库连接\nenv:close()   --关闭数据库环境\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2>模块与包</h2>\n<pre><code>Lua 加入了标准的模块管理机制，可以把一些公用的代码放在一个文件里，以 API 接口的形式在其他地方调用，有利于代码的重用和降低代码耦合度。\nLua 的模块是由变量、函数等已知元素组成的 table，因此创建一个模块很简单，就是创建一个 table，然后把需要导出的常量、函数放入其中，最后返回这个 table 就行。\ndemo:\n   -- 文件名为 module.lua\n   -- 定义一个名为 module 的模块\n   module = {}\n    \n   -- 定义一个常量\n   module.constant = &quot;这是一个常量&quot;\n    \n   -- 定义一个函数\n   function module.func1()\n       io.write(&quot;这是一个公有函数！\\n&quot;)\n   end\n    \n   local function func2()\n       print(&quot;这是一个私有函数！&quot;)\n   end\n    \n   function module.func3()\n       func2()\n   end\n    \n   return module\n\n模块引用\n    require 函数\n    Lua提供了一个名为require的函数用来加载模块。要加载一个模块，只需要简单地调用就可以了。\n    \n    require(&quot;&lt;模块名&gt;&quot;)\n    或者\n    require &quot;&lt;模块名&gt;&quot;\n    \n    -- test_module.lua 文件\n    -- module 模块为上文提到到 module.lua\n    require(&quot;module&quot;)\n     \n    print(module.constant)\n     \n    module.func3()\n    \n加载机制\n    加载模块路径\n    对于自定义的模块，模块文件不是放在哪个文件目录都行，函数 require 有它自己的文件路径加载策略，它会尝试从 Lua 文件或 C 程序库中加载模块。\n    require 用于搜索 Lua 文件的路径是存放在全局变量 package.path 中，当 Lua 启动后，会以环境变量 LUA_PATH 的值来初始这个环境变量。如果没有找到该环境变量，则使用一个编译时定义的默认路径来初始化。\n    当然，如果没有 LUA_PATH 这个环境变量，也可以自定义设置，在当前用户根目录下打开 .profile 文件（没有则创建，打开 .bashrc 文件也可以），例如把 &quot;~/lua/&quot; 路径加入 LUA_PATH 环境变量里：\n        #LUA_PATH\n        export LUA_PATH=&quot;~/lua/?.lua;;&quot;   \n    文件路径以 &quot;;&quot; 号分隔，最后的 2 个 &quot;;;&quot; 表示新加的路径后面加上原来的默认路径。\n\nC语言包（非重点）-- 参考：http://www.runoob.com/lua/lua-modules-packages.html\n   Lua和C是很容易结合的，使用C为Lua写包。 \n   与Lua中写包不同，C包在使用以前必须首先加载并连接，在大多数系统中最容易的实现方式是通过动态连接库机制。\n   Lua在一个叫loadlib的函数内提供了所有的动态连接的功能。这个函数有两个参数:库的绝对路径和初始化函数。\n</code></pre>\n<h2>元表(Metatable)</h2>\n<pre><code>http://www.runoob.com/lua/lua-metatables.html\n</code></pre>\n<h2>协程</h2>\n<pre><code>http://www.runoob.com/lua/lua-coroutine.html\n</code></pre>\n<h2>文件I/O</h2>\n<pre><code>http://www.runoob.com/lua/lua-file-io.html\n</code></pre>\n<h2>错误处理</h2>\n<pre><code>错误种类\n    1. 语法错误\n        语法错误通常是由于对程序的组件（如运算符、表达式）使用不当引起的\n    2. 运行错误\n        运行错误是程序可以正常执行，但是会输出报错信息\n\n错误处理\n   使用两个函数：assert 和 error 来处理错误\n   assert函数:\n       local function add(a,b)\n          assert(type(a) == &quot;number&quot;, &quot;a 不是一个数字&quot;)\n          assert(type(b) == &quot;number&quot;, &quot;b 不是一个数字&quot;)\n          return a+b\n       end\n       add(10)\n       \n       执行以上程序会出现如下错误：\n       lua: test.lua:3: b 不是一个数字\n       stack traceback:\n           [C]: in function 'assert'\n           test.lua:3: in local 'add'\n           test.lua:6: in main chunk\n           [C]: in ?         \n    \n   现象:实例中assert首先检查第一个参数，若没问题，assert不做任何事情；否则，assert以第二个参数作为错误信息抛出     \n\n   error函数:\n     格式: error (message [, level])\n        功能：终止正在执行的函数，并返回message的内容作为错误信息(error函数永远都不会返回)\n        通常情况下，error会附加一些错误位置的信息到message头部。\n        Level参数指示获得错误的位置:\n        Level=1[默认]：为调用error位置(文件+行号)\n        Level=2：指出哪个调用error的函数的函数\n        Level=0:不添加错误位置信息      \n\npcall 和 xpcall、debug(非重点内容)\n  Lua中处理错误，可以使用函数pcall（protected call）来包装需要执行的代码。\n  pcall接收一个函数和要传递给后者的参数，并执行，执行结果：有错误、无错误；返回值true或者或false, errorinfo\n      if pcall(function_name,...) then\n      -- 没有错误\n      else\n      -- 一些错误\n      end\n    简单例子:\n        &gt; =pcall(function(i) print(i) end, 33)\n        33\n        true\n        &gt; =pcall(function(i) print(i) error('error..') end, 33)\n        33\n        false        stdin:1: error..        \n    \n    pcall以一种&quot;保护模式&quot;来调用第一个参数，因此pcall可以捕获函数执行中的任何错误。\n    通常在错误发生时，希望落得更多的调试信息，而不只是发生错误的位置。但pcall返回时，它已经销毁了调用桟的部分内容。\n    Lua提供了xpcall函数，xpcall接收第二个参数——一个错误处理函数，当错误发生时，Lua会在调用桟展开（unwind）前调用错误处理函数，于是就可以在这个函数中使用debug库来获取关于错误的额外信息了。\n    debug库提供了两个通用的错误处理函数，返回的调试内容会多一点:\n    debug.debug：提供一个Lua提示符，让用户来检查错误的原因\n    debug.traceback：根据调用桟来构建一个扩展的错误消息\n</code></pre>\n<h2>面向对象</h2>\n<pre><code>面向对象的特征: 封装 继承 多态（lua没有多态）\n\n封装\n    Lua中的表不仅在某种意义上是一种对象。像对象一样，表也有状态（成员变量）；也有与对象的值独立的本性，特别是拥有两个不同值的对象（table）代表两个不同的对象；一个对象在不同的时候也可以有不同的值，但他始终是一个对象；与对象类似，表的生命周期与其由什么创建、在哪创建没有关系。对象有他们的成员函数，表也有：\n       Account = {balance = 0}\n       function Account.withdraw (v)\n           Account.balance = Account.balance - v\n       end \n       \n    简单完整实例\n       -- Meta class\n       Shape = {area = 0}\n       \n       -- 基础类方法 new -- 创建对象\n       function Shape:new (o,side)\n         o = o or {}\n         setmetatable(o, self)\n         self.__index = self\n         side = side or 0\n         self.area = side*side;\n         return o\n       end\n       \n       -- 基础类方法 printArea\n       function Shape:printArea ()\n         print(&quot;面积为 &quot;,self.area) -- 访问属性\n       end\n       \n       -- 创建对象\n       myshape = Shape:new(nil,10)\n       \n       myshape:printArea()   -- 访问成员函数\n\n继承\n    继承是指一个对象直接使用另一对象的属性和方法\n         -- Meta class\n        Shape = {area = 0}\n        -- 基础类方法 new\n        function Shape:new (o,side)\n          o = o or {}\n          setmetatable(o, self)\n          self.__index = self\n          side = side or 0\n          self.area = side*side;\n          return o\n        end\n        -- 基础类方法 printArea\n        function Shape:printArea ()\n          print(&quot;面积为 &quot;,self.area)\n        end\n        \n        -- 创建对象\n        myshape = Shape:new(nil,10)\n        myshape:printArea()\n        \n        Square = Shape:new()\n        -- 派生类方法 new\n        function Square:new (o,side)\n          o = o or Shape:new(o,side)\n          setmetatable(o, self)\n          self.__index = self\n          return o\n        end\n        \n        -- 派生类方法 printArea\n        function Square:printArea ()\n          print(&quot;正方形面积为 &quot;,self.area)\n        end\n        \n        -- 创建对象\n        mysquare = Square:new(nil,10)\n        mysquare:printArea()\n        \n        Rectangle = Shape:new()\n        -- 派生类方法 new\n        function Rectangle:new (o,length,breadth)\n          o = o or Shape:new(o)\n          setmetatable(o, self)\n          self.__index = self\n          self.area = length * breadth\n          return o\n        end\n        \n        -- 派生类方法 printArea\n        function Rectangle:printArea ()\n          print(&quot;矩形面积为 &quot;,self.area)\n        end\n        \n        -- 创建对象\n        myrectangle = Rectangle:new(nil,10,20)\n        myrectangle:printArea()\n        \n重写\n    -- 派生类方法 printArea\n    function Square:printArea ()\n      print(&quot;正方形面积 &quot;,self.area)\n    end        \n</code></pre>\n<h2>数据库访问</h2>\n<pre><code>Lua 连接MySql 数据库\n\nrequire &quot;luasql.mysql&quot;\n\n--创建环境对象\nenv = luasql.mysql()\n\n--连接数据库\nconn = env:connect(&quot;数据库名&quot;,&quot;用户名&quot;,&quot;密码&quot;,&quot;IP地址&quot;,端口)\n\n--设置数据库的编码格式\nconn:execute&quot;SET NAMES UTF8&quot;\n\n--执行数据库操作\ncur = conn:execute(&quot;select * from role&quot;)\n\nrow = cur:fetch({},&quot;a&quot;)\n\n--文件对象的创建\nfile = io.open(&quot;role.txt&quot;,&quot;w+&quot;);\n\nwhile row do\n    var = string.format(&quot;%d %s\\n&quot;, row.id, row.name)\n\n    print(var)\n\n    file:write(var)\n\n    row = cur:fetch(row,&quot;a&quot;)\nend\n\n\nfile:close()  --关闭文件对象\nconn:close()  --关闭数据库连接\nenv:close()   --关闭数据库环境\n</code></pre>\n"},{"title":"微服务API网关框架(6)--OpenResty介绍与简单使用","catalog":true,"date":"2018-12-20T03:40:48.000Z","subtitle":null,"header-img":"Demo.png","catagories":["微服务API网关"],"_content":"\n# OpenResty\n\n## 介绍\n    OpenResty\n        是一个基于 Nginx 与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。\n        用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。\n        通过汇聚各种设计精良的 Nginx 模块（主要由 OpenResty 团队自主开发），从而将 Nginx 有效地变成一个强大的通用 Web 应用平台。\n        这样，Web 开发人员和系统工程师可以使用 Lua 脚本语言调动 Nginx 支持的各种 C 以及 Lua 模块，快速构造出足以胜任 10K 乃至 1000K 以上单机并发连接的高性能 Web 应用系统。\n        OpenResty的目标是让你的Web服务直接跑在 Nginx 服务内部，充分利用 Nginx 的非阻塞 I/O 模型，不仅仅对 HTTP 客户端请求,\n        甚至于对远程后端诸如 MySQL、PostgreSQL、Memcached 以及 Redis 等都进行一致的高性能响应。\n\n## 安装\n    1）下载安装\n    centos系统\n    # yum install readline-devel pcre pcre-devel openssl openssl-devel gcc curl GeoIP-devel\n    下载源码包\n    https://github.com/openresty/openresty/releases\n    选择最新版本v1.13.6.1\n    解压安装\n    # tar -xzvf openresty-1.13.6.1.tar.gz\n    # cd openresty-1.13.6.1/\n    \n    ##选择模块 ./configure --help\n    \n    # ./configure --with-luajit --with-pcre --with-http_gzip_static_module --with-http_realip_module --with-http_geoip_module --with-http_ssl_module  --with-http_stub_status_module \n    \n    --with-http_gzip_static_module #静态文件压缩\n    --with-http_stub_status_module #监控nginx状态\n    --with-http_realip_module #通过这个模块允许我们改变客户端请求头中客户端IP地址值(例如X-Real-IP 或 X-Forwarded-For)，意义在于能够使得后台服务器记录原始客户端的IP地址\n    --with-pcre #设置PCRE库（pcre pcre-devel）\n    --with-http_ssl_module #使用https协议模块。（openssl openssl-devel）\n    --with-http_geoip_module #增加了根据ip获得城市信息，经纬度等模块 （GeoIP-devel）\n    \n    # make && make install\n    \n    2）安装成功后，默认会在/usr/local/openresty/\n    目录下\n    luajit 是采用C语言写的Lua代码的解释器 ----just in time   即时解析\n    lualib 是编辑好的lua类库\n    nginx，其实我们openResty就是nginx，只是做了一些模块化工作；所以启动openResty就是启动nginx，我们可以到 cd nginx/sbin/，直接运行  ./nginx\n    \n    3）设置环境变量\n    # vi /etc/profile\n    export NGINX_HOME=/usr/local/openresty/nginx\n    export PATH=$PATH:$NGINX_HOME/sbin\n    # source /etc/profile ##生效\n\n## 简单例子 -- Hello World\n    1）ngx_lua模块的hello world\n    编辑nginx下conf配置文件nginx.conf\n    # vi nginx.conf\n    在server模块加上\n    location /helloworld {\n    \tdefault_type text/html;\n        content_by_lua 'ngx.say(\"hello world\")';\n    }\n    \n    检查配置文件是否正确\n    # /usr/local/openresty/nginx/sbin/nginx -t -c /usr/local/openresty/nginx/conf/nginx.conf\n    \n    重启nginx\n    # ./nginx -s reload\n    访问http://192.168.31.138/helloworld  输出 hello world\n    \n    2）nginx的内部变量\n    \n    名称 说明\n    $arg_name 请求中的name参数\n    $args 请求中的参数\n    $binary_remote_addr 远程地址的二进制表示\n    $body_bytes_sent 已发送的消息体字节数\n    $content_length HTTP请求信息里的\"Content-Length\"\n    $content_type 请求信息里的\"Content-Type\"\n    $document_root 针对当前请求的根路径设置值\n    $document_uri 与$uri相同; 比如 /test2/test.php\n    $host 请求信息中的\"Host\"，如果请求中没有Host行，则等于设置的服务器名\n    $hostname 机器名使用 gethostname系统调用的值\n    $http_cookie cookie 信息\n    $http_referer 引用地址\n    $http_user_agent 客户端代理信息\n    $http_via 最后一个访问服务器的Ip地址。\n    $http_x_forwarded_for 相当于网络访问路径\n    $is_args 如果请求行带有参数，返回“?”，否则返回空字符串\n    $limit_rate 对连接速率的限制\n    $nginx_version 当前运行的nginx版本号\n    $pid worker进程的PID\n    $query_string 与$args相同\n    $realpath_root 按root指令或alias指令算出的当前请求的绝对路径。其中的符号链接都会解析成真是文件路径\n    $remote_addr 客户端IP地址\n    $remote_port 客户端端口号\n    $remote_user 客户端用户名，认证用\n    $request 用户请求\n    $request_body 这个变量（0.7.58+）包含请求的主要信息。在使用proxy_pass或fastcgi_pass指令的location中比较有意义\n    $request_body_file 客户端请求主体信息的临时文件名\n    $request_completion 如果请求成功，设为\"OK\"；如果请求未完成或者不是一系列请求中最后一部分则设为空\n    $request_filename 当前请求的文件路径名，比如/opt/nginx/www/test.php\n    $request_method 请求的方法，比如\"GET\"、\"POST\"等\n    $request_uri 请求的URI，带参数; 比如http://localhost:88/test1/\n    $scheme 所用的协议，比如http或者是https\n    $server_addr 服务器地址，如果没有用listen指明服务器地址，使用这个变量将发起一次系统调用以取得地址(造成资源浪费)\n    $server_name 请求到达的服务器名\n    $server_port 请求到达的服务器端口号\n    $server_protocol 请求的协议版本，\"HTTP/1.0\"或\"HTTP/1.1\"\n    $uri 请求的URI，可能和最初的值有不同，比如经过重定向之类的\n    \n    \n    写个配置文件，测试一下$uri变量\n    location /test_url {\n    \techo \"url:$uri\";\n    }\n    \n    location /test_url {\n    \t\t\techo \"url:$uri\";\n    \t\t\techo \"full url : $host$request_uri\";\n    \t\t}\n    \t\t\n    重启nginx，访问\n    \n    再此基础上测试$args变量\n    location /test_url {\n    \techo \"url:$uri----args:$args\";\n    }\n    \n    再此基础上测试$arg_name变量\n    location /test_url {\n    \techo \"url:$uri----args:$args--------arg_name:$arg_name\";\n    }\n    \n    说明一下，$arg_name表示取名为name的参数，如果想取其他名称的参数可以对应的取该参数名\n    location /test_url {\n    \techo \"url:$uri --- args:$args --- arg_name:$arg_name <br/>\";\n    \techo \"arg_user:$arg_user --- arg_age:$arg_age<br/>\";\n    \techo \"arg_test:$arg_test\";\n    }\n    \n    test参数名不存在，则为空。\n    自定义变量\n    location /test_def {\n    \tset $name \"rainbow\";\n    \techo $name;\n    }\n    \n    set 设置的变量 为局部变量，其他请求无法获取此$name的值\n    location /test_def {\n    \tset $name \"rainbow\";\n    \techo_exec /test_def2;  ##内部跳转，可以传递变量\n    }\n    location /test_def2 {\n    \techo $name;\n    }\n\n## Openresty中使用Lua\n    openresty 引入 lua\n    \n    一）openresty中nginx引入lua方式\n    \n      1）xxx_by_lua   --->字符串编写方式\n      2) xxx_by_lua_block ---->代码块方式\n      3) xxx_by_lua_file  ---->直接引用一个lua脚本文件\n    \n    我们案例中使用内容处理阶段，用content_by_lua演示\n    \n    -----------------编辑nginx.conf-----------------------\n    \n    第一种：content_by_lua\n    \n    location /testlua {\n      content_by_lua \"ngx.say('hello world')\";\n    }\n    \n    输出了hello world\n    \n    content_by_lua 方式，参数为字符串，编写不是太方便。\n    \n    ----------------------------------------\n    \n    第二种：content_by_lua_block\n    location /testlua {\n      content_by_lua_block {\n           ngx.say(\"hello world\");\n      } \n    }\n    \n    content_by_lua_block {}  表示内部为lua块，里面可以应用lua语句\n    \n    ----------------------------------------\n    \n    第三种：content_by_lua_file\n    \n    location /testlua {\n      content_by_lua_file /usr/local/lua/test.lua;\n    }\n    \n    content_by_lua_file 就是引用外部lua文件\n    \n    # vi  test.lua\n    ngx.say(\"hello world\");\n    \n    \n    二）openresty使用lua打印输出案例\n    \n      location /testsay {\n        content_by_lua_block {\n            --写响应头  \n            ngx.header.a = \"1\"  \n            ngx.header.b = \"2\" \n            --输出响应  \n            ngx.say(\"a\", \"b\", \"<br/>\")  \n            ngx.print(\"c\", \"d\", \"<br/>\")  \n            --200状态码退出  \n            return ngx.exit(200) \n        } \n      }\n    \n      ngx.header：输出响应头；\n      ngx.print：输出响应内容体；\n      ngx.say：通ngx.print，但是会最后输出一个换行符；\n      ngx.exit：指定状态码退出。\n    \n    三）介绍一下openresty使用lua常用的api\n    \n    1）ngx.var ： 获取Nginx变量 和 内置变量\n    \n    nginx内置的变量\n    \n    $arg_name 请求中的name参数\n    $args 请求中的参数\n    $binary_remote_addr 远程地址的二进制表示\n    $body_bytes_sent  已发送的消息体字节数\n    $content_length HTTP请求信息里的\"Content-Length\"\n    $content_type 请求信息里的\"Content-Type\"\n    $document_root  针对当前请求的根路径设置值\n    $document_uri 与$uri相同; 比如 /test2/test.php\n    $host 请求信息中的\"Host\"，如果请求中没有Host行，则等于设置的服务器名\n    $hostname 机器名使用 gethostname系统调用的值\n    $http_cookie  cookie 信息\n    $http_referer 引用地址\n    $http_user_agent  客户端代理信息\n    $http_via 最后一个访问服务器的Ip地址。\n    $http_x_forwarded_for 相当于网络访问路径\n    $is_args  如果请求行带有参数，返回“?”，否则返回空字符串\n    $limit_rate 对连接速率的限制\n    $nginx_version  当前运行的nginx版本号\n    $pid  worker进程的PID\n    $query_string 与$args相同\n    $realpath_root  按root指令或alias指令算出的当前请求的绝对路径。其中的符号链接都会解析成真是文件路径\n    $remote_addr  客户端IP地址\n    $remote_port  客户端端口号\n    $remote_user  客户端用户名，认证用\n    $request  用户请求\n    $request_body 这个变量（0.7.58+）包含请求的主要信息。在使用proxy_pass或fastcgi_pass指令的location中比较有意义\n    $request_body_file  客户端请求主体信息的临时文件名\n    $request_completion 如果请求成功，设为\"OK\"；如果请求未完成或者不是一系列请求中最后一部分则设为空\n    $request_filename 当前请求的文件路径名，比如/opt/nginx/www/test.php\n    $request_method 请求的方法，比如\"GET\"、\"POST\"等\n    $request_uri  请求的URI，带参数; 比如http://localhost:88/test1/\n    $scheme 所用的协议，比如http或者是https\n    $server_addr  服务器地址，如果没有用listen指明服务器地址，使用这个变量将发起一次系统调用以取得地址(造成资源浪费)\n    $server_name  请求到达的服务器名\n    $server_port  请求到达的服务器端口号\n    $server_protocol  请求的协议版本，\"HTTP/1.0\"或\"HTTP/1.1\"\n    $uri  请求的URI，可能和最初的值有不同，比如经过重定向之类的\n    \n    ngx.var.xxx\n    \n    location /var {\n        set $c 3;\n    \n        #处理业务\n        content_by_lua_block {\n          local a = tonumber(ngx.var.arg_a) or 0\n          local b = tonumber(ngx.var.arg_b) or 0\n          local c = tonumber(ngx.var.c) or 0\n          ngx.say(\"sum:\", a + b + c )\n        }\n    }\n    \n    注意：ngx.var.c 此变量必须提前声明；\n    另外对于nginx location中使用正则捕获的捕获组可以使用ngx.var[捕获组数字]获取；\n    \n    location ~ ^/var/([0-9]+) {\n       content_by_lua_block {\n        ngx.say(\"var[1]:\", ngx.var[1] )\n      }\n    }\n    \n    2）ngx.req请求模块的常用api\n    \n       ngx.req.get_headers：获取请求头，\n       获取带中划线的请求头时请使用如headers.user_agent这种方式；如果一个请求头有多个值，则返回的是table；\n    \n    -----------test.lua-------------------\n    \n    local headers = ngx.req.get_headers()  \n    ngx.say(\"============headers begin===============\", \"<br/>\")  \n    ngx.say(\"Host : \", headers[\"Host\"], \"<br/>\")  \n    ngx.say(\"headers['user-agent'] : \", headers[\"user-agent\"], \"<br/>\")  \n    ngx.say(\"headers.user_agent : \", headers.user_agent, \"<br/>\") \n    ngx.say(\"-------------遍历headers-----------\", \"<br/>\") \n    for k,v in pairs(headers) do  \n        if type(v) == \"table\" then  \n            ngx.say(k, \" : \", table.concat(v, \",\"), \"<br/>\")  \n        else  \n            ngx.say(k, \" : \", v, \"<br/>\")  \n        end  \n    end  \n    ngx.say(\"===========headers end============\", \"<br/>\")  \n    ngx.say(\"<br/>\")  \n    \n    \n    \n    3）获取请求参数\n      ngx.req.get_uri_args：获取url请求参数，其用法和get_headers类似；\n      ngx.req.get_post_args：获取post请求内容体，其用法和get_headers类似，\n                             但是必须提前调用ngx.req.read_body()来读取body体\n                             （也可以选择在nginx配置文件使用lua_need_request_body on;开启读取body体，\n                               但是官方不推荐）；\n    \n      ngx.req.get_body_data：为解析的请求body体内容字符串。\n    \n    ---------------test.lua---------------\n    \n    --get请求uri参数  \n    ngx.say(\"===========uri get args begin==================\", \"<br/>\")  \n    local uri_args = ngx.req.get_uri_args()  \n    for k, v in pairs(uri_args) do  \n        if type(v) == \"table\" then  \n            ngx.say(k, \" : \", table.concat(v, \", \"), \"<br/>\")  \n        else  \n            ngx.say(k, \": \", v, \"<br/>\")  \n        end  \n    end  \n    ngx.say(\"===========uri get args end==================\", \"<br/>\") \n      \n    --post请求参数  \n    ngx.req.read_body()  \n    ngx.say(\"=================post args begin====================\", \"<br/>\")  \n    local post_args = ngx.req.get_post_args()  \n    for k, v in pairs(post_args) do  \n        if type(v) == \"table\" then  \n            ngx.say(k, \" : \", table.concat(v, \", \"), \"<br/>\")  \n        else  \n            ngx.say(k, \": \", v, \"<br/>\")  \n        end  \n    end  \n    ngx.say(\"================post args end=====================\", \"<br/>\")  \n      \n    \n    4) ngx.req其他常用的api\n    --请求的http协议版本  \n    ngx.say(\"ngx.req.http_version : \", ngx.req.http_version(), \"<br/>\")  \n    --请求方法  \n    ngx.say(\"ngx.req.get_method : \", ngx.req.get_method(), \"<br/>\")  \n    --原始的请求头内容  \n    ngx.say(\"ngx.req.raw_header : \",  ngx.req.raw_header(), \"<br/>\")  \n    --请求的body内容体  \n    ngx.say(\"ngx.req.get_body_data() : \", ngx.req.get_body_data(), \"<br/>\")  \n    ngx.say(\"<br/>\")  \n    \n    ngx.req.raw_header()这个函数返回值为字符串\n    \n    5）编码解码\n    \n    ngx.escape_uri/ngx.unescape_uri ： uri编码解码；\n    \n    ngx.encode_args/ngx.decode_args：参数编码解码；\n    \n    ngx.encode_base64/ngx.decode_base64：BASE64编码解码；\n    \n    -------test.lua\n    \n    --未经解码的请求uri  \n    local request_uri = ngx.var.request_uri;  \n    ngx.say(\"request_uri : \", request_uri, \"<br/>\"); \n    \n    --编码\n    local escape_uri = ngx.escape_uri(request_uri)\n    ngx.say(\"escape_uri : \", escape_uri, \"<br/>\"); \n    \n    --解码  \n    ngx.say(\"decode request_uri : \", ngx.unescape_uri(escape_uri), \"<br/>\");\n    \n    --参数编码\n    local request_uri = ngx.var.request_uri;\n    local question_pos, _ = string.find(request_uri, '?')\n    if question_pos>0 then\n      local uri = string.sub(request_uri, 1, question_pos-1)\n      ngx.say(\"uri sub=\",string.sub(request_uri, question_pos+1),\"<br/>\");\n      \n      --对字符串进行解码\n      local args = ngx.decode_args(string.sub(request_uri, question_pos+1))\n      \n      for k,v in pairs(args) do\n        ngx.say(\"k=\",k,\",v=\", v, \"<br/>\");\n      end\n      \n      if args and args.userId then\n        args.userId = args.userId + 10000\n        ngx.say(\"args+10000 : \", uri .. '?' .. ngx.encode_args(args), \"<br/>\");\n      end\n    end\n    \n    6）md5加密api\n    --MD5  \n    ngx.say(\"ngx.md5 : \", ngx.md5(\"123\"), \"<br/>\")  \n    \n    7）nginx获取时间\n    \n    之前介绍的os.time()会涉及系统调用，性能比较差，推荐使用nginx中的时间api\n    \n    ngx.time()  --返回秒级精度的时间戳\n    ngx.now()   --返回毫秒级精度的时间戳\n    \n    就是通过这两种方式获取到的只是nginx缓存起来的时间戳，不是实时的。\n    所以有时候会出现一些比较奇怪的现象，比如下面代码：\n    \n    local t1 = ngx.now()\n    for i=1,1000000 do\n    end\n    local t2 = ngx.now()\n    print(t1, \",\", t2) -- t1和t2的值是一样的，why？\n    ngx.exit(200)\n    \n    正常来说，t2应该大于t1才对，但由于nginx没有及时更新（缓存的）时间戳，所以导致t2和t1获取到的时间戳是一样的。\n    那么怎样才能强迫nginx更新缓存呢？调用多一个ngx.update_time()函数即可：\n    \n    local t1 = ngx.now()\n    for i=1,1000000 do\n    end\n    ngx.update_time()\n    local t2 = ngx.now()\n    print(t1, \",\", t2) \n    ngx.exit(200)\n    \n    8）ngx.re模块中正则表达式相关的api\n    \n    ngx.re.match\n    ngx.re.sub\n    ngx.re.gsub\n    ngx.re.find\n    ngx.re.gmatch\n    \n    我们这里只简单的介绍 ngx.re.match，详细用法可以自行去网上学习\n    \n    ngx.re.match\n    只有第一次匹配的结果被返回，如果没有匹配，则返回nil；或者匹配过程中出现错误时，\n    也会返回nil，此时错误信息会被保存在err中。\n    \n    当匹配的字符串找到时，一个Lua table captures会被返回，\n    captures[0]中保存的就是匹配到的字串，\n    captures[1]保存的是用括号括起来的第一个子模式（捕获分组）的结果，\n    captures[2]保存的是第二个子模式（捕获分组）的结果，依次类似。\n    \n    ---------------------\n    \n    local m, err = ngx.re.match(\"hello, 1234\", \"[0-9]+\")\n    if m then\n      ngx.say(m[0])\n    else\n      if err then\n        ngx.log(ngx.ERR, \"error: \", err)\n        return\n      end\n    \n      ngx.say(\"match not found\")\n    end\n    \n    上面例子中，匹配的字符串是1234，因此m[0] == \"1234\"，\n    --------------\n    \n    local m, err = ngx.re.match(\"hello, 1234\", \"([0-9])[0-9]+\")\n    ngx.say(m[0],\"<br/>\")\n    ngx.say(m[1])\n    \n    \n    ---------------------------------------------------------\n    \n    \n    备注：有没有注意到，我们每次修改都要重启nginx，这样太过于麻烦，我们可以用\n    content_by_lua_file 引入外部lua，这样的话 只要修改外部的lua，就可以了，不需要重启nginx了。\n    注意需要把lua_code_cache 设置为off\n    \n    语法：lua_code_cache on | off\n    默认： on\n    适用上下文：http、server、location、location if\n    这个指令是指定是否开启lua的代码编译缓存，开发时可以设置为off，以便lua文件实时生效，\n    如果是生产线上，为了性能，建议开启。\n    最终nginx.conf修改为\n    \n    以后我们只要修改test.lua 文件就可以了。\n    \n    9）标准日志输出\n    \n    ngx.log(log_level, ...) \n    \n    日志输出级别\n    \n    ngx.STDERR     -- 标准输出\n    ngx.EMERG      -- 紧急报错\n    ngx.ALERT      -- 报警\n    ngx.CRIT       -- 严重，系统故障，触发运维告警系统\n    ngx.ERR        -- 错误，业务不可恢复性错误\n    ngx.WARN       -- 告警，业务中可忽略错误\n    ngx.NOTICE     -- 提醒，业务比较重要信息\n    ngx.INFO       -- 信息，业务琐碎日志信息，包含不同情况判断等\n    ngx.DEBUG      -- 调试\n    \n    -------------------------------------\n    \n    #user  nobody;\n    worker_processes  1;\n    \n    error_log  logs/error.log error;    # 日志级别\n    #pid        logs/nginx.pid;\n    \n    events {\n        worker_connections  1024;\n    }\n    \n    http {\n        server {\n            listen    80;\n            location / {\n                content_by_lua_block {\n                    local num = 55\n                    local str = \"string\"\n                    local obj\n                    ngx.log(ngx.ERR, \"num:\", num)\n                    ngx.log(ngx.INFO, \" string:\", str)\n                    print([[i am print]])\n                    ngx.log(ngx.ERR, \" object:\", obj)\n                }\n            }\n        }\n    }\n    \n    日志输出级别使用的 error，只有等于或大于这个级别的日志才会输出\n    \n    ngx.DEBUG\n    ngx.WARN\n    \n    对于应用开发，一般使用 ngx.INFO 到 ngx.CRIT 就够了。生产中错误日志开启到 error 级别就够了\n    \n    10）重定向 ngx.redirect\n    \n    -----重定向\n    \n    location = /bar {\n      content_by_lua_block {\n        ngx.say([[I am bar]])\n      }\n    }\n    \n    location = /foo {\n      rewrite_by_lua_block {\n        return ngx.redirect('/bar');\n      }\n    }\n    \n    \n    11）不同阶段共享变量\n    \n    ngx.ctx 全局共享变量\n    \n    在 OpenResty 的体系中，可以通过共享内存的方式完成不同工作进程的数据共享，\n    本地内存方式 去让不同的工作进程共享数据\n    \n    openresty有不同处理阶段，后面的课程会介绍。在不同的处理阶段，如何共享数据\n    \n    可以通过 Lua 模块方式完成单个进程内不同请求的数据共享。如何完成单个请求内不同阶段的数据共享呢？\n    \n    ngx.ctx 表就是为了解决这类问题而设计的。参考下面例子：\n    \n    location /test {\n         rewrite_by_lua_block {\n             ngx.ctx.foo = 76\n         }\n         access_by_lua_block {\n             ngx.ctx.foo = ngx.ctx.foo + 3\n         }\n         content_by_lua_block {\n             ngx.say(ngx.ctx.foo)\n         }\n     }\n    \n     ngx.ctx.xxxxx\n    \n    首先 ngx.ctx 是一个表，所以我们可以对他添加、修改。它用来存储基于请求的 Lua 环境数据，\n    其生存周期与当前请求相同 (类似 Nginx 变量)。它有一个最重要的特性：\n    单个请求内的 rewrite (重写)，access (访问)，和 content (内容) 等各处理阶段是保持一致的。\n    \n    额外注意，每个请求，包括子请求，都有一份自己的 ngx.ctx 表。例如：\n    \n     location /sub {\n         content_by_lua_block {\n             ngx.say(\"sub pre: \", ngx.ctx.blah)\n             ngx.ctx.blah = 32\n             ngx.say(\"sub post: \", ngx.ctx.blah)\n         }\n     }\n    \n     location /main {\n         content_by_lua_block {\n             ngx.ctx.blah = 73\n             ngx.say(\"main pre: \", ngx.ctx.blah)\n             local res = ngx.location.capture(\"/sub\")\n             ngx.print(res.body)\n             ngx.say(\"main post: \", ngx.ctx.blah)\n         }\n     }\n    \n    ngx.ctx 表查询需要相对昂贵的元方法调用，这比通过用户自己的函数参数直接传递基于请求的数据要慢得多。\n    所以不要为了节约用户函数参数而滥用此 API，因为它可能对性能有明显影响。\n    \n    由于 ngx.ctx 保存的是指定请求资源，所以这个变量是不能直接共享给其他请求使用的。\n    \n    \n    更多api使用  https://www.nginx.com/resources/wiki/modules/lua/#nginx-api-for-lua\n    \n    操作指令  说明\n    ngx.arg 指令参数，如跟在content_by_lua_file后面的参数\n    ngx.var 变量，ngx.var.VARIABLE引用某个变量\n    ngx.ctx 请求的lua上下文\n    ngx.header  响应头，ngx.header.HEADER引用某个头\n    ngx.status  响应码\n    \n    API 说明\n    ngx.log 输出到error.log\n    print 等价于 ngx.log(ngx.NOTICE, ...)\n    ngx.send_headers  发送响应头\n    ngx.headers_sent  响应头是否已发送\n    ngx.resp.get_headers  获取响应头\n    ngx.timer.at  注册定时器事件\n    ngx.is_subrequest 当前请求是否是子请求\n    ngx.location.capture  发布一个子请求\n    ngx.location.capture_multi  发布多个子请求\n    ngx.exec   \n    ngx.redirect   \n    ngx.print 输出响应\n    ngx.say 输出响应，自动添加'n'\n    ngx.flush 刷新响应\n    ngx.exit  结束请求\n    ngx.eof  \n    ngx.sleep 无阻塞的休眠（使用定时器实现）\n    ngx.get_phase  \n    ngx.on_abort  注册client断开请求时的回调函数\n    ndk.set_var.DIRECTIVE  \n    ngx.req.start_time  请求的开始时间\n    ngx.req.http_version  请求的HTTP版本号\n    ngx.req.raw_header  请求头（包括请求行）\n    ngx.req.get_method  请求方法\n    ngx.req.set_method  请求方法重载\n    ngx.req.set_uri 请求URL重写\n    ngx.req.set_uri_args   \n    ngx.req.get_uri_args  获取请求参数\n    ngx.req.get_post_args 获取请求表单\n    ngx.req.get_headers 获取请求头\n    ngx.req.set_header   \n    ngx.req.clear_header   \n    ngx.req.read_body 读取请求体\n    ngx.req.discard_body  扔掉请求体\n    ngx.req.get_body_data  \n    ngx.req.get_body_file  \n    ngx.req.set_body_data  \n    ngx.req.set_body_file  \n    ngx.req.init_body  \n    ngx.req.append_body  \n    ngx.req.finish_body  \n    ngx.req.socket   \n    ngx.escape_uri  字符串的url编码\n    ngx.unescape_uri  字符串url解码\n    ngx.encode_args 将table编码为一个参数字符串\n    ngx.decode_args 将参数字符串编码为一个table\n    ngx.encode_base64 字符串的base64编码\n    ngx.decode_base64 字符串的base64解码\n    ngx.crc32_short 字符串的crs32_short哈希\n    ngx.crc32_long  字符串的crs32_long哈希\n    ngx.hmac_sha1 字符串的hmac_sha1哈希\n    ngx.md5 返回16进制MD5\n    ngx.md5_bin 返回2进制MD5\n    ngx.sha1_bin  返回2进制sha1哈希值\n    ngx.quote_sql_str SQL语句转义\n    ngx.today 返回当前日期\n    ngx.time  返回UNIX时间戳\n    ngx.now 返回当前时间\n    ngx.update_time 刷新时间后再返回\n    ngx.localtime  \n    ngx.utctime  \n    ngx.cookie_time 返回的时间可用于cookie值\n    ngx.http_time 返回的时间可用于HTTP头\n    ngx.parse_http_time 解析HTTP头的时间\n    ngx.re.match   \n    ngx.re.find  \n    ngx.re.gmatch  \n    ngx.re.sub   \n    ngx.re.gsub  \n    ngx.shared.DICT  \n    ngx.shared.DICT.get  \n    ngx.shared.DICT.get_stale  \n    ngx.shared.DICT.set  \n    ngx.shared.DICT.safe_set   \n    ngx.shared.DICT.add  \n    ngx.shared.DICT.safe_add   \n    ngx.shared.DICT.replace  \n    ngx.shared.DICT.delete   \n    ngx.shared.DICT.incr   \n    ngx.shared.DICT.flush_all  \n    ngx.shared.DICT.flush_expired  \n    ngx.shared.DICT.get_keys   \n    ngx.socket.udp   \n    udpsock:setpeername  \n    udpsock:send   \n    udpsock:receive  \n    udpsock:close  \n    udpsock:settimeout   \n    ngx.socket.tcp   \n    tcpsock:connect  \n    tcpsock:sslhandshake   \n    tcpsock:send   \n    tcpsock:receive  \n    tcpsock:receiveuntil   \n    tcpsock:close  \n    tcpsock:settimeout   \n    tcpsock:setoption  \n    tcpsock:setkeepalive   \n    tcpsock:getreusedtimes   \n    ngx.socket.connect   \n    ngx.thread.spawn   \n    ngx.thread.wait  \n    ngx.thread.kill  \n    coroutine.create   \n    coroutine.resume   \n    coroutine.yield  \n    coroutine.wrap   \n    coroutine.running  \n    coroutine.status   \n    ngx.config.debug  编译时是否有 --with-debug选项\n    ngx.config.prefix 编译时的 --prefix选项\n    ngx.config.nginx_version  返回nginx版本号\n    ngx.config.nginx_configure  返回编译时 ./configure的命令行选项\n    ngx.config.ngx_lua_version  返回ngx_lua模块版本号\n    ngx.worker.exiting  当前worker进程是否正在关闭（如reload、shutdown期间）\n    ngx.worker.pid  返回当前worker进程的pid\n       \n    常量说明\n    ngx.OK (0)\n    ngx.ERROR (-1)\n    ngx.AGAIN (-2)\n    ngx.DONE (-4)\n    ngx.DECLINED (-5)\n    ngx.nil\n    \n    \n    HTTP 请求方式\n    ngx.HTTP_GET\n    ngx.HTTP_HEAD\n    ngx.HTTP_PUT\n    ngx.HTTP_POST\n    ngx.HTTP_DELETE\n    ngx.HTTP_OPTIONS  \n    ngx.HTTP_MKCOL    \n    ngx.HTTP_COPY      \n    ngx.HTTP_MOVE     \n    ngx.HTTP_PROPFIND \n    ngx.HTTP_PROPPATCH \n    ngx.HTTP_LOCK \n    ngx.HTTP_UNLOCK    \n    ngx.HTTP_PATCH   \n    ngx.HTTP_TRACE  \n    \n    \n    HTTP 返回状态\n    ngx.HTTP_OK (200)\n    ngx.HTTP_CREATED (201)\n    ngx.HTTP_SPECIAL_RESPONSE (300)\n    ngx.HTTP_MOVED_PERMANENTLY (301)\n    ngx.HTTP_MOVED_TEMPORARILY (302)\n    ngx.HTTP_SEE_OTHER (303)\n    ngx.HTTP_NOT_MODIFIED (304)\n    ngx.HTTP_BAD_REQUEST (400)\n    ngx.HTTP_UNAUTHORIZED (401)\n    ngx.HTTP_FORBIDDEN (403)\n    ngx.HTTP_NOT_FOUND (404)\n    ngx.HTTP_NOT_ALLOWED (405)\n    ngx.HTTP_GONE (410)\n    ngx.HTTP_INTERNAL_SERVER_ERROR (500)\n    ngx.HTTP_METHOD_NOT_IMPLEMENTED (501)\n    ngx.HTTP_SERVICE_UNAVAILABLE (503)\n    ngx.HTTP_GATEWAY_TIMEOUT (504) \n\n","source":"_posts/微服务API网关框架-6.md","raw":"---\ntitle: 微服务API网关框架(6)--OpenResty介绍与简单使用\ncatalog: true\ndate: 2018-12-20 11:40:48\nsubtitle:\nheader-img: \"Demo.png\"\ntags:\n- 微服务API网关\ncatagories:\n- 微服务API网关\n---\n\n# OpenResty\n\n## 介绍\n    OpenResty\n        是一个基于 Nginx 与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。\n        用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。\n        通过汇聚各种设计精良的 Nginx 模块（主要由 OpenResty 团队自主开发），从而将 Nginx 有效地变成一个强大的通用 Web 应用平台。\n        这样，Web 开发人员和系统工程师可以使用 Lua 脚本语言调动 Nginx 支持的各种 C 以及 Lua 模块，快速构造出足以胜任 10K 乃至 1000K 以上单机并发连接的高性能 Web 应用系统。\n        OpenResty的目标是让你的Web服务直接跑在 Nginx 服务内部，充分利用 Nginx 的非阻塞 I/O 模型，不仅仅对 HTTP 客户端请求,\n        甚至于对远程后端诸如 MySQL、PostgreSQL、Memcached 以及 Redis 等都进行一致的高性能响应。\n\n## 安装\n    1）下载安装\n    centos系统\n    # yum install readline-devel pcre pcre-devel openssl openssl-devel gcc curl GeoIP-devel\n    下载源码包\n    https://github.com/openresty/openresty/releases\n    选择最新版本v1.13.6.1\n    解压安装\n    # tar -xzvf openresty-1.13.6.1.tar.gz\n    # cd openresty-1.13.6.1/\n    \n    ##选择模块 ./configure --help\n    \n    # ./configure --with-luajit --with-pcre --with-http_gzip_static_module --with-http_realip_module --with-http_geoip_module --with-http_ssl_module  --with-http_stub_status_module \n    \n    --with-http_gzip_static_module #静态文件压缩\n    --with-http_stub_status_module #监控nginx状态\n    --with-http_realip_module #通过这个模块允许我们改变客户端请求头中客户端IP地址值(例如X-Real-IP 或 X-Forwarded-For)，意义在于能够使得后台服务器记录原始客户端的IP地址\n    --with-pcre #设置PCRE库（pcre pcre-devel）\n    --with-http_ssl_module #使用https协议模块。（openssl openssl-devel）\n    --with-http_geoip_module #增加了根据ip获得城市信息，经纬度等模块 （GeoIP-devel）\n    \n    # make && make install\n    \n    2）安装成功后，默认会在/usr/local/openresty/\n    目录下\n    luajit 是采用C语言写的Lua代码的解释器 ----just in time   即时解析\n    lualib 是编辑好的lua类库\n    nginx，其实我们openResty就是nginx，只是做了一些模块化工作；所以启动openResty就是启动nginx，我们可以到 cd nginx/sbin/，直接运行  ./nginx\n    \n    3）设置环境变量\n    # vi /etc/profile\n    export NGINX_HOME=/usr/local/openresty/nginx\n    export PATH=$PATH:$NGINX_HOME/sbin\n    # source /etc/profile ##生效\n\n## 简单例子 -- Hello World\n    1）ngx_lua模块的hello world\n    编辑nginx下conf配置文件nginx.conf\n    # vi nginx.conf\n    在server模块加上\n    location /helloworld {\n    \tdefault_type text/html;\n        content_by_lua 'ngx.say(\"hello world\")';\n    }\n    \n    检查配置文件是否正确\n    # /usr/local/openresty/nginx/sbin/nginx -t -c /usr/local/openresty/nginx/conf/nginx.conf\n    \n    重启nginx\n    # ./nginx -s reload\n    访问http://192.168.31.138/helloworld  输出 hello world\n    \n    2）nginx的内部变量\n    \n    名称 说明\n    $arg_name 请求中的name参数\n    $args 请求中的参数\n    $binary_remote_addr 远程地址的二进制表示\n    $body_bytes_sent 已发送的消息体字节数\n    $content_length HTTP请求信息里的\"Content-Length\"\n    $content_type 请求信息里的\"Content-Type\"\n    $document_root 针对当前请求的根路径设置值\n    $document_uri 与$uri相同; 比如 /test2/test.php\n    $host 请求信息中的\"Host\"，如果请求中没有Host行，则等于设置的服务器名\n    $hostname 机器名使用 gethostname系统调用的值\n    $http_cookie cookie 信息\n    $http_referer 引用地址\n    $http_user_agent 客户端代理信息\n    $http_via 最后一个访问服务器的Ip地址。\n    $http_x_forwarded_for 相当于网络访问路径\n    $is_args 如果请求行带有参数，返回“?”，否则返回空字符串\n    $limit_rate 对连接速率的限制\n    $nginx_version 当前运行的nginx版本号\n    $pid worker进程的PID\n    $query_string 与$args相同\n    $realpath_root 按root指令或alias指令算出的当前请求的绝对路径。其中的符号链接都会解析成真是文件路径\n    $remote_addr 客户端IP地址\n    $remote_port 客户端端口号\n    $remote_user 客户端用户名，认证用\n    $request 用户请求\n    $request_body 这个变量（0.7.58+）包含请求的主要信息。在使用proxy_pass或fastcgi_pass指令的location中比较有意义\n    $request_body_file 客户端请求主体信息的临时文件名\n    $request_completion 如果请求成功，设为\"OK\"；如果请求未完成或者不是一系列请求中最后一部分则设为空\n    $request_filename 当前请求的文件路径名，比如/opt/nginx/www/test.php\n    $request_method 请求的方法，比如\"GET\"、\"POST\"等\n    $request_uri 请求的URI，带参数; 比如http://localhost:88/test1/\n    $scheme 所用的协议，比如http或者是https\n    $server_addr 服务器地址，如果没有用listen指明服务器地址，使用这个变量将发起一次系统调用以取得地址(造成资源浪费)\n    $server_name 请求到达的服务器名\n    $server_port 请求到达的服务器端口号\n    $server_protocol 请求的协议版本，\"HTTP/1.0\"或\"HTTP/1.1\"\n    $uri 请求的URI，可能和最初的值有不同，比如经过重定向之类的\n    \n    \n    写个配置文件，测试一下$uri变量\n    location /test_url {\n    \techo \"url:$uri\";\n    }\n    \n    location /test_url {\n    \t\t\techo \"url:$uri\";\n    \t\t\techo \"full url : $host$request_uri\";\n    \t\t}\n    \t\t\n    重启nginx，访问\n    \n    再此基础上测试$args变量\n    location /test_url {\n    \techo \"url:$uri----args:$args\";\n    }\n    \n    再此基础上测试$arg_name变量\n    location /test_url {\n    \techo \"url:$uri----args:$args--------arg_name:$arg_name\";\n    }\n    \n    说明一下，$arg_name表示取名为name的参数，如果想取其他名称的参数可以对应的取该参数名\n    location /test_url {\n    \techo \"url:$uri --- args:$args --- arg_name:$arg_name <br/>\";\n    \techo \"arg_user:$arg_user --- arg_age:$arg_age<br/>\";\n    \techo \"arg_test:$arg_test\";\n    }\n    \n    test参数名不存在，则为空。\n    自定义变量\n    location /test_def {\n    \tset $name \"rainbow\";\n    \techo $name;\n    }\n    \n    set 设置的变量 为局部变量，其他请求无法获取此$name的值\n    location /test_def {\n    \tset $name \"rainbow\";\n    \techo_exec /test_def2;  ##内部跳转，可以传递变量\n    }\n    location /test_def2 {\n    \techo $name;\n    }\n\n## Openresty中使用Lua\n    openresty 引入 lua\n    \n    一）openresty中nginx引入lua方式\n    \n      1）xxx_by_lua   --->字符串编写方式\n      2) xxx_by_lua_block ---->代码块方式\n      3) xxx_by_lua_file  ---->直接引用一个lua脚本文件\n    \n    我们案例中使用内容处理阶段，用content_by_lua演示\n    \n    -----------------编辑nginx.conf-----------------------\n    \n    第一种：content_by_lua\n    \n    location /testlua {\n      content_by_lua \"ngx.say('hello world')\";\n    }\n    \n    输出了hello world\n    \n    content_by_lua 方式，参数为字符串，编写不是太方便。\n    \n    ----------------------------------------\n    \n    第二种：content_by_lua_block\n    location /testlua {\n      content_by_lua_block {\n           ngx.say(\"hello world\");\n      } \n    }\n    \n    content_by_lua_block {}  表示内部为lua块，里面可以应用lua语句\n    \n    ----------------------------------------\n    \n    第三种：content_by_lua_file\n    \n    location /testlua {\n      content_by_lua_file /usr/local/lua/test.lua;\n    }\n    \n    content_by_lua_file 就是引用外部lua文件\n    \n    # vi  test.lua\n    ngx.say(\"hello world\");\n    \n    \n    二）openresty使用lua打印输出案例\n    \n      location /testsay {\n        content_by_lua_block {\n            --写响应头  \n            ngx.header.a = \"1\"  \n            ngx.header.b = \"2\" \n            --输出响应  \n            ngx.say(\"a\", \"b\", \"<br/>\")  \n            ngx.print(\"c\", \"d\", \"<br/>\")  \n            --200状态码退出  \n            return ngx.exit(200) \n        } \n      }\n    \n      ngx.header：输出响应头；\n      ngx.print：输出响应内容体；\n      ngx.say：通ngx.print，但是会最后输出一个换行符；\n      ngx.exit：指定状态码退出。\n    \n    三）介绍一下openresty使用lua常用的api\n    \n    1）ngx.var ： 获取Nginx变量 和 内置变量\n    \n    nginx内置的变量\n    \n    $arg_name 请求中的name参数\n    $args 请求中的参数\n    $binary_remote_addr 远程地址的二进制表示\n    $body_bytes_sent  已发送的消息体字节数\n    $content_length HTTP请求信息里的\"Content-Length\"\n    $content_type 请求信息里的\"Content-Type\"\n    $document_root  针对当前请求的根路径设置值\n    $document_uri 与$uri相同; 比如 /test2/test.php\n    $host 请求信息中的\"Host\"，如果请求中没有Host行，则等于设置的服务器名\n    $hostname 机器名使用 gethostname系统调用的值\n    $http_cookie  cookie 信息\n    $http_referer 引用地址\n    $http_user_agent  客户端代理信息\n    $http_via 最后一个访问服务器的Ip地址。\n    $http_x_forwarded_for 相当于网络访问路径\n    $is_args  如果请求行带有参数，返回“?”，否则返回空字符串\n    $limit_rate 对连接速率的限制\n    $nginx_version  当前运行的nginx版本号\n    $pid  worker进程的PID\n    $query_string 与$args相同\n    $realpath_root  按root指令或alias指令算出的当前请求的绝对路径。其中的符号链接都会解析成真是文件路径\n    $remote_addr  客户端IP地址\n    $remote_port  客户端端口号\n    $remote_user  客户端用户名，认证用\n    $request  用户请求\n    $request_body 这个变量（0.7.58+）包含请求的主要信息。在使用proxy_pass或fastcgi_pass指令的location中比较有意义\n    $request_body_file  客户端请求主体信息的临时文件名\n    $request_completion 如果请求成功，设为\"OK\"；如果请求未完成或者不是一系列请求中最后一部分则设为空\n    $request_filename 当前请求的文件路径名，比如/opt/nginx/www/test.php\n    $request_method 请求的方法，比如\"GET\"、\"POST\"等\n    $request_uri  请求的URI，带参数; 比如http://localhost:88/test1/\n    $scheme 所用的协议，比如http或者是https\n    $server_addr  服务器地址，如果没有用listen指明服务器地址，使用这个变量将发起一次系统调用以取得地址(造成资源浪费)\n    $server_name  请求到达的服务器名\n    $server_port  请求到达的服务器端口号\n    $server_protocol  请求的协议版本，\"HTTP/1.0\"或\"HTTP/1.1\"\n    $uri  请求的URI，可能和最初的值有不同，比如经过重定向之类的\n    \n    ngx.var.xxx\n    \n    location /var {\n        set $c 3;\n    \n        #处理业务\n        content_by_lua_block {\n          local a = tonumber(ngx.var.arg_a) or 0\n          local b = tonumber(ngx.var.arg_b) or 0\n          local c = tonumber(ngx.var.c) or 0\n          ngx.say(\"sum:\", a + b + c )\n        }\n    }\n    \n    注意：ngx.var.c 此变量必须提前声明；\n    另外对于nginx location中使用正则捕获的捕获组可以使用ngx.var[捕获组数字]获取；\n    \n    location ~ ^/var/([0-9]+) {\n       content_by_lua_block {\n        ngx.say(\"var[1]:\", ngx.var[1] )\n      }\n    }\n    \n    2）ngx.req请求模块的常用api\n    \n       ngx.req.get_headers：获取请求头，\n       获取带中划线的请求头时请使用如headers.user_agent这种方式；如果一个请求头有多个值，则返回的是table；\n    \n    -----------test.lua-------------------\n    \n    local headers = ngx.req.get_headers()  \n    ngx.say(\"============headers begin===============\", \"<br/>\")  \n    ngx.say(\"Host : \", headers[\"Host\"], \"<br/>\")  \n    ngx.say(\"headers['user-agent'] : \", headers[\"user-agent\"], \"<br/>\")  \n    ngx.say(\"headers.user_agent : \", headers.user_agent, \"<br/>\") \n    ngx.say(\"-------------遍历headers-----------\", \"<br/>\") \n    for k,v in pairs(headers) do  \n        if type(v) == \"table\" then  \n            ngx.say(k, \" : \", table.concat(v, \",\"), \"<br/>\")  \n        else  \n            ngx.say(k, \" : \", v, \"<br/>\")  \n        end  \n    end  \n    ngx.say(\"===========headers end============\", \"<br/>\")  \n    ngx.say(\"<br/>\")  \n    \n    \n    \n    3）获取请求参数\n      ngx.req.get_uri_args：获取url请求参数，其用法和get_headers类似；\n      ngx.req.get_post_args：获取post请求内容体，其用法和get_headers类似，\n                             但是必须提前调用ngx.req.read_body()来读取body体\n                             （也可以选择在nginx配置文件使用lua_need_request_body on;开启读取body体，\n                               但是官方不推荐）；\n    \n      ngx.req.get_body_data：为解析的请求body体内容字符串。\n    \n    ---------------test.lua---------------\n    \n    --get请求uri参数  \n    ngx.say(\"===========uri get args begin==================\", \"<br/>\")  \n    local uri_args = ngx.req.get_uri_args()  \n    for k, v in pairs(uri_args) do  \n        if type(v) == \"table\" then  \n            ngx.say(k, \" : \", table.concat(v, \", \"), \"<br/>\")  \n        else  \n            ngx.say(k, \": \", v, \"<br/>\")  \n        end  \n    end  \n    ngx.say(\"===========uri get args end==================\", \"<br/>\") \n      \n    --post请求参数  \n    ngx.req.read_body()  \n    ngx.say(\"=================post args begin====================\", \"<br/>\")  \n    local post_args = ngx.req.get_post_args()  \n    for k, v in pairs(post_args) do  \n        if type(v) == \"table\" then  \n            ngx.say(k, \" : \", table.concat(v, \", \"), \"<br/>\")  \n        else  \n            ngx.say(k, \": \", v, \"<br/>\")  \n        end  \n    end  \n    ngx.say(\"================post args end=====================\", \"<br/>\")  \n      \n    \n    4) ngx.req其他常用的api\n    --请求的http协议版本  \n    ngx.say(\"ngx.req.http_version : \", ngx.req.http_version(), \"<br/>\")  \n    --请求方法  \n    ngx.say(\"ngx.req.get_method : \", ngx.req.get_method(), \"<br/>\")  \n    --原始的请求头内容  \n    ngx.say(\"ngx.req.raw_header : \",  ngx.req.raw_header(), \"<br/>\")  \n    --请求的body内容体  \n    ngx.say(\"ngx.req.get_body_data() : \", ngx.req.get_body_data(), \"<br/>\")  \n    ngx.say(\"<br/>\")  \n    \n    ngx.req.raw_header()这个函数返回值为字符串\n    \n    5）编码解码\n    \n    ngx.escape_uri/ngx.unescape_uri ： uri编码解码；\n    \n    ngx.encode_args/ngx.decode_args：参数编码解码；\n    \n    ngx.encode_base64/ngx.decode_base64：BASE64编码解码；\n    \n    -------test.lua\n    \n    --未经解码的请求uri  \n    local request_uri = ngx.var.request_uri;  \n    ngx.say(\"request_uri : \", request_uri, \"<br/>\"); \n    \n    --编码\n    local escape_uri = ngx.escape_uri(request_uri)\n    ngx.say(\"escape_uri : \", escape_uri, \"<br/>\"); \n    \n    --解码  \n    ngx.say(\"decode request_uri : \", ngx.unescape_uri(escape_uri), \"<br/>\");\n    \n    --参数编码\n    local request_uri = ngx.var.request_uri;\n    local question_pos, _ = string.find(request_uri, '?')\n    if question_pos>0 then\n      local uri = string.sub(request_uri, 1, question_pos-1)\n      ngx.say(\"uri sub=\",string.sub(request_uri, question_pos+1),\"<br/>\");\n      \n      --对字符串进行解码\n      local args = ngx.decode_args(string.sub(request_uri, question_pos+1))\n      \n      for k,v in pairs(args) do\n        ngx.say(\"k=\",k,\",v=\", v, \"<br/>\");\n      end\n      \n      if args and args.userId then\n        args.userId = args.userId + 10000\n        ngx.say(\"args+10000 : \", uri .. '?' .. ngx.encode_args(args), \"<br/>\");\n      end\n    end\n    \n    6）md5加密api\n    --MD5  \n    ngx.say(\"ngx.md5 : \", ngx.md5(\"123\"), \"<br/>\")  \n    \n    7）nginx获取时间\n    \n    之前介绍的os.time()会涉及系统调用，性能比较差，推荐使用nginx中的时间api\n    \n    ngx.time()  --返回秒级精度的时间戳\n    ngx.now()   --返回毫秒级精度的时间戳\n    \n    就是通过这两种方式获取到的只是nginx缓存起来的时间戳，不是实时的。\n    所以有时候会出现一些比较奇怪的现象，比如下面代码：\n    \n    local t1 = ngx.now()\n    for i=1,1000000 do\n    end\n    local t2 = ngx.now()\n    print(t1, \",\", t2) -- t1和t2的值是一样的，why？\n    ngx.exit(200)\n    \n    正常来说，t2应该大于t1才对，但由于nginx没有及时更新（缓存的）时间戳，所以导致t2和t1获取到的时间戳是一样的。\n    那么怎样才能强迫nginx更新缓存呢？调用多一个ngx.update_time()函数即可：\n    \n    local t1 = ngx.now()\n    for i=1,1000000 do\n    end\n    ngx.update_time()\n    local t2 = ngx.now()\n    print(t1, \",\", t2) \n    ngx.exit(200)\n    \n    8）ngx.re模块中正则表达式相关的api\n    \n    ngx.re.match\n    ngx.re.sub\n    ngx.re.gsub\n    ngx.re.find\n    ngx.re.gmatch\n    \n    我们这里只简单的介绍 ngx.re.match，详细用法可以自行去网上学习\n    \n    ngx.re.match\n    只有第一次匹配的结果被返回，如果没有匹配，则返回nil；或者匹配过程中出现错误时，\n    也会返回nil，此时错误信息会被保存在err中。\n    \n    当匹配的字符串找到时，一个Lua table captures会被返回，\n    captures[0]中保存的就是匹配到的字串，\n    captures[1]保存的是用括号括起来的第一个子模式（捕获分组）的结果，\n    captures[2]保存的是第二个子模式（捕获分组）的结果，依次类似。\n    \n    ---------------------\n    \n    local m, err = ngx.re.match(\"hello, 1234\", \"[0-9]+\")\n    if m then\n      ngx.say(m[0])\n    else\n      if err then\n        ngx.log(ngx.ERR, \"error: \", err)\n        return\n      end\n    \n      ngx.say(\"match not found\")\n    end\n    \n    上面例子中，匹配的字符串是1234，因此m[0] == \"1234\"，\n    --------------\n    \n    local m, err = ngx.re.match(\"hello, 1234\", \"([0-9])[0-9]+\")\n    ngx.say(m[0],\"<br/>\")\n    ngx.say(m[1])\n    \n    \n    ---------------------------------------------------------\n    \n    \n    备注：有没有注意到，我们每次修改都要重启nginx，这样太过于麻烦，我们可以用\n    content_by_lua_file 引入外部lua，这样的话 只要修改外部的lua，就可以了，不需要重启nginx了。\n    注意需要把lua_code_cache 设置为off\n    \n    语法：lua_code_cache on | off\n    默认： on\n    适用上下文：http、server、location、location if\n    这个指令是指定是否开启lua的代码编译缓存，开发时可以设置为off，以便lua文件实时生效，\n    如果是生产线上，为了性能，建议开启。\n    最终nginx.conf修改为\n    \n    以后我们只要修改test.lua 文件就可以了。\n    \n    9）标准日志输出\n    \n    ngx.log(log_level, ...) \n    \n    日志输出级别\n    \n    ngx.STDERR     -- 标准输出\n    ngx.EMERG      -- 紧急报错\n    ngx.ALERT      -- 报警\n    ngx.CRIT       -- 严重，系统故障，触发运维告警系统\n    ngx.ERR        -- 错误，业务不可恢复性错误\n    ngx.WARN       -- 告警，业务中可忽略错误\n    ngx.NOTICE     -- 提醒，业务比较重要信息\n    ngx.INFO       -- 信息，业务琐碎日志信息，包含不同情况判断等\n    ngx.DEBUG      -- 调试\n    \n    -------------------------------------\n    \n    #user  nobody;\n    worker_processes  1;\n    \n    error_log  logs/error.log error;    # 日志级别\n    #pid        logs/nginx.pid;\n    \n    events {\n        worker_connections  1024;\n    }\n    \n    http {\n        server {\n            listen    80;\n            location / {\n                content_by_lua_block {\n                    local num = 55\n                    local str = \"string\"\n                    local obj\n                    ngx.log(ngx.ERR, \"num:\", num)\n                    ngx.log(ngx.INFO, \" string:\", str)\n                    print([[i am print]])\n                    ngx.log(ngx.ERR, \" object:\", obj)\n                }\n            }\n        }\n    }\n    \n    日志输出级别使用的 error，只有等于或大于这个级别的日志才会输出\n    \n    ngx.DEBUG\n    ngx.WARN\n    \n    对于应用开发，一般使用 ngx.INFO 到 ngx.CRIT 就够了。生产中错误日志开启到 error 级别就够了\n    \n    10）重定向 ngx.redirect\n    \n    -----重定向\n    \n    location = /bar {\n      content_by_lua_block {\n        ngx.say([[I am bar]])\n      }\n    }\n    \n    location = /foo {\n      rewrite_by_lua_block {\n        return ngx.redirect('/bar');\n      }\n    }\n    \n    \n    11）不同阶段共享变量\n    \n    ngx.ctx 全局共享变量\n    \n    在 OpenResty 的体系中，可以通过共享内存的方式完成不同工作进程的数据共享，\n    本地内存方式 去让不同的工作进程共享数据\n    \n    openresty有不同处理阶段，后面的课程会介绍。在不同的处理阶段，如何共享数据\n    \n    可以通过 Lua 模块方式完成单个进程内不同请求的数据共享。如何完成单个请求内不同阶段的数据共享呢？\n    \n    ngx.ctx 表就是为了解决这类问题而设计的。参考下面例子：\n    \n    location /test {\n         rewrite_by_lua_block {\n             ngx.ctx.foo = 76\n         }\n         access_by_lua_block {\n             ngx.ctx.foo = ngx.ctx.foo + 3\n         }\n         content_by_lua_block {\n             ngx.say(ngx.ctx.foo)\n         }\n     }\n    \n     ngx.ctx.xxxxx\n    \n    首先 ngx.ctx 是一个表，所以我们可以对他添加、修改。它用来存储基于请求的 Lua 环境数据，\n    其生存周期与当前请求相同 (类似 Nginx 变量)。它有一个最重要的特性：\n    单个请求内的 rewrite (重写)，access (访问)，和 content (内容) 等各处理阶段是保持一致的。\n    \n    额外注意，每个请求，包括子请求，都有一份自己的 ngx.ctx 表。例如：\n    \n     location /sub {\n         content_by_lua_block {\n             ngx.say(\"sub pre: \", ngx.ctx.blah)\n             ngx.ctx.blah = 32\n             ngx.say(\"sub post: \", ngx.ctx.blah)\n         }\n     }\n    \n     location /main {\n         content_by_lua_block {\n             ngx.ctx.blah = 73\n             ngx.say(\"main pre: \", ngx.ctx.blah)\n             local res = ngx.location.capture(\"/sub\")\n             ngx.print(res.body)\n             ngx.say(\"main post: \", ngx.ctx.blah)\n         }\n     }\n    \n    ngx.ctx 表查询需要相对昂贵的元方法调用，这比通过用户自己的函数参数直接传递基于请求的数据要慢得多。\n    所以不要为了节约用户函数参数而滥用此 API，因为它可能对性能有明显影响。\n    \n    由于 ngx.ctx 保存的是指定请求资源，所以这个变量是不能直接共享给其他请求使用的。\n    \n    \n    更多api使用  https://www.nginx.com/resources/wiki/modules/lua/#nginx-api-for-lua\n    \n    操作指令  说明\n    ngx.arg 指令参数，如跟在content_by_lua_file后面的参数\n    ngx.var 变量，ngx.var.VARIABLE引用某个变量\n    ngx.ctx 请求的lua上下文\n    ngx.header  响应头，ngx.header.HEADER引用某个头\n    ngx.status  响应码\n    \n    API 说明\n    ngx.log 输出到error.log\n    print 等价于 ngx.log(ngx.NOTICE, ...)\n    ngx.send_headers  发送响应头\n    ngx.headers_sent  响应头是否已发送\n    ngx.resp.get_headers  获取响应头\n    ngx.timer.at  注册定时器事件\n    ngx.is_subrequest 当前请求是否是子请求\n    ngx.location.capture  发布一个子请求\n    ngx.location.capture_multi  发布多个子请求\n    ngx.exec   \n    ngx.redirect   \n    ngx.print 输出响应\n    ngx.say 输出响应，自动添加'n'\n    ngx.flush 刷新响应\n    ngx.exit  结束请求\n    ngx.eof  \n    ngx.sleep 无阻塞的休眠（使用定时器实现）\n    ngx.get_phase  \n    ngx.on_abort  注册client断开请求时的回调函数\n    ndk.set_var.DIRECTIVE  \n    ngx.req.start_time  请求的开始时间\n    ngx.req.http_version  请求的HTTP版本号\n    ngx.req.raw_header  请求头（包括请求行）\n    ngx.req.get_method  请求方法\n    ngx.req.set_method  请求方法重载\n    ngx.req.set_uri 请求URL重写\n    ngx.req.set_uri_args   \n    ngx.req.get_uri_args  获取请求参数\n    ngx.req.get_post_args 获取请求表单\n    ngx.req.get_headers 获取请求头\n    ngx.req.set_header   \n    ngx.req.clear_header   \n    ngx.req.read_body 读取请求体\n    ngx.req.discard_body  扔掉请求体\n    ngx.req.get_body_data  \n    ngx.req.get_body_file  \n    ngx.req.set_body_data  \n    ngx.req.set_body_file  \n    ngx.req.init_body  \n    ngx.req.append_body  \n    ngx.req.finish_body  \n    ngx.req.socket   \n    ngx.escape_uri  字符串的url编码\n    ngx.unescape_uri  字符串url解码\n    ngx.encode_args 将table编码为一个参数字符串\n    ngx.decode_args 将参数字符串编码为一个table\n    ngx.encode_base64 字符串的base64编码\n    ngx.decode_base64 字符串的base64解码\n    ngx.crc32_short 字符串的crs32_short哈希\n    ngx.crc32_long  字符串的crs32_long哈希\n    ngx.hmac_sha1 字符串的hmac_sha1哈希\n    ngx.md5 返回16进制MD5\n    ngx.md5_bin 返回2进制MD5\n    ngx.sha1_bin  返回2进制sha1哈希值\n    ngx.quote_sql_str SQL语句转义\n    ngx.today 返回当前日期\n    ngx.time  返回UNIX时间戳\n    ngx.now 返回当前时间\n    ngx.update_time 刷新时间后再返回\n    ngx.localtime  \n    ngx.utctime  \n    ngx.cookie_time 返回的时间可用于cookie值\n    ngx.http_time 返回的时间可用于HTTP头\n    ngx.parse_http_time 解析HTTP头的时间\n    ngx.re.match   \n    ngx.re.find  \n    ngx.re.gmatch  \n    ngx.re.sub   \n    ngx.re.gsub  \n    ngx.shared.DICT  \n    ngx.shared.DICT.get  \n    ngx.shared.DICT.get_stale  \n    ngx.shared.DICT.set  \n    ngx.shared.DICT.safe_set   \n    ngx.shared.DICT.add  \n    ngx.shared.DICT.safe_add   \n    ngx.shared.DICT.replace  \n    ngx.shared.DICT.delete   \n    ngx.shared.DICT.incr   \n    ngx.shared.DICT.flush_all  \n    ngx.shared.DICT.flush_expired  \n    ngx.shared.DICT.get_keys   \n    ngx.socket.udp   \n    udpsock:setpeername  \n    udpsock:send   \n    udpsock:receive  \n    udpsock:close  \n    udpsock:settimeout   \n    ngx.socket.tcp   \n    tcpsock:connect  \n    tcpsock:sslhandshake   \n    tcpsock:send   \n    tcpsock:receive  \n    tcpsock:receiveuntil   \n    tcpsock:close  \n    tcpsock:settimeout   \n    tcpsock:setoption  \n    tcpsock:setkeepalive   \n    tcpsock:getreusedtimes   \n    ngx.socket.connect   \n    ngx.thread.spawn   \n    ngx.thread.wait  \n    ngx.thread.kill  \n    coroutine.create   \n    coroutine.resume   \n    coroutine.yield  \n    coroutine.wrap   \n    coroutine.running  \n    coroutine.status   \n    ngx.config.debug  编译时是否有 --with-debug选项\n    ngx.config.prefix 编译时的 --prefix选项\n    ngx.config.nginx_version  返回nginx版本号\n    ngx.config.nginx_configure  返回编译时 ./configure的命令行选项\n    ngx.config.ngx_lua_version  返回ngx_lua模块版本号\n    ngx.worker.exiting  当前worker进程是否正在关闭（如reload、shutdown期间）\n    ngx.worker.pid  返回当前worker进程的pid\n       \n    常量说明\n    ngx.OK (0)\n    ngx.ERROR (-1)\n    ngx.AGAIN (-2)\n    ngx.DONE (-4)\n    ngx.DECLINED (-5)\n    ngx.nil\n    \n    \n    HTTP 请求方式\n    ngx.HTTP_GET\n    ngx.HTTP_HEAD\n    ngx.HTTP_PUT\n    ngx.HTTP_POST\n    ngx.HTTP_DELETE\n    ngx.HTTP_OPTIONS  \n    ngx.HTTP_MKCOL    \n    ngx.HTTP_COPY      \n    ngx.HTTP_MOVE     \n    ngx.HTTP_PROPFIND \n    ngx.HTTP_PROPPATCH \n    ngx.HTTP_LOCK \n    ngx.HTTP_UNLOCK    \n    ngx.HTTP_PATCH   \n    ngx.HTTP_TRACE  \n    \n    \n    HTTP 返回状态\n    ngx.HTTP_OK (200)\n    ngx.HTTP_CREATED (201)\n    ngx.HTTP_SPECIAL_RESPONSE (300)\n    ngx.HTTP_MOVED_PERMANENTLY (301)\n    ngx.HTTP_MOVED_TEMPORARILY (302)\n    ngx.HTTP_SEE_OTHER (303)\n    ngx.HTTP_NOT_MODIFIED (304)\n    ngx.HTTP_BAD_REQUEST (400)\n    ngx.HTTP_UNAUTHORIZED (401)\n    ngx.HTTP_FORBIDDEN (403)\n    ngx.HTTP_NOT_FOUND (404)\n    ngx.HTTP_NOT_ALLOWED (405)\n    ngx.HTTP_GONE (410)\n    ngx.HTTP_INTERNAL_SERVER_ERROR (500)\n    ngx.HTTP_METHOD_NOT_IMPLEMENTED (501)\n    ngx.HTTP_SERVICE_UNAVAILABLE (503)\n    ngx.HTTP_GATEWAY_TIMEOUT (504) \n\n","slug":"微服务API网关框架-6","published":1,"updated":"2018-12-20T06:10:32.976Z","_id":"cjpw2eyh9000tn0ujean5z4a3","comments":1,"layout":"post","photos":[],"link":"","content":"<h1><span id=\"openresty\">OpenResty</span></h1>\n<h2><span id=\"介绍\">介绍</span></h2>\n<pre><code>OpenResty\n    是一个基于 Nginx 与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。\n    用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。\n    通过汇聚各种设计精良的 Nginx 模块（主要由 OpenResty 团队自主开发），从而将 Nginx 有效地变成一个强大的通用 Web 应用平台。\n    这样，Web 开发人员和系统工程师可以使用 Lua 脚本语言调动 Nginx 支持的各种 C 以及 Lua 模块，快速构造出足以胜任 10K 乃至 1000K 以上单机并发连接的高性能 Web 应用系统。\n    OpenResty的目标是让你的Web服务直接跑在 Nginx 服务内部，充分利用 Nginx 的非阻塞 I/O 模型，不仅仅对 HTTP 客户端请求,\n    甚至于对远程后端诸如 MySQL、PostgreSQL、Memcached 以及 Redis 等都进行一致的高性能响应。\n</code></pre>\n<h2><span id=\"安装\">安装</span></h2>\n<pre><code>1）下载安装\ncentos系统\n# yum install readline-devel pcre pcre-devel openssl openssl-devel gcc curl GeoIP-devel\n下载源码包\nhttps://github.com/openresty/openresty/releases\n选择最新版本v1.13.6.1\n解压安装\n# tar -xzvf openresty-1.13.6.1.tar.gz\n# cd openresty-1.13.6.1/\n\n##选择模块 ./configure --help\n\n# ./configure --with-luajit --with-pcre --with-http_gzip_static_module --with-http_realip_module --with-http_geoip_module --with-http_ssl_module  --with-http_stub_status_module \n\n--with-http_gzip_static_module #静态文件压缩\n--with-http_stub_status_module #监控nginx状态\n--with-http_realip_module #通过这个模块允许我们改变客户端请求头中客户端IP地址值(例如X-Real-IP 或 X-Forwarded-For)，意义在于能够使得后台服务器记录原始客户端的IP地址\n--with-pcre #设置PCRE库（pcre pcre-devel）\n--with-http_ssl_module #使用https协议模块。（openssl openssl-devel）\n--with-http_geoip_module #增加了根据ip获得城市信息，经纬度等模块 （GeoIP-devel）\n\n# make &amp;&amp; make install\n\n2）安装成功后，默认会在/usr/local/openresty/\n目录下\nluajit 是采用C语言写的Lua代码的解释器 ----just in time   即时解析\nlualib 是编辑好的lua类库\nnginx，其实我们openResty就是nginx，只是做了一些模块化工作；所以启动openResty就是启动nginx，我们可以到 cd nginx/sbin/，直接运行  ./nginx\n\n3）设置环境变量\n# vi /etc/profile\nexport NGINX_HOME=/usr/local/openresty/nginx\nexport PATH=$PATH:$NGINX_HOME/sbin\n# source /etc/profile ##生效\n</code></pre>\n<h2><span id=\"简单例子-hello-world\">简单例子 – Hello World</span></h2>\n<pre><code>1）ngx_lua模块的hello world\n编辑nginx下conf配置文件nginx.conf\n# vi nginx.conf\n在server模块加上\nlocation /helloworld {\n\tdefault_type text/html;\n    content_by_lua 'ngx.say(&quot;hello world&quot;)';\n}\n\n检查配置文件是否正确\n# /usr/local/openresty/nginx/sbin/nginx -t -c /usr/local/openresty/nginx/conf/nginx.conf\n\n重启nginx\n# ./nginx -s reload\n访问http://192.168.31.138/helloworld  输出 hello world\n\n2）nginx的内部变量\n\n名称 说明\n$arg_name 请求中的name参数\n$args 请求中的参数\n$binary_remote_addr 远程地址的二进制表示\n$body_bytes_sent 已发送的消息体字节数\n$content_length HTTP请求信息里的&quot;Content-Length&quot;\n$content_type 请求信息里的&quot;Content-Type&quot;\n$document_root 针对当前请求的根路径设置值\n$document_uri 与$uri相同; 比如 /test2/test.php\n$host 请求信息中的&quot;Host&quot;，如果请求中没有Host行，则等于设置的服务器名\n$hostname 机器名使用 gethostname系统调用的值\n$http_cookie cookie 信息\n$http_referer 引用地址\n$http_user_agent 客户端代理信息\n$http_via 最后一个访问服务器的Ip地址。\n$http_x_forwarded_for 相当于网络访问路径\n$is_args 如果请求行带有参数，返回“?”，否则返回空字符串\n$limit_rate 对连接速率的限制\n$nginx_version 当前运行的nginx版本号\n$pid worker进程的PID\n$query_string 与$args相同\n$realpath_root 按root指令或alias指令算出的当前请求的绝对路径。其中的符号链接都会解析成真是文件路径\n$remote_addr 客户端IP地址\n$remote_port 客户端端口号\n$remote_user 客户端用户名，认证用\n$request 用户请求\n$request_body 这个变量（0.7.58+）包含请求的主要信息。在使用proxy_pass或fastcgi_pass指令的location中比较有意义\n$request_body_file 客户端请求主体信息的临时文件名\n$request_completion 如果请求成功，设为&quot;OK&quot;；如果请求未完成或者不是一系列请求中最后一部分则设为空\n$request_filename 当前请求的文件路径名，比如/opt/nginx/www/test.php\n$request_method 请求的方法，比如&quot;GET&quot;、&quot;POST&quot;等\n$request_uri 请求的URI，带参数; 比如http://localhost:88/test1/\n$scheme 所用的协议，比如http或者是https\n$server_addr 服务器地址，如果没有用listen指明服务器地址，使用这个变量将发起一次系统调用以取得地址(造成资源浪费)\n$server_name 请求到达的服务器名\n$server_port 请求到达的服务器端口号\n$server_protocol 请求的协议版本，&quot;HTTP/1.0&quot;或&quot;HTTP/1.1&quot;\n$uri 请求的URI，可能和最初的值有不同，比如经过重定向之类的\n\n\n写个配置文件，测试一下$uri变量\nlocation /test_url {\n\techo &quot;url:$uri&quot;;\n}\n\nlocation /test_url {\n\t\t\techo &quot;url:$uri&quot;;\n\t\t\techo &quot;full url : $host$request_uri&quot;;\n\t\t}\n\t\t\n重启nginx，访问\n\n再此基础上测试$args变量\nlocation /test_url {\n\techo &quot;url:$uri----args:$args&quot;;\n}\n\n再此基础上测试$arg_name变量\nlocation /test_url {\n\techo &quot;url:$uri----args:$args--------arg_name:$arg_name&quot;;\n}\n\n说明一下，$arg_name表示取名为name的参数，如果想取其他名称的参数可以对应的取该参数名\nlocation /test_url {\n\techo &quot;url:$uri --- args:$args --- arg_name:$arg_name &lt;br/&gt;&quot;;\n\techo &quot;arg_user:$arg_user --- arg_age:$arg_age&lt;br/&gt;&quot;;\n\techo &quot;arg_test:$arg_test&quot;;\n}\n\ntest参数名不存在，则为空。\n自定义变量\nlocation /test_def {\n\tset $name &quot;rainbow&quot;;\n\techo $name;\n}\n\nset 设置的变量 为局部变量，其他请求无法获取此$name的值\nlocation /test_def {\n\tset $name &quot;rainbow&quot;;\n\techo_exec /test_def2;  ##内部跳转，可以传递变量\n}\nlocation /test_def2 {\n\techo $name;\n}\n</code></pre>\n<h2><span id=\"openresty中使用lua\">Openresty中使用Lua</span></h2>\n<pre><code>openresty 引入 lua\n\n一）openresty中nginx引入lua方式\n\n  1）xxx_by_lua   ---&gt;字符串编写方式\n  2) xxx_by_lua_block ----&gt;代码块方式\n  3) xxx_by_lua_file  ----&gt;直接引用一个lua脚本文件\n\n我们案例中使用内容处理阶段，用content_by_lua演示\n\n-----------------编辑nginx.conf-----------------------\n\n第一种：content_by_lua\n\nlocation /testlua {\n  content_by_lua &quot;ngx.say('hello world')&quot;;\n}\n\n输出了hello world\n\ncontent_by_lua 方式，参数为字符串，编写不是太方便。\n\n----------------------------------------\n\n第二种：content_by_lua_block\nlocation /testlua {\n  content_by_lua_block {\n       ngx.say(&quot;hello world&quot;);\n  } \n}\n\ncontent_by_lua_block {}  表示内部为lua块，里面可以应用lua语句\n\n----------------------------------------\n\n第三种：content_by_lua_file\n\nlocation /testlua {\n  content_by_lua_file /usr/local/lua/test.lua;\n}\n\ncontent_by_lua_file 就是引用外部lua文件\n\n# vi  test.lua\nngx.say(&quot;hello world&quot;);\n\n\n二）openresty使用lua打印输出案例\n\n  location /testsay {\n    content_by_lua_block {\n        --写响应头  \n        ngx.header.a = &quot;1&quot;  \n        ngx.header.b = &quot;2&quot; \n        --输出响应  \n        ngx.say(&quot;a&quot;, &quot;b&quot;, &quot;&lt;br/&gt;&quot;)  \n        ngx.print(&quot;c&quot;, &quot;d&quot;, &quot;&lt;br/&gt;&quot;)  \n        --200状态码退出  \n        return ngx.exit(200) \n    } \n  }\n\n  ngx.header：输出响应头；\n  ngx.print：输出响应内容体；\n  ngx.say：通ngx.print，但是会最后输出一个换行符；\n  ngx.exit：指定状态码退出。\n\n三）介绍一下openresty使用lua常用的api\n\n1）ngx.var ： 获取Nginx变量 和 内置变量\n\nnginx内置的变量\n\n$arg_name 请求中的name参数\n$args 请求中的参数\n$binary_remote_addr 远程地址的二进制表示\n$body_bytes_sent  已发送的消息体字节数\n$content_length HTTP请求信息里的&quot;Content-Length&quot;\n$content_type 请求信息里的&quot;Content-Type&quot;\n$document_root  针对当前请求的根路径设置值\n$document_uri 与$uri相同; 比如 /test2/test.php\n$host 请求信息中的&quot;Host&quot;，如果请求中没有Host行，则等于设置的服务器名\n$hostname 机器名使用 gethostname系统调用的值\n$http_cookie  cookie 信息\n$http_referer 引用地址\n$http_user_agent  客户端代理信息\n$http_via 最后一个访问服务器的Ip地址。\n$http_x_forwarded_for 相当于网络访问路径\n$is_args  如果请求行带有参数，返回“?”，否则返回空字符串\n$limit_rate 对连接速率的限制\n$nginx_version  当前运行的nginx版本号\n$pid  worker进程的PID\n$query_string 与$args相同\n$realpath_root  按root指令或alias指令算出的当前请求的绝对路径。其中的符号链接都会解析成真是文件路径\n$remote_addr  客户端IP地址\n$remote_port  客户端端口号\n$remote_user  客户端用户名，认证用\n$request  用户请求\n$request_body 这个变量（0.7.58+）包含请求的主要信息。在使用proxy_pass或fastcgi_pass指令的location中比较有意义\n$request_body_file  客户端请求主体信息的临时文件名\n$request_completion 如果请求成功，设为&quot;OK&quot;；如果请求未完成或者不是一系列请求中最后一部分则设为空\n$request_filename 当前请求的文件路径名，比如/opt/nginx/www/test.php\n$request_method 请求的方法，比如&quot;GET&quot;、&quot;POST&quot;等\n$request_uri  请求的URI，带参数; 比如http://localhost:88/test1/\n$scheme 所用的协议，比如http或者是https\n$server_addr  服务器地址，如果没有用listen指明服务器地址，使用这个变量将发起一次系统调用以取得地址(造成资源浪费)\n$server_name  请求到达的服务器名\n$server_port  请求到达的服务器端口号\n$server_protocol  请求的协议版本，&quot;HTTP/1.0&quot;或&quot;HTTP/1.1&quot;\n$uri  请求的URI，可能和最初的值有不同，比如经过重定向之类的\n\nngx.var.xxx\n\nlocation /var {\n    set $c 3;\n\n    #处理业务\n    content_by_lua_block {\n      local a = tonumber(ngx.var.arg_a) or 0\n      local b = tonumber(ngx.var.arg_b) or 0\n      local c = tonumber(ngx.var.c) or 0\n      ngx.say(&quot;sum:&quot;, a + b + c )\n    }\n}\n\n注意：ngx.var.c 此变量必须提前声明；\n另外对于nginx location中使用正则捕获的捕获组可以使用ngx.var[捕获组数字]获取；\n\nlocation ~ ^/var/([0-9]+) {\n   content_by_lua_block {\n    ngx.say(&quot;var[1]:&quot;, ngx.var[1] )\n  }\n}\n\n2）ngx.req请求模块的常用api\n\n   ngx.req.get_headers：获取请求头，\n   获取带中划线的请求头时请使用如headers.user_agent这种方式；如果一个请求头有多个值，则返回的是table；\n\n-----------test.lua-------------------\n\nlocal headers = ngx.req.get_headers()  \nngx.say(&quot;============headers begin===============&quot;, &quot;&lt;br/&gt;&quot;)  \nngx.say(&quot;Host : &quot;, headers[&quot;Host&quot;], &quot;&lt;br/&gt;&quot;)  \nngx.say(&quot;headers['user-agent'] : &quot;, headers[&quot;user-agent&quot;], &quot;&lt;br/&gt;&quot;)  \nngx.say(&quot;headers.user_agent : &quot;, headers.user_agent, &quot;&lt;br/&gt;&quot;) \nngx.say(&quot;-------------遍历headers-----------&quot;, &quot;&lt;br/&gt;&quot;) \nfor k,v in pairs(headers) do  \n    if type(v) == &quot;table&quot; then  \n        ngx.say(k, &quot; : &quot;, table.concat(v, &quot;,&quot;), &quot;&lt;br/&gt;&quot;)  \n    else  \n        ngx.say(k, &quot; : &quot;, v, &quot;&lt;br/&gt;&quot;)  \n    end  \nend  \nngx.say(&quot;===========headers end============&quot;, &quot;&lt;br/&gt;&quot;)  \nngx.say(&quot;&lt;br/&gt;&quot;)  \n\n\n\n3）获取请求参数\n  ngx.req.get_uri_args：获取url请求参数，其用法和get_headers类似；\n  ngx.req.get_post_args：获取post请求内容体，其用法和get_headers类似，\n                         但是必须提前调用ngx.req.read_body()来读取body体\n                         （也可以选择在nginx配置文件使用lua_need_request_body on;开启读取body体，\n                           但是官方不推荐）；\n\n  ngx.req.get_body_data：为解析的请求body体内容字符串。\n\n---------------test.lua---------------\n\n--get请求uri参数  \nngx.say(&quot;===========uri get args begin==================&quot;, &quot;&lt;br/&gt;&quot;)  \nlocal uri_args = ngx.req.get_uri_args()  \nfor k, v in pairs(uri_args) do  \n    if type(v) == &quot;table&quot; then  \n        ngx.say(k, &quot; : &quot;, table.concat(v, &quot;, &quot;), &quot;&lt;br/&gt;&quot;)  \n    else  \n        ngx.say(k, &quot;: &quot;, v, &quot;&lt;br/&gt;&quot;)  \n    end  \nend  \nngx.say(&quot;===========uri get args end==================&quot;, &quot;&lt;br/&gt;&quot;) \n  \n--post请求参数  \nngx.req.read_body()  \nngx.say(&quot;=================post args begin====================&quot;, &quot;&lt;br/&gt;&quot;)  \nlocal post_args = ngx.req.get_post_args()  \nfor k, v in pairs(post_args) do  \n    if type(v) == &quot;table&quot; then  \n        ngx.say(k, &quot; : &quot;, table.concat(v, &quot;, &quot;), &quot;&lt;br/&gt;&quot;)  \n    else  \n        ngx.say(k, &quot;: &quot;, v, &quot;&lt;br/&gt;&quot;)  \n    end  \nend  \nngx.say(&quot;================post args end=====================&quot;, &quot;&lt;br/&gt;&quot;)  \n  \n\n4) ngx.req其他常用的api\n--请求的http协议版本  \nngx.say(&quot;ngx.req.http_version : &quot;, ngx.req.http_version(), &quot;&lt;br/&gt;&quot;)  \n--请求方法  \nngx.say(&quot;ngx.req.get_method : &quot;, ngx.req.get_method(), &quot;&lt;br/&gt;&quot;)  \n--原始的请求头内容  \nngx.say(&quot;ngx.req.raw_header : &quot;,  ngx.req.raw_header(), &quot;&lt;br/&gt;&quot;)  \n--请求的body内容体  \nngx.say(&quot;ngx.req.get_body_data() : &quot;, ngx.req.get_body_data(), &quot;&lt;br/&gt;&quot;)  \nngx.say(&quot;&lt;br/&gt;&quot;)  \n\nngx.req.raw_header()这个函数返回值为字符串\n\n5）编码解码\n\nngx.escape_uri/ngx.unescape_uri ： uri编码解码；\n\nngx.encode_args/ngx.decode_args：参数编码解码；\n\nngx.encode_base64/ngx.decode_base64：BASE64编码解码；\n\n-------test.lua\n\n--未经解码的请求uri  \nlocal request_uri = ngx.var.request_uri;  \nngx.say(&quot;request_uri : &quot;, request_uri, &quot;&lt;br/&gt;&quot;); \n\n--编码\nlocal escape_uri = ngx.escape_uri(request_uri)\nngx.say(&quot;escape_uri : &quot;, escape_uri, &quot;&lt;br/&gt;&quot;); \n\n--解码  \nngx.say(&quot;decode request_uri : &quot;, ngx.unescape_uri(escape_uri), &quot;&lt;br/&gt;&quot;);\n\n--参数编码\nlocal request_uri = ngx.var.request_uri;\nlocal question_pos, _ = string.find(request_uri, '?')\nif question_pos&gt;0 then\n  local uri = string.sub(request_uri, 1, question_pos-1)\n  ngx.say(&quot;uri sub=&quot;,string.sub(request_uri, question_pos+1),&quot;&lt;br/&gt;&quot;);\n  \n  --对字符串进行解码\n  local args = ngx.decode_args(string.sub(request_uri, question_pos+1))\n  \n  for k,v in pairs(args) do\n    ngx.say(&quot;k=&quot;,k,&quot;,v=&quot;, v, &quot;&lt;br/&gt;&quot;);\n  end\n  \n  if args and args.userId then\n    args.userId = args.userId + 10000\n    ngx.say(&quot;args+10000 : &quot;, uri .. '?' .. ngx.encode_args(args), &quot;&lt;br/&gt;&quot;);\n  end\nend\n\n6）md5加密api\n--MD5  \nngx.say(&quot;ngx.md5 : &quot;, ngx.md5(&quot;123&quot;), &quot;&lt;br/&gt;&quot;)  \n\n7）nginx获取时间\n\n之前介绍的os.time()会涉及系统调用，性能比较差，推荐使用nginx中的时间api\n\nngx.time()  --返回秒级精度的时间戳\nngx.now()   --返回毫秒级精度的时间戳\n\n就是通过这两种方式获取到的只是nginx缓存起来的时间戳，不是实时的。\n所以有时候会出现一些比较奇怪的现象，比如下面代码：\n\nlocal t1 = ngx.now()\nfor i=1,1000000 do\nend\nlocal t2 = ngx.now()\nprint(t1, &quot;,&quot;, t2) -- t1和t2的值是一样的，why？\nngx.exit(200)\n\n正常来说，t2应该大于t1才对，但由于nginx没有及时更新（缓存的）时间戳，所以导致t2和t1获取到的时间戳是一样的。\n那么怎样才能强迫nginx更新缓存呢？调用多一个ngx.update_time()函数即可：\n\nlocal t1 = ngx.now()\nfor i=1,1000000 do\nend\nngx.update_time()\nlocal t2 = ngx.now()\nprint(t1, &quot;,&quot;, t2) \nngx.exit(200)\n\n8）ngx.re模块中正则表达式相关的api\n\nngx.re.match\nngx.re.sub\nngx.re.gsub\nngx.re.find\nngx.re.gmatch\n\n我们这里只简单的介绍 ngx.re.match，详细用法可以自行去网上学习\n\nngx.re.match\n只有第一次匹配的结果被返回，如果没有匹配，则返回nil；或者匹配过程中出现错误时，\n也会返回nil，此时错误信息会被保存在err中。\n\n当匹配的字符串找到时，一个Lua table captures会被返回，\ncaptures[0]中保存的就是匹配到的字串，\ncaptures[1]保存的是用括号括起来的第一个子模式（捕获分组）的结果，\ncaptures[2]保存的是第二个子模式（捕获分组）的结果，依次类似。\n\n---------------------\n\nlocal m, err = ngx.re.match(&quot;hello, 1234&quot;, &quot;[0-9]+&quot;)\nif m then\n  ngx.say(m[0])\nelse\n  if err then\n    ngx.log(ngx.ERR, &quot;error: &quot;, err)\n    return\n  end\n\n  ngx.say(&quot;match not found&quot;)\nend\n\n上面例子中，匹配的字符串是1234，因此m[0] == &quot;1234&quot;，\n--------------\n\nlocal m, err = ngx.re.match(&quot;hello, 1234&quot;, &quot;([0-9])[0-9]+&quot;)\nngx.say(m[0],&quot;&lt;br/&gt;&quot;)\nngx.say(m[1])\n\n\n---------------------------------------------------------\n\n\n备注：有没有注意到，我们每次修改都要重启nginx，这样太过于麻烦，我们可以用\ncontent_by_lua_file 引入外部lua，这样的话 只要修改外部的lua，就可以了，不需要重启nginx了。\n注意需要把lua_code_cache 设置为off\n\n语法：lua_code_cache on | off\n默认： on\n适用上下文：http、server、location、location if\n这个指令是指定是否开启lua的代码编译缓存，开发时可以设置为off，以便lua文件实时生效，\n如果是生产线上，为了性能，建议开启。\n最终nginx.conf修改为\n\n以后我们只要修改test.lua 文件就可以了。\n\n9）标准日志输出\n\nngx.log(log_level, ...) \n\n日志输出级别\n\nngx.STDERR     -- 标准输出\nngx.EMERG      -- 紧急报错\nngx.ALERT      -- 报警\nngx.CRIT       -- 严重，系统故障，触发运维告警系统\nngx.ERR        -- 错误，业务不可恢复性错误\nngx.WARN       -- 告警，业务中可忽略错误\nngx.NOTICE     -- 提醒，业务比较重要信息\nngx.INFO       -- 信息，业务琐碎日志信息，包含不同情况判断等\nngx.DEBUG      -- 调试\n\n-------------------------------------\n\n#user  nobody;\nworker_processes  1;\n\nerror_log  logs/error.log error;    # 日志级别\n#pid        logs/nginx.pid;\n\nevents {\n    worker_connections  1024;\n}\n\nhttp {\n    server {\n        listen    80;\n        location / {\n            content_by_lua_block {\n                local num = 55\n                local str = &quot;string&quot;\n                local obj\n                ngx.log(ngx.ERR, &quot;num:&quot;, num)\n                ngx.log(ngx.INFO, &quot; string:&quot;, str)\n                print([[i am print]])\n                ngx.log(ngx.ERR, &quot; object:&quot;, obj)\n            }\n        }\n    }\n}\n\n日志输出级别使用的 error，只有等于或大于这个级别的日志才会输出\n\nngx.DEBUG\nngx.WARN\n\n对于应用开发，一般使用 ngx.INFO 到 ngx.CRIT 就够了。生产中错误日志开启到 error 级别就够了\n\n10）重定向 ngx.redirect\n\n-----重定向\n\nlocation = /bar {\n  content_by_lua_block {\n    ngx.say([[I am bar]])\n  }\n}\n\nlocation = /foo {\n  rewrite_by_lua_block {\n    return ngx.redirect('/bar');\n  }\n}\n\n\n11）不同阶段共享变量\n\nngx.ctx 全局共享变量\n\n在 OpenResty 的体系中，可以通过共享内存的方式完成不同工作进程的数据共享，\n本地内存方式 去让不同的工作进程共享数据\n\nopenresty有不同处理阶段，后面的课程会介绍。在不同的处理阶段，如何共享数据\n\n可以通过 Lua 模块方式完成单个进程内不同请求的数据共享。如何完成单个请求内不同阶段的数据共享呢？\n\nngx.ctx 表就是为了解决这类问题而设计的。参考下面例子：\n\nlocation /test {\n     rewrite_by_lua_block {\n         ngx.ctx.foo = 76\n     }\n     access_by_lua_block {\n         ngx.ctx.foo = ngx.ctx.foo + 3\n     }\n     content_by_lua_block {\n         ngx.say(ngx.ctx.foo)\n     }\n }\n\n ngx.ctx.xxxxx\n\n首先 ngx.ctx 是一个表，所以我们可以对他添加、修改。它用来存储基于请求的 Lua 环境数据，\n其生存周期与当前请求相同 (类似 Nginx 变量)。它有一个最重要的特性：\n单个请求内的 rewrite (重写)，access (访问)，和 content (内容) 等各处理阶段是保持一致的。\n\n额外注意，每个请求，包括子请求，都有一份自己的 ngx.ctx 表。例如：\n\n location /sub {\n     content_by_lua_block {\n         ngx.say(&quot;sub pre: &quot;, ngx.ctx.blah)\n         ngx.ctx.blah = 32\n         ngx.say(&quot;sub post: &quot;, ngx.ctx.blah)\n     }\n }\n\n location /main {\n     content_by_lua_block {\n         ngx.ctx.blah = 73\n         ngx.say(&quot;main pre: &quot;, ngx.ctx.blah)\n         local res = ngx.location.capture(&quot;/sub&quot;)\n         ngx.print(res.body)\n         ngx.say(&quot;main post: &quot;, ngx.ctx.blah)\n     }\n }\n\nngx.ctx 表查询需要相对昂贵的元方法调用，这比通过用户自己的函数参数直接传递基于请求的数据要慢得多。\n所以不要为了节约用户函数参数而滥用此 API，因为它可能对性能有明显影响。\n\n由于 ngx.ctx 保存的是指定请求资源，所以这个变量是不能直接共享给其他请求使用的。\n\n\n更多api使用  https://www.nginx.com/resources/wiki/modules/lua/#nginx-api-for-lua\n\n操作指令  说明\nngx.arg 指令参数，如跟在content_by_lua_file后面的参数\nngx.var 变量，ngx.var.VARIABLE引用某个变量\nngx.ctx 请求的lua上下文\nngx.header  响应头，ngx.header.HEADER引用某个头\nngx.status  响应码\n\nAPI 说明\nngx.log 输出到error.log\nprint 等价于 ngx.log(ngx.NOTICE, ...)\nngx.send_headers  发送响应头\nngx.headers_sent  响应头是否已发送\nngx.resp.get_headers  获取响应头\nngx.timer.at  注册定时器事件\nngx.is_subrequest 当前请求是否是子请求\nngx.location.capture  发布一个子请求\nngx.location.capture_multi  发布多个子请求\nngx.exec   \nngx.redirect   \nngx.print 输出响应\nngx.say 输出响应，自动添加'n'\nngx.flush 刷新响应\nngx.exit  结束请求\nngx.eof  \nngx.sleep 无阻塞的休眠（使用定时器实现）\nngx.get_phase  \nngx.on_abort  注册client断开请求时的回调函数\nndk.set_var.DIRECTIVE  \nngx.req.start_time  请求的开始时间\nngx.req.http_version  请求的HTTP版本号\nngx.req.raw_header  请求头（包括请求行）\nngx.req.get_method  请求方法\nngx.req.set_method  请求方法重载\nngx.req.set_uri 请求URL重写\nngx.req.set_uri_args   \nngx.req.get_uri_args  获取请求参数\nngx.req.get_post_args 获取请求表单\nngx.req.get_headers 获取请求头\nngx.req.set_header   \nngx.req.clear_header   \nngx.req.read_body 读取请求体\nngx.req.discard_body  扔掉请求体\nngx.req.get_body_data  \nngx.req.get_body_file  \nngx.req.set_body_data  \nngx.req.set_body_file  \nngx.req.init_body  \nngx.req.append_body  \nngx.req.finish_body  \nngx.req.socket   \nngx.escape_uri  字符串的url编码\nngx.unescape_uri  字符串url解码\nngx.encode_args 将table编码为一个参数字符串\nngx.decode_args 将参数字符串编码为一个table\nngx.encode_base64 字符串的base64编码\nngx.decode_base64 字符串的base64解码\nngx.crc32_short 字符串的crs32_short哈希\nngx.crc32_long  字符串的crs32_long哈希\nngx.hmac_sha1 字符串的hmac_sha1哈希\nngx.md5 返回16进制MD5\nngx.md5_bin 返回2进制MD5\nngx.sha1_bin  返回2进制sha1哈希值\nngx.quote_sql_str SQL语句转义\nngx.today 返回当前日期\nngx.time  返回UNIX时间戳\nngx.now 返回当前时间\nngx.update_time 刷新时间后再返回\nngx.localtime  \nngx.utctime  \nngx.cookie_time 返回的时间可用于cookie值\nngx.http_time 返回的时间可用于HTTP头\nngx.parse_http_time 解析HTTP头的时间\nngx.re.match   \nngx.re.find  \nngx.re.gmatch  \nngx.re.sub   \nngx.re.gsub  \nngx.shared.DICT  \nngx.shared.DICT.get  \nngx.shared.DICT.get_stale  \nngx.shared.DICT.set  \nngx.shared.DICT.safe_set   \nngx.shared.DICT.add  \nngx.shared.DICT.safe_add   \nngx.shared.DICT.replace  \nngx.shared.DICT.delete   \nngx.shared.DICT.incr   \nngx.shared.DICT.flush_all  \nngx.shared.DICT.flush_expired  \nngx.shared.DICT.get_keys   \nngx.socket.udp   \nudpsock:setpeername  \nudpsock:send   \nudpsock:receive  \nudpsock:close  \nudpsock:settimeout   \nngx.socket.tcp   \ntcpsock:connect  \ntcpsock:sslhandshake   \ntcpsock:send   \ntcpsock:receive  \ntcpsock:receiveuntil   \ntcpsock:close  \ntcpsock:settimeout   \ntcpsock:setoption  \ntcpsock:setkeepalive   \ntcpsock:getreusedtimes   \nngx.socket.connect   \nngx.thread.spawn   \nngx.thread.wait  \nngx.thread.kill  \ncoroutine.create   \ncoroutine.resume   \ncoroutine.yield  \ncoroutine.wrap   \ncoroutine.running  \ncoroutine.status   \nngx.config.debug  编译时是否有 --with-debug选项\nngx.config.prefix 编译时的 --prefix选项\nngx.config.nginx_version  返回nginx版本号\nngx.config.nginx_configure  返回编译时 ./configure的命令行选项\nngx.config.ngx_lua_version  返回ngx_lua模块版本号\nngx.worker.exiting  当前worker进程是否正在关闭（如reload、shutdown期间）\nngx.worker.pid  返回当前worker进程的pid\n   \n常量说明\nngx.OK (0)\nngx.ERROR (-1)\nngx.AGAIN (-2)\nngx.DONE (-4)\nngx.DECLINED (-5)\nngx.nil\n\n\nHTTP 请求方式\nngx.HTTP_GET\nngx.HTTP_HEAD\nngx.HTTP_PUT\nngx.HTTP_POST\nngx.HTTP_DELETE\nngx.HTTP_OPTIONS  \nngx.HTTP_MKCOL    \nngx.HTTP_COPY      \nngx.HTTP_MOVE     \nngx.HTTP_PROPFIND \nngx.HTTP_PROPPATCH \nngx.HTTP_LOCK \nngx.HTTP_UNLOCK    \nngx.HTTP_PATCH   \nngx.HTTP_TRACE  \n\n\nHTTP 返回状态\nngx.HTTP_OK (200)\nngx.HTTP_CREATED (201)\nngx.HTTP_SPECIAL_RESPONSE (300)\nngx.HTTP_MOVED_PERMANENTLY (301)\nngx.HTTP_MOVED_TEMPORARILY (302)\nngx.HTTP_SEE_OTHER (303)\nngx.HTTP_NOT_MODIFIED (304)\nngx.HTTP_BAD_REQUEST (400)\nngx.HTTP_UNAUTHORIZED (401)\nngx.HTTP_FORBIDDEN (403)\nngx.HTTP_NOT_FOUND (404)\nngx.HTTP_NOT_ALLOWED (405)\nngx.HTTP_GONE (410)\nngx.HTTP_INTERNAL_SERVER_ERROR (500)\nngx.HTTP_METHOD_NOT_IMPLEMENTED (501)\nngx.HTTP_SERVICE_UNAVAILABLE (503)\nngx.HTTP_GATEWAY_TIMEOUT (504)\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1>OpenResty</h1>\n<h2>介绍</h2>\n<pre><code>OpenResty\n    是一个基于 Nginx 与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。\n    用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。\n    通过汇聚各种设计精良的 Nginx 模块（主要由 OpenResty 团队自主开发），从而将 Nginx 有效地变成一个强大的通用 Web 应用平台。\n    这样，Web 开发人员和系统工程师可以使用 Lua 脚本语言调动 Nginx 支持的各种 C 以及 Lua 模块，快速构造出足以胜任 10K 乃至 1000K 以上单机并发连接的高性能 Web 应用系统。\n    OpenResty的目标是让你的Web服务直接跑在 Nginx 服务内部，充分利用 Nginx 的非阻塞 I/O 模型，不仅仅对 HTTP 客户端请求,\n    甚至于对远程后端诸如 MySQL、PostgreSQL、Memcached 以及 Redis 等都进行一致的高性能响应。\n</code></pre>\n<h2>安装</h2>\n<pre><code>1）下载安装\ncentos系统\n# yum install readline-devel pcre pcre-devel openssl openssl-devel gcc curl GeoIP-devel\n下载源码包\nhttps://github.com/openresty/openresty/releases\n选择最新版本v1.13.6.1\n解压安装\n# tar -xzvf openresty-1.13.6.1.tar.gz\n# cd openresty-1.13.6.1/\n\n##选择模块 ./configure --help\n\n# ./configure --with-luajit --with-pcre --with-http_gzip_static_module --with-http_realip_module --with-http_geoip_module --with-http_ssl_module  --with-http_stub_status_module \n\n--with-http_gzip_static_module #静态文件压缩\n--with-http_stub_status_module #监控nginx状态\n--with-http_realip_module #通过这个模块允许我们改变客户端请求头中客户端IP地址值(例如X-Real-IP 或 X-Forwarded-For)，意义在于能够使得后台服务器记录原始客户端的IP地址\n--with-pcre #设置PCRE库（pcre pcre-devel）\n--with-http_ssl_module #使用https协议模块。（openssl openssl-devel）\n--with-http_geoip_module #增加了根据ip获得城市信息，经纬度等模块 （GeoIP-devel）\n\n# make &amp;&amp; make install\n\n2）安装成功后，默认会在/usr/local/openresty/\n目录下\nluajit 是采用C语言写的Lua代码的解释器 ----just in time   即时解析\nlualib 是编辑好的lua类库\nnginx，其实我们openResty就是nginx，只是做了一些模块化工作；所以启动openResty就是启动nginx，我们可以到 cd nginx/sbin/，直接运行  ./nginx\n\n3）设置环境变量\n# vi /etc/profile\nexport NGINX_HOME=/usr/local/openresty/nginx\nexport PATH=$PATH:$NGINX_HOME/sbin\n# source /etc/profile ##生效\n</code></pre>\n<h2>简单例子 – Hello World</h2>\n<pre><code>1）ngx_lua模块的hello world\n编辑nginx下conf配置文件nginx.conf\n# vi nginx.conf\n在server模块加上\nlocation /helloworld {\n\tdefault_type text/html;\n    content_by_lua 'ngx.say(&quot;hello world&quot;)';\n}\n\n检查配置文件是否正确\n# /usr/local/openresty/nginx/sbin/nginx -t -c /usr/local/openresty/nginx/conf/nginx.conf\n\n重启nginx\n# ./nginx -s reload\n访问http://192.168.31.138/helloworld  输出 hello world\n\n2）nginx的内部变量\n\n名称 说明\n$arg_name 请求中的name参数\n$args 请求中的参数\n$binary_remote_addr 远程地址的二进制表示\n$body_bytes_sent 已发送的消息体字节数\n$content_length HTTP请求信息里的&quot;Content-Length&quot;\n$content_type 请求信息里的&quot;Content-Type&quot;\n$document_root 针对当前请求的根路径设置值\n$document_uri 与$uri相同; 比如 /test2/test.php\n$host 请求信息中的&quot;Host&quot;，如果请求中没有Host行，则等于设置的服务器名\n$hostname 机器名使用 gethostname系统调用的值\n$http_cookie cookie 信息\n$http_referer 引用地址\n$http_user_agent 客户端代理信息\n$http_via 最后一个访问服务器的Ip地址。\n$http_x_forwarded_for 相当于网络访问路径\n$is_args 如果请求行带有参数，返回“?”，否则返回空字符串\n$limit_rate 对连接速率的限制\n$nginx_version 当前运行的nginx版本号\n$pid worker进程的PID\n$query_string 与$args相同\n$realpath_root 按root指令或alias指令算出的当前请求的绝对路径。其中的符号链接都会解析成真是文件路径\n$remote_addr 客户端IP地址\n$remote_port 客户端端口号\n$remote_user 客户端用户名，认证用\n$request 用户请求\n$request_body 这个变量（0.7.58+）包含请求的主要信息。在使用proxy_pass或fastcgi_pass指令的location中比较有意义\n$request_body_file 客户端请求主体信息的临时文件名\n$request_completion 如果请求成功，设为&quot;OK&quot;；如果请求未完成或者不是一系列请求中最后一部分则设为空\n$request_filename 当前请求的文件路径名，比如/opt/nginx/www/test.php\n$request_method 请求的方法，比如&quot;GET&quot;、&quot;POST&quot;等\n$request_uri 请求的URI，带参数; 比如http://localhost:88/test1/\n$scheme 所用的协议，比如http或者是https\n$server_addr 服务器地址，如果没有用listen指明服务器地址，使用这个变量将发起一次系统调用以取得地址(造成资源浪费)\n$server_name 请求到达的服务器名\n$server_port 请求到达的服务器端口号\n$server_protocol 请求的协议版本，&quot;HTTP/1.0&quot;或&quot;HTTP/1.1&quot;\n$uri 请求的URI，可能和最初的值有不同，比如经过重定向之类的\n\n\n写个配置文件，测试一下$uri变量\nlocation /test_url {\n\techo &quot;url:$uri&quot;;\n}\n\nlocation /test_url {\n\t\t\techo &quot;url:$uri&quot;;\n\t\t\techo &quot;full url : $host$request_uri&quot;;\n\t\t}\n\t\t\n重启nginx，访问\n\n再此基础上测试$args变量\nlocation /test_url {\n\techo &quot;url:$uri----args:$args&quot;;\n}\n\n再此基础上测试$arg_name变量\nlocation /test_url {\n\techo &quot;url:$uri----args:$args--------arg_name:$arg_name&quot;;\n}\n\n说明一下，$arg_name表示取名为name的参数，如果想取其他名称的参数可以对应的取该参数名\nlocation /test_url {\n\techo &quot;url:$uri --- args:$args --- arg_name:$arg_name &lt;br/&gt;&quot;;\n\techo &quot;arg_user:$arg_user --- arg_age:$arg_age&lt;br/&gt;&quot;;\n\techo &quot;arg_test:$arg_test&quot;;\n}\n\ntest参数名不存在，则为空。\n自定义变量\nlocation /test_def {\n\tset $name &quot;rainbow&quot;;\n\techo $name;\n}\n\nset 设置的变量 为局部变量，其他请求无法获取此$name的值\nlocation /test_def {\n\tset $name &quot;rainbow&quot;;\n\techo_exec /test_def2;  ##内部跳转，可以传递变量\n}\nlocation /test_def2 {\n\techo $name;\n}\n</code></pre>\n<h2>Openresty中使用Lua</h2>\n<pre><code>openresty 引入 lua\n\n一）openresty中nginx引入lua方式\n\n  1）xxx_by_lua   ---&gt;字符串编写方式\n  2) xxx_by_lua_block ----&gt;代码块方式\n  3) xxx_by_lua_file  ----&gt;直接引用一个lua脚本文件\n\n我们案例中使用内容处理阶段，用content_by_lua演示\n\n-----------------编辑nginx.conf-----------------------\n\n第一种：content_by_lua\n\nlocation /testlua {\n  content_by_lua &quot;ngx.say('hello world')&quot;;\n}\n\n输出了hello world\n\ncontent_by_lua 方式，参数为字符串，编写不是太方便。\n\n----------------------------------------\n\n第二种：content_by_lua_block\nlocation /testlua {\n  content_by_lua_block {\n       ngx.say(&quot;hello world&quot;);\n  } \n}\n\ncontent_by_lua_block {}  表示内部为lua块，里面可以应用lua语句\n\n----------------------------------------\n\n第三种：content_by_lua_file\n\nlocation /testlua {\n  content_by_lua_file /usr/local/lua/test.lua;\n}\n\ncontent_by_lua_file 就是引用外部lua文件\n\n# vi  test.lua\nngx.say(&quot;hello world&quot;);\n\n\n二）openresty使用lua打印输出案例\n\n  location /testsay {\n    content_by_lua_block {\n        --写响应头  \n        ngx.header.a = &quot;1&quot;  \n        ngx.header.b = &quot;2&quot; \n        --输出响应  \n        ngx.say(&quot;a&quot;, &quot;b&quot;, &quot;&lt;br/&gt;&quot;)  \n        ngx.print(&quot;c&quot;, &quot;d&quot;, &quot;&lt;br/&gt;&quot;)  \n        --200状态码退出  \n        return ngx.exit(200) \n    } \n  }\n\n  ngx.header：输出响应头；\n  ngx.print：输出响应内容体；\n  ngx.say：通ngx.print，但是会最后输出一个换行符；\n  ngx.exit：指定状态码退出。\n\n三）介绍一下openresty使用lua常用的api\n\n1）ngx.var ： 获取Nginx变量 和 内置变量\n\nnginx内置的变量\n\n$arg_name 请求中的name参数\n$args 请求中的参数\n$binary_remote_addr 远程地址的二进制表示\n$body_bytes_sent  已发送的消息体字节数\n$content_length HTTP请求信息里的&quot;Content-Length&quot;\n$content_type 请求信息里的&quot;Content-Type&quot;\n$document_root  针对当前请求的根路径设置值\n$document_uri 与$uri相同; 比如 /test2/test.php\n$host 请求信息中的&quot;Host&quot;，如果请求中没有Host行，则等于设置的服务器名\n$hostname 机器名使用 gethostname系统调用的值\n$http_cookie  cookie 信息\n$http_referer 引用地址\n$http_user_agent  客户端代理信息\n$http_via 最后一个访问服务器的Ip地址。\n$http_x_forwarded_for 相当于网络访问路径\n$is_args  如果请求行带有参数，返回“?”，否则返回空字符串\n$limit_rate 对连接速率的限制\n$nginx_version  当前运行的nginx版本号\n$pid  worker进程的PID\n$query_string 与$args相同\n$realpath_root  按root指令或alias指令算出的当前请求的绝对路径。其中的符号链接都会解析成真是文件路径\n$remote_addr  客户端IP地址\n$remote_port  客户端端口号\n$remote_user  客户端用户名，认证用\n$request  用户请求\n$request_body 这个变量（0.7.58+）包含请求的主要信息。在使用proxy_pass或fastcgi_pass指令的location中比较有意义\n$request_body_file  客户端请求主体信息的临时文件名\n$request_completion 如果请求成功，设为&quot;OK&quot;；如果请求未完成或者不是一系列请求中最后一部分则设为空\n$request_filename 当前请求的文件路径名，比如/opt/nginx/www/test.php\n$request_method 请求的方法，比如&quot;GET&quot;、&quot;POST&quot;等\n$request_uri  请求的URI，带参数; 比如http://localhost:88/test1/\n$scheme 所用的协议，比如http或者是https\n$server_addr  服务器地址，如果没有用listen指明服务器地址，使用这个变量将发起一次系统调用以取得地址(造成资源浪费)\n$server_name  请求到达的服务器名\n$server_port  请求到达的服务器端口号\n$server_protocol  请求的协议版本，&quot;HTTP/1.0&quot;或&quot;HTTP/1.1&quot;\n$uri  请求的URI，可能和最初的值有不同，比如经过重定向之类的\n\nngx.var.xxx\n\nlocation /var {\n    set $c 3;\n\n    #处理业务\n    content_by_lua_block {\n      local a = tonumber(ngx.var.arg_a) or 0\n      local b = tonumber(ngx.var.arg_b) or 0\n      local c = tonumber(ngx.var.c) or 0\n      ngx.say(&quot;sum:&quot;, a + b + c )\n    }\n}\n\n注意：ngx.var.c 此变量必须提前声明；\n另外对于nginx location中使用正则捕获的捕获组可以使用ngx.var[捕获组数字]获取；\n\nlocation ~ ^/var/([0-9]+) {\n   content_by_lua_block {\n    ngx.say(&quot;var[1]:&quot;, ngx.var[1] )\n  }\n}\n\n2）ngx.req请求模块的常用api\n\n   ngx.req.get_headers：获取请求头，\n   获取带中划线的请求头时请使用如headers.user_agent这种方式；如果一个请求头有多个值，则返回的是table；\n\n-----------test.lua-------------------\n\nlocal headers = ngx.req.get_headers()  \nngx.say(&quot;============headers begin===============&quot;, &quot;&lt;br/&gt;&quot;)  \nngx.say(&quot;Host : &quot;, headers[&quot;Host&quot;], &quot;&lt;br/&gt;&quot;)  \nngx.say(&quot;headers['user-agent'] : &quot;, headers[&quot;user-agent&quot;], &quot;&lt;br/&gt;&quot;)  \nngx.say(&quot;headers.user_agent : &quot;, headers.user_agent, &quot;&lt;br/&gt;&quot;) \nngx.say(&quot;-------------遍历headers-----------&quot;, &quot;&lt;br/&gt;&quot;) \nfor k,v in pairs(headers) do  \n    if type(v) == &quot;table&quot; then  \n        ngx.say(k, &quot; : &quot;, table.concat(v, &quot;,&quot;), &quot;&lt;br/&gt;&quot;)  \n    else  \n        ngx.say(k, &quot; : &quot;, v, &quot;&lt;br/&gt;&quot;)  \n    end  \nend  \nngx.say(&quot;===========headers end============&quot;, &quot;&lt;br/&gt;&quot;)  \nngx.say(&quot;&lt;br/&gt;&quot;)  \n\n\n\n3）获取请求参数\n  ngx.req.get_uri_args：获取url请求参数，其用法和get_headers类似；\n  ngx.req.get_post_args：获取post请求内容体，其用法和get_headers类似，\n                         但是必须提前调用ngx.req.read_body()来读取body体\n                         （也可以选择在nginx配置文件使用lua_need_request_body on;开启读取body体，\n                           但是官方不推荐）；\n\n  ngx.req.get_body_data：为解析的请求body体内容字符串。\n\n---------------test.lua---------------\n\n--get请求uri参数  \nngx.say(&quot;===========uri get args begin==================&quot;, &quot;&lt;br/&gt;&quot;)  \nlocal uri_args = ngx.req.get_uri_args()  \nfor k, v in pairs(uri_args) do  \n    if type(v) == &quot;table&quot; then  \n        ngx.say(k, &quot; : &quot;, table.concat(v, &quot;, &quot;), &quot;&lt;br/&gt;&quot;)  \n    else  \n        ngx.say(k, &quot;: &quot;, v, &quot;&lt;br/&gt;&quot;)  \n    end  \nend  \nngx.say(&quot;===========uri get args end==================&quot;, &quot;&lt;br/&gt;&quot;) \n  \n--post请求参数  \nngx.req.read_body()  \nngx.say(&quot;=================post args begin====================&quot;, &quot;&lt;br/&gt;&quot;)  \nlocal post_args = ngx.req.get_post_args()  \nfor k, v in pairs(post_args) do  \n    if type(v) == &quot;table&quot; then  \n        ngx.say(k, &quot; : &quot;, table.concat(v, &quot;, &quot;), &quot;&lt;br/&gt;&quot;)  \n    else  \n        ngx.say(k, &quot;: &quot;, v, &quot;&lt;br/&gt;&quot;)  \n    end  \nend  \nngx.say(&quot;================post args end=====================&quot;, &quot;&lt;br/&gt;&quot;)  \n  \n\n4) ngx.req其他常用的api\n--请求的http协议版本  \nngx.say(&quot;ngx.req.http_version : &quot;, ngx.req.http_version(), &quot;&lt;br/&gt;&quot;)  \n--请求方法  \nngx.say(&quot;ngx.req.get_method : &quot;, ngx.req.get_method(), &quot;&lt;br/&gt;&quot;)  \n--原始的请求头内容  \nngx.say(&quot;ngx.req.raw_header : &quot;,  ngx.req.raw_header(), &quot;&lt;br/&gt;&quot;)  \n--请求的body内容体  \nngx.say(&quot;ngx.req.get_body_data() : &quot;, ngx.req.get_body_data(), &quot;&lt;br/&gt;&quot;)  \nngx.say(&quot;&lt;br/&gt;&quot;)  \n\nngx.req.raw_header()这个函数返回值为字符串\n\n5）编码解码\n\nngx.escape_uri/ngx.unescape_uri ： uri编码解码；\n\nngx.encode_args/ngx.decode_args：参数编码解码；\n\nngx.encode_base64/ngx.decode_base64：BASE64编码解码；\n\n-------test.lua\n\n--未经解码的请求uri  \nlocal request_uri = ngx.var.request_uri;  \nngx.say(&quot;request_uri : &quot;, request_uri, &quot;&lt;br/&gt;&quot;); \n\n--编码\nlocal escape_uri = ngx.escape_uri(request_uri)\nngx.say(&quot;escape_uri : &quot;, escape_uri, &quot;&lt;br/&gt;&quot;); \n\n--解码  \nngx.say(&quot;decode request_uri : &quot;, ngx.unescape_uri(escape_uri), &quot;&lt;br/&gt;&quot;);\n\n--参数编码\nlocal request_uri = ngx.var.request_uri;\nlocal question_pos, _ = string.find(request_uri, '?')\nif question_pos&gt;0 then\n  local uri = string.sub(request_uri, 1, question_pos-1)\n  ngx.say(&quot;uri sub=&quot;,string.sub(request_uri, question_pos+1),&quot;&lt;br/&gt;&quot;);\n  \n  --对字符串进行解码\n  local args = ngx.decode_args(string.sub(request_uri, question_pos+1))\n  \n  for k,v in pairs(args) do\n    ngx.say(&quot;k=&quot;,k,&quot;,v=&quot;, v, &quot;&lt;br/&gt;&quot;);\n  end\n  \n  if args and args.userId then\n    args.userId = args.userId + 10000\n    ngx.say(&quot;args+10000 : &quot;, uri .. '?' .. ngx.encode_args(args), &quot;&lt;br/&gt;&quot;);\n  end\nend\n\n6）md5加密api\n--MD5  \nngx.say(&quot;ngx.md5 : &quot;, ngx.md5(&quot;123&quot;), &quot;&lt;br/&gt;&quot;)  \n\n7）nginx获取时间\n\n之前介绍的os.time()会涉及系统调用，性能比较差，推荐使用nginx中的时间api\n\nngx.time()  --返回秒级精度的时间戳\nngx.now()   --返回毫秒级精度的时间戳\n\n就是通过这两种方式获取到的只是nginx缓存起来的时间戳，不是实时的。\n所以有时候会出现一些比较奇怪的现象，比如下面代码：\n\nlocal t1 = ngx.now()\nfor i=1,1000000 do\nend\nlocal t2 = ngx.now()\nprint(t1, &quot;,&quot;, t2) -- t1和t2的值是一样的，why？\nngx.exit(200)\n\n正常来说，t2应该大于t1才对，但由于nginx没有及时更新（缓存的）时间戳，所以导致t2和t1获取到的时间戳是一样的。\n那么怎样才能强迫nginx更新缓存呢？调用多一个ngx.update_time()函数即可：\n\nlocal t1 = ngx.now()\nfor i=1,1000000 do\nend\nngx.update_time()\nlocal t2 = ngx.now()\nprint(t1, &quot;,&quot;, t2) \nngx.exit(200)\n\n8）ngx.re模块中正则表达式相关的api\n\nngx.re.match\nngx.re.sub\nngx.re.gsub\nngx.re.find\nngx.re.gmatch\n\n我们这里只简单的介绍 ngx.re.match，详细用法可以自行去网上学习\n\nngx.re.match\n只有第一次匹配的结果被返回，如果没有匹配，则返回nil；或者匹配过程中出现错误时，\n也会返回nil，此时错误信息会被保存在err中。\n\n当匹配的字符串找到时，一个Lua table captures会被返回，\ncaptures[0]中保存的就是匹配到的字串，\ncaptures[1]保存的是用括号括起来的第一个子模式（捕获分组）的结果，\ncaptures[2]保存的是第二个子模式（捕获分组）的结果，依次类似。\n\n---------------------\n\nlocal m, err = ngx.re.match(&quot;hello, 1234&quot;, &quot;[0-9]+&quot;)\nif m then\n  ngx.say(m[0])\nelse\n  if err then\n    ngx.log(ngx.ERR, &quot;error: &quot;, err)\n    return\n  end\n\n  ngx.say(&quot;match not found&quot;)\nend\n\n上面例子中，匹配的字符串是1234，因此m[0] == &quot;1234&quot;，\n--------------\n\nlocal m, err = ngx.re.match(&quot;hello, 1234&quot;, &quot;([0-9])[0-9]+&quot;)\nngx.say(m[0],&quot;&lt;br/&gt;&quot;)\nngx.say(m[1])\n\n\n---------------------------------------------------------\n\n\n备注：有没有注意到，我们每次修改都要重启nginx，这样太过于麻烦，我们可以用\ncontent_by_lua_file 引入外部lua，这样的话 只要修改外部的lua，就可以了，不需要重启nginx了。\n注意需要把lua_code_cache 设置为off\n\n语法：lua_code_cache on | off\n默认： on\n适用上下文：http、server、location、location if\n这个指令是指定是否开启lua的代码编译缓存，开发时可以设置为off，以便lua文件实时生效，\n如果是生产线上，为了性能，建议开启。\n最终nginx.conf修改为\n\n以后我们只要修改test.lua 文件就可以了。\n\n9）标准日志输出\n\nngx.log(log_level, ...) \n\n日志输出级别\n\nngx.STDERR     -- 标准输出\nngx.EMERG      -- 紧急报错\nngx.ALERT      -- 报警\nngx.CRIT       -- 严重，系统故障，触发运维告警系统\nngx.ERR        -- 错误，业务不可恢复性错误\nngx.WARN       -- 告警，业务中可忽略错误\nngx.NOTICE     -- 提醒，业务比较重要信息\nngx.INFO       -- 信息，业务琐碎日志信息，包含不同情况判断等\nngx.DEBUG      -- 调试\n\n-------------------------------------\n\n#user  nobody;\nworker_processes  1;\n\nerror_log  logs/error.log error;    # 日志级别\n#pid        logs/nginx.pid;\n\nevents {\n    worker_connections  1024;\n}\n\nhttp {\n    server {\n        listen    80;\n        location / {\n            content_by_lua_block {\n                local num = 55\n                local str = &quot;string&quot;\n                local obj\n                ngx.log(ngx.ERR, &quot;num:&quot;, num)\n                ngx.log(ngx.INFO, &quot; string:&quot;, str)\n                print([[i am print]])\n                ngx.log(ngx.ERR, &quot; object:&quot;, obj)\n            }\n        }\n    }\n}\n\n日志输出级别使用的 error，只有等于或大于这个级别的日志才会输出\n\nngx.DEBUG\nngx.WARN\n\n对于应用开发，一般使用 ngx.INFO 到 ngx.CRIT 就够了。生产中错误日志开启到 error 级别就够了\n\n10）重定向 ngx.redirect\n\n-----重定向\n\nlocation = /bar {\n  content_by_lua_block {\n    ngx.say([[I am bar]])\n  }\n}\n\nlocation = /foo {\n  rewrite_by_lua_block {\n    return ngx.redirect('/bar');\n  }\n}\n\n\n11）不同阶段共享变量\n\nngx.ctx 全局共享变量\n\n在 OpenResty 的体系中，可以通过共享内存的方式完成不同工作进程的数据共享，\n本地内存方式 去让不同的工作进程共享数据\n\nopenresty有不同处理阶段，后面的课程会介绍。在不同的处理阶段，如何共享数据\n\n可以通过 Lua 模块方式完成单个进程内不同请求的数据共享。如何完成单个请求内不同阶段的数据共享呢？\n\nngx.ctx 表就是为了解决这类问题而设计的。参考下面例子：\n\nlocation /test {\n     rewrite_by_lua_block {\n         ngx.ctx.foo = 76\n     }\n     access_by_lua_block {\n         ngx.ctx.foo = ngx.ctx.foo + 3\n     }\n     content_by_lua_block {\n         ngx.say(ngx.ctx.foo)\n     }\n }\n\n ngx.ctx.xxxxx\n\n首先 ngx.ctx 是一个表，所以我们可以对他添加、修改。它用来存储基于请求的 Lua 环境数据，\n其生存周期与当前请求相同 (类似 Nginx 变量)。它有一个最重要的特性：\n单个请求内的 rewrite (重写)，access (访问)，和 content (内容) 等各处理阶段是保持一致的。\n\n额外注意，每个请求，包括子请求，都有一份自己的 ngx.ctx 表。例如：\n\n location /sub {\n     content_by_lua_block {\n         ngx.say(&quot;sub pre: &quot;, ngx.ctx.blah)\n         ngx.ctx.blah = 32\n         ngx.say(&quot;sub post: &quot;, ngx.ctx.blah)\n     }\n }\n\n location /main {\n     content_by_lua_block {\n         ngx.ctx.blah = 73\n         ngx.say(&quot;main pre: &quot;, ngx.ctx.blah)\n         local res = ngx.location.capture(&quot;/sub&quot;)\n         ngx.print(res.body)\n         ngx.say(&quot;main post: &quot;, ngx.ctx.blah)\n     }\n }\n\nngx.ctx 表查询需要相对昂贵的元方法调用，这比通过用户自己的函数参数直接传递基于请求的数据要慢得多。\n所以不要为了节约用户函数参数而滥用此 API，因为它可能对性能有明显影响。\n\n由于 ngx.ctx 保存的是指定请求资源，所以这个变量是不能直接共享给其他请求使用的。\n\n\n更多api使用  https://www.nginx.com/resources/wiki/modules/lua/#nginx-api-for-lua\n\n操作指令  说明\nngx.arg 指令参数，如跟在content_by_lua_file后面的参数\nngx.var 变量，ngx.var.VARIABLE引用某个变量\nngx.ctx 请求的lua上下文\nngx.header  响应头，ngx.header.HEADER引用某个头\nngx.status  响应码\n\nAPI 说明\nngx.log 输出到error.log\nprint 等价于 ngx.log(ngx.NOTICE, ...)\nngx.send_headers  发送响应头\nngx.headers_sent  响应头是否已发送\nngx.resp.get_headers  获取响应头\nngx.timer.at  注册定时器事件\nngx.is_subrequest 当前请求是否是子请求\nngx.location.capture  发布一个子请求\nngx.location.capture_multi  发布多个子请求\nngx.exec   \nngx.redirect   \nngx.print 输出响应\nngx.say 输出响应，自动添加'n'\nngx.flush 刷新响应\nngx.exit  结束请求\nngx.eof  \nngx.sleep 无阻塞的休眠（使用定时器实现）\nngx.get_phase  \nngx.on_abort  注册client断开请求时的回调函数\nndk.set_var.DIRECTIVE  \nngx.req.start_time  请求的开始时间\nngx.req.http_version  请求的HTTP版本号\nngx.req.raw_header  请求头（包括请求行）\nngx.req.get_method  请求方法\nngx.req.set_method  请求方法重载\nngx.req.set_uri 请求URL重写\nngx.req.set_uri_args   \nngx.req.get_uri_args  获取请求参数\nngx.req.get_post_args 获取请求表单\nngx.req.get_headers 获取请求头\nngx.req.set_header   \nngx.req.clear_header   \nngx.req.read_body 读取请求体\nngx.req.discard_body  扔掉请求体\nngx.req.get_body_data  \nngx.req.get_body_file  \nngx.req.set_body_data  \nngx.req.set_body_file  \nngx.req.init_body  \nngx.req.append_body  \nngx.req.finish_body  \nngx.req.socket   \nngx.escape_uri  字符串的url编码\nngx.unescape_uri  字符串url解码\nngx.encode_args 将table编码为一个参数字符串\nngx.decode_args 将参数字符串编码为一个table\nngx.encode_base64 字符串的base64编码\nngx.decode_base64 字符串的base64解码\nngx.crc32_short 字符串的crs32_short哈希\nngx.crc32_long  字符串的crs32_long哈希\nngx.hmac_sha1 字符串的hmac_sha1哈希\nngx.md5 返回16进制MD5\nngx.md5_bin 返回2进制MD5\nngx.sha1_bin  返回2进制sha1哈希值\nngx.quote_sql_str SQL语句转义\nngx.today 返回当前日期\nngx.time  返回UNIX时间戳\nngx.now 返回当前时间\nngx.update_time 刷新时间后再返回\nngx.localtime  \nngx.utctime  \nngx.cookie_time 返回的时间可用于cookie值\nngx.http_time 返回的时间可用于HTTP头\nngx.parse_http_time 解析HTTP头的时间\nngx.re.match   \nngx.re.find  \nngx.re.gmatch  \nngx.re.sub   \nngx.re.gsub  \nngx.shared.DICT  \nngx.shared.DICT.get  \nngx.shared.DICT.get_stale  \nngx.shared.DICT.set  \nngx.shared.DICT.safe_set   \nngx.shared.DICT.add  \nngx.shared.DICT.safe_add   \nngx.shared.DICT.replace  \nngx.shared.DICT.delete   \nngx.shared.DICT.incr   \nngx.shared.DICT.flush_all  \nngx.shared.DICT.flush_expired  \nngx.shared.DICT.get_keys   \nngx.socket.udp   \nudpsock:setpeername  \nudpsock:send   \nudpsock:receive  \nudpsock:close  \nudpsock:settimeout   \nngx.socket.tcp   \ntcpsock:connect  \ntcpsock:sslhandshake   \ntcpsock:send   \ntcpsock:receive  \ntcpsock:receiveuntil   \ntcpsock:close  \ntcpsock:settimeout   \ntcpsock:setoption  \ntcpsock:setkeepalive   \ntcpsock:getreusedtimes   \nngx.socket.connect   \nngx.thread.spawn   \nngx.thread.wait  \nngx.thread.kill  \ncoroutine.create   \ncoroutine.resume   \ncoroutine.yield  \ncoroutine.wrap   \ncoroutine.running  \ncoroutine.status   \nngx.config.debug  编译时是否有 --with-debug选项\nngx.config.prefix 编译时的 --prefix选项\nngx.config.nginx_version  返回nginx版本号\nngx.config.nginx_configure  返回编译时 ./configure的命令行选项\nngx.config.ngx_lua_version  返回ngx_lua模块版本号\nngx.worker.exiting  当前worker进程是否正在关闭（如reload、shutdown期间）\nngx.worker.pid  返回当前worker进程的pid\n   \n常量说明\nngx.OK (0)\nngx.ERROR (-1)\nngx.AGAIN (-2)\nngx.DONE (-4)\nngx.DECLINED (-5)\nngx.nil\n\n\nHTTP 请求方式\nngx.HTTP_GET\nngx.HTTP_HEAD\nngx.HTTP_PUT\nngx.HTTP_POST\nngx.HTTP_DELETE\nngx.HTTP_OPTIONS  \nngx.HTTP_MKCOL    \nngx.HTTP_COPY      \nngx.HTTP_MOVE     \nngx.HTTP_PROPFIND \nngx.HTTP_PROPPATCH \nngx.HTTP_LOCK \nngx.HTTP_UNLOCK    \nngx.HTTP_PATCH   \nngx.HTTP_TRACE  \n\n\nHTTP 返回状态\nngx.HTTP_OK (200)\nngx.HTTP_CREATED (201)\nngx.HTTP_SPECIAL_RESPONSE (300)\nngx.HTTP_MOVED_PERMANENTLY (301)\nngx.HTTP_MOVED_TEMPORARILY (302)\nngx.HTTP_SEE_OTHER (303)\nngx.HTTP_NOT_MODIFIED (304)\nngx.HTTP_BAD_REQUEST (400)\nngx.HTTP_UNAUTHORIZED (401)\nngx.HTTP_FORBIDDEN (403)\nngx.HTTP_NOT_FOUND (404)\nngx.HTTP_NOT_ALLOWED (405)\nngx.HTTP_GONE (410)\nngx.HTTP_INTERNAL_SERVER_ERROR (500)\nngx.HTTP_METHOD_NOT_IMPLEMENTED (501)\nngx.HTTP_SERVICE_UNAVAILABLE (503)\nngx.HTTP_GATEWAY_TIMEOUT (504)\n</code></pre>\n"}],"PostAsset":[{"_id":"source/_posts/RabbitMQ学习-1-概念与认识/vhost.png","slug":"vhost.png","post":"cjpw2eyfc0001n0uj6qu6ga4j","modified":0,"renderable":0},{"_id":"source/_posts/hexo-theme-beantech/home_posts_tag-false.png","slug":"home_posts_tag-false.png","post":"cjpw2eyfl0004n0uj1n0kv5xr","modified":0,"renderable":0},{"_id":"source/_posts/微服务API网关框架-1/多节点场景网关.png","slug":"多节点场景网关.png","post":"cjpw2eyfp0006n0ujay58202c","modified":0,"renderable":0},{"_id":"source/_posts/微服务API网关框架-1/架构2.png","slug":"架构2.png","post":"cjpw2eyfp0006n0ujay58202c","modified":0,"renderable":0},{"_id":"source/_posts/微服务API网关框架-1/架构.png","slug":"架构.png","post":"cjpw2eyfp0006n0ujay58202c","modified":0,"renderable":0},{"_id":"source/_posts/微服务API网关框架-1/正向代理.png","slug":"正向代理.png","post":"cjpw2eyfp0006n0ujay58202c","modified":0,"renderable":0},{"_id":"source/_posts/微服务API网关框架-1/架构3.png","slug":"架构3.png","post":"cjpw2eyfp0006n0ujay58202c","modified":0,"renderable":0},{"_id":"source/_posts/RabbitMQ学习-1-概念与认识/用户管理-添加用户.png","slug":"用户管理-添加用户.png","post":"cjpw2eyfc0001n0uj6qu6ga4j","modified":0,"renderable":0},{"_id":"source/_posts/hexo-theme-beantech/home_posts_tag-true.png","slug":"home_posts_tag-true.png","post":"cjpw2eyfl0004n0uj1n0kv5xr","modified":0,"renderable":0},{"_id":"source/_posts/微服务API网关框架-2/Demo.png","slug":"Demo.png","post":"cjpw2eyfw000an0ujhz3bxf4f","modified":0,"renderable":0},{"_id":"source/_posts/微服务API网关框架-3/Demo.png","slug":"Demo.png","post":"cjpw2eyft0009n0uj4pb1dbkm","modified":0,"renderable":0},{"_id":"source/_posts/RabbitMQ学习-2-队列模型/Demo.png","slug":"Demo.png","post":"cjpw2eyfg0002n0ujkhf6vlcc","modified":0,"renderable":0},{"_id":"source/_posts/RabbitMQ学习-2-队列模型/工作队列.png","slug":"工作队列.png","post":"cjpw2eyfg0002n0ujkhf6vlcc","modified":0,"renderable":0},{"_id":"source/_posts/RabbitMQ学习-2-队列模型/简单队列.png","slug":"简单队列.png","post":"cjpw2eyfg0002n0ujkhf6vlcc","modified":0,"renderable":0},{"_id":"source/_posts/hexo-theme-beantech/Demo.png","slug":"Demo.png","post":"cjpw2eyfl0004n0uj1n0kv5xr","modified":0,"renderable":0},{"_id":"source/_posts/基于Golang的gRPC使用笔记1/Demo.png","slug":"Demo.png","post":"cjpw2eyfn0005n0ujbmnh9c96","modified":0,"renderable":0},{"_id":"source/_posts/基于Golang的gRPC使用笔记1/gRPC特点.png","slug":"gRPC特点.png","post":"cjpw2eyfn0005n0ujbmnh9c96","modified":0,"renderable":0},{"_id":"source/_posts/基于Golang的gRPC使用笔记1/gRPC调用示例.png","slug":"gRPC调用示例.png","post":"cjpw2eyfn0005n0ujbmnh9c96","modified":0,"renderable":0},{"_id":"source/_posts/基于Golang的gRPC使用笔记1/rpc原理图.png","slug":"rpc原理图.png","post":"cjpw2eyfn0005n0ujbmnh9c96","modified":0,"renderable":0},{"_id":"source/_posts/微服务API网关框架-1/Demo.png","slug":"Demo.png","post":"cjpw2eyfp0006n0ujay58202c","modified":0,"renderable":0},{"_id":"source/_posts/微服务API网关框架-1/单节点场景网关.png","slug":"单节点场景网关.png","post":"cjpw2eyfp0006n0ujay58202c","modified":0,"renderable":0},{"_id":"source/_posts/微服务API网关框架-1/反向代理.png","slug":"反向代理.png","post":"cjpw2eyfp0006n0ujay58202c","modified":0,"renderable":0},{"_id":"source/_posts/微服务API网关框架-1/新旧进程同在.png","slug":"新旧进程同在.png","post":"cjpw2eyfp0006n0ujay58202c","modified":0,"renderable":0},{"_id":"source/_posts/RabbitMQ学习-1-概念与认识/Demo.png","slug":"Demo.png","post":"cjpw2eyfc0001n0uj6qu6ga4j","modified":0,"renderable":0},{"_id":"source/_posts/RabbitMQ学习-1-概念与认识/v-host授权.png","slug":"v-host授权.png","post":"cjpw2eyfc0001n0uj6qu6ga4j","modified":0,"renderable":0},{"_id":"source/_posts/RabbitMQ学习-1-概念与认识/v-host授权2.png","slug":"v-host授权2.png","post":"cjpw2eyfc0001n0uj6qu6ga4j","modified":0,"renderable":0},{"_id":"source/_posts/RabbitMQ学习-1-概念与认识/v-host授权后.png","slug":"v-host授权后.png","post":"cjpw2eyfc0001n0uj6qu6ga4j","modified":0,"renderable":0},{"_id":"source/_posts/RabbitMQ学习-1-概念与认识/v-host添加.png","slug":"v-host添加.png","post":"cjpw2eyfc0001n0uj6qu6ga4j","modified":0,"renderable":0},{"_id":"source/_posts/RabbitMQ学习-1-概念与认识/异步处理.png","slug":"异步处理.png","post":"cjpw2eyfc0001n0uj6qu6ga4j","modified":0,"renderable":0},{"_id":"source/_posts/RabbitMQ学习-1-概念与认识/日志收集与处理.png","slug":"日志收集与处理.png","post":"cjpw2eyfc0001n0uj6qu6ga4j","modified":0,"renderable":0},{"_id":"source/_posts/RabbitMQ学习-1-概念与认识/秒杀抢购.png","slug":"秒杀抢购.png","post":"cjpw2eyfc0001n0uj6qu6ga4j","modified":0,"renderable":0},{"_id":"source/_posts/RabbitMQ学习-1-概念与认识/系统解耦.png","slug":"系统解耦.png","post":"cjpw2eyfc0001n0uj6qu6ga4j","modified":0,"renderable":0},{"_id":"source/_posts/微服务API网关框架-4/Demo.png","slug":"Demo.png","post":"cjpw2eyh3000on0ujc440506d","modified":0,"renderable":0},{"_id":"source/_posts/微服务API网关框架-6/Demo.png","slug":"Demo.png","post":"cjpw2eyh9000tn0ujean5z4a3","modified":0,"renderable":0},{"_id":"source/_posts/微服务API网关框架-5/Demo.png","slug":"Demo.png","post":"cjpw2eyh6000qn0ujoi3vpzq8","modified":0,"renderable":0}],"PostCategory":[],"PostTag":[{"post_id":"cjpw2eyfc0001n0uj6qu6ga4j","tag_id":"cjpw2eyfj0003n0ujzaag7ew1","_id":"cjpw2eyfs0008n0uj4xuh6ap8"},{"post_id":"cjpw2eyfg0002n0ujkhf6vlcc","tag_id":"cjpw2eyfj0003n0ujzaag7ew1","_id":"cjpw2eyfy000cn0ujg5izbhls"},{"post_id":"cjpw2eyfl0004n0uj1n0kv5xr","tag_id":"cjpw2eyfx000bn0ujrahbshot","_id":"cjpw2eyg7000en0uj184zvmd5"},{"post_id":"cjpw2eyfn0005n0ujbmnh9c96","tag_id":"cjpw2eyg4000dn0ujtw6zki9b","_id":"cjpw2eygj000hn0ujf8fao319"},{"post_id":"cjpw2eyfn0005n0ujbmnh9c96","tag_id":"cjpw2eygc000fn0uj3uxag3v7","_id":"cjpw2eygk000in0uj8o1u2o0a"},{"post_id":"cjpw2eyfp0006n0ujay58202c","tag_id":"cjpw2eygg000gn0ujtwv0wmy2","_id":"cjpw2eygm000kn0ujvhbplhn4"},{"post_id":"cjpw2eyft0009n0uj4pb1dbkm","tag_id":"cjpw2eygg000gn0ujtwv0wmy2","_id":"cjpw2eygo000mn0ujbsg0st0l"},{"post_id":"cjpw2eyfw000an0ujhz3bxf4f","tag_id":"cjpw2eygg000gn0ujtwv0wmy2","_id":"cjpw2eygp000nn0ujgb8q8bpa"},{"post_id":"cjpw2eyh3000on0ujc440506d","tag_id":"cjpw2eygg000gn0ujtwv0wmy2","_id":"cjpw2eyh8000sn0uj8tzl4daj"},{"post_id":"cjpw2eyh6000qn0ujoi3vpzq8","tag_id":"cjpw2eygg000gn0ujtwv0wmy2","_id":"cjpw2eyhc000vn0uju8yqsi7y"},{"post_id":"cjpw2eyh9000tn0ujean5z4a3","tag_id":"cjpw2eygg000gn0ujtwv0wmy2","_id":"cjpw2eyhd000wn0ujuqs5pu9b"}],"Tag":[{"name":"RabbitMQ 消息队列","_id":"cjpw2eyfj0003n0ujzaag7ew1"},{"name":"Hexo","_id":"cjpw2eyfx000bn0ujrahbshot"},{"name":"gRPC","_id":"cjpw2eyg4000dn0ujtw6zki9b"},{"name":"golang","_id":"cjpw2eygc000fn0uj3uxag3v7"},{"name":"微服务API网关","_id":"cjpw2eygg000gn0ujtwv0wmy2"}]}}