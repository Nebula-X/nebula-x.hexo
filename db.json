{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/img/avatar.jpg","path":"img/avatar.jpg","modified":1,"renderable":0},{"_id":"source/img/icon_wechat.png","path":"img/icon_wechat.png","modified":1,"renderable":0},{"_id":"source/img/404-bg.jpg","path":"img/404-bg.jpg","modified":1,"renderable":0},{"_id":"source/img/signature/nebula-black.png","path":"img/signature/nebula-black.png","modified":1,"renderable":0},{"_id":"source/img/signature/nebula-white.png","path":"img/signature/nebula-white.png","modified":1,"renderable":0},{"_id":"themes/beantech/source/css/beantech.css","path":"css/beantech.css","modified":1,"renderable":1},{"_id":"themes/beantech/source/css/beantech.min.css","path":"css/beantech.min.css","modified":1,"renderable":1},{"_id":"themes/beantech/source/css/archive.styl","path":"css/archive.styl","modified":1,"renderable":1},{"_id":"themes/beantech/source/css/highlight.styl","path":"css/highlight.styl","modified":1,"renderable":1},{"_id":"themes/beantech/source/css/hux-blog.min.css","path":"css/hux-blog.min.css","modified":1,"renderable":1},{"_id":"themes/beantech/source/css/signature.styl","path":"css/signature.styl","modified":1,"renderable":1},{"_id":"themes/beantech/source/css/rocket.styl","path":"css/rocket.styl","modified":1,"renderable":1},{"_id":"themes/beantech/source/css/toc.styl","path":"css/toc.styl","modified":1,"renderable":1},{"_id":"themes/beantech/source/css/widget.styl","path":"css/widget.styl","modified":1,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":1,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":1,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":1,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":1,"renderable":1},{"_id":"themes/beantech/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":1,"renderable":1},{"_id":"themes/beantech/source/js/hux-blog.js","path":"js/hux-blog.js","modified":1,"renderable":1},{"_id":"themes/beantech/source/js/hux-blog.min.js","path":"js/hux-blog.min.js","modified":1,"renderable":1},{"_id":"themes/beantech/source/js/jquery.nav.js","path":"js/jquery.nav.js","modified":1,"renderable":1},{"_id":"themes/beantech/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":1,"renderable":1},{"_id":"themes/beantech/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1},{"_id":"themes/beantech/source/js/toc.js","path":"js/toc.js","modified":1,"renderable":1},{"_id":"source/img/header_img/Iron-Man-3.jpg","path":"img/header_img/Iron-Man-3.jpg","modified":1,"renderable":0},{"_id":"themes/beantech/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":1,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":1,"renderable":1},{"_id":"themes/beantech/source/js/bootstrap.js","path":"js/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/beantech/source/js/jquery.min.js","path":"js/jquery.min.js","modified":1,"renderable":1},{"_id":"source/img/contact-bg.jpg","path":"img/contact-bg.jpg","modified":1,"renderable":0},{"_id":"themes/beantech/source/css/bootstrap.css","path":"css/bootstrap.css","modified":1,"renderable":1},{"_id":"themes/beantech/source/css/images/rocket.png","path":"css/images/rocket.png","modified":1,"renderable":1},{"_id":"themes/beantech/source/css/images/ironman.png","path":"css/images/ironman.png","modified":1,"renderable":1},{"_id":"source/img/header_img/tf-logo-dark.png","path":"img/header_img/tf-logo-dark.png","modified":1,"renderable":0},{"_id":"themes/beantech/source/js/jquery.js","path":"js/jquery.js","modified":1,"renderable":1},{"_id":"source/img/beantech-desktop.png","path":"img/beantech-desktop.png","modified":1,"renderable":0},{"_id":"source/img/header_img/tag-bg.png","path":"img/header_img/tag-bg.png","modified":1,"renderable":0},{"_id":"source/img/header_img/home-bg-o.png","path":"img/header_img/home-bg-o.png","modified":1,"renderable":0},{"_id":"source/img/header_img/home-bg-2-dark.png","path":"img/header_img/home-bg-2-dark.png","modified":1,"renderable":0},{"_id":"source/img/header_img/archive-bg.png","path":"img/header_img/archive-bg.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/CNAME","hash":"c9e7a36a848473962a7689ab37caf5b9347af655","modified":1541671811512},{"_id":"source/404.md","hash":"8d0d831a77fe92a9e1530366ed90dec6d73d3aef","modified":1541580566620},{"_id":"themes/beantech/LICENSE","hash":"c48eaae47a703282e0ffe7b91d69366452046214","modified":1541580566723},{"_id":"themes/beantech/_config.yml","hash":"f0796b8e85fe6b3154a5fa442420003fe18dff0a","modified":1541580566724},{"_id":"source/_posts/Lua脚本教程-1.md","hash":"020f0de6d836be42a9ec54a5e8fefc28384927ce","modified":1545018460091},{"_id":"source/_posts/Lua脚本教程-2.md","hash":"fec9d46eeeeea5939301b91001214ee351bdc596","modified":1545018094805},{"_id":"source/_posts/Lua脚本教程-3.md","hash":"0343c751d67570040ef0443457030de3618388bb","modified":1545026925107},{"_id":"source/_posts/RabbitMQ学习-1-概念与认识.md","hash":"548033a77e893122ebf44d08f44375ce59295e23","modified":1542780967799},{"_id":"source/_posts/RabbitMQ学习-2-队列模型.md","hash":"7fe3250c6cb123a47088a9fc53200861dbca1620","modified":1543106057568},{"_id":"source/_posts/hexo-theme-beantech.md","hash":"d7b8618bbd1a4897781c9a75309c02e097d4d74e","modified":1541807596362},{"_id":"source/_posts/基于Golang的gRPC使用笔记1.md","hash":"c2686645ab891e09e60d2651dca34e60d6be542e","modified":1542725365945},{"_id":"source/_posts/微服务API网关框架-1.md","hash":"0dcff76be4e45b4e7adabb7008210485614b146a","modified":1545209139151},{"_id":"source/_posts/微服务API网关框架-2.md","hash":"2bcbefa0bff76308a381d58bc15d444ec76ccc1d","modified":1545210008672},{"_id":"source/archive/index.md","hash":"971fdb6d0fc384fe1301dc82a68568d5ab29d332","modified":1541726039442},{"_id":"source/about/index.md","hash":"28611a9a0b9074734fce81b4f6669bf652a1b4c3","modified":1541726221596},{"_id":"source/img/avatar.jpg","hash":"77c450e6ef9c5c243fdd212a87fedda945718382","modified":1541691053456},{"_id":"source/img/icon_wechat.png","hash":"4188058026609de06c6cac88b349a2da831a1783","modified":1541580566711},{"_id":"themes/beantech/languages_to_be_added/de.yml","hash":"02a98ba2b93e30a00ae7979fbe90b767a27290f0","modified":1541580566725},{"_id":"source/tags/index.md","hash":"d8fbfb47afcf8bbf75c4b1244d5727e20a01cd99","modified":1541726588994},{"_id":"themes/beantech/languages_to_be_added/default.yml","hash":"3cd0873b310cbf2fe022ee18d55a6113b347ea09","modified":1541580566726},{"_id":"themes/beantech/languages_to_be_added/en.yml","hash":"3cd0873b310cbf2fe022ee18d55a6113b347ea09","modified":1541580566726},{"_id":"themes/beantech/languages_to_be_added/es.yml","hash":"fb089145368422ac47da9eb00fed05b15c904aa2","modified":1541580566727},{"_id":"themes/beantech/languages_to_be_added/no.yml","hash":"5ce3a1043ff85cecf83f3b5b0cdad2df44fa0192","modified":1541580566728},{"_id":"themes/beantech/languages_to_be_added/pl.yml","hash":"6dc5d1b2aa75ae4c527089a770f43bafb91d80f4","modified":1541580566729},{"_id":"themes/beantech/languages_to_be_added/zh-CN.yml","hash":"6d712d9eb6ba12213dcd76b532cd86e9da83cfa3","modified":1541580566730},{"_id":"themes/beantech/languages_to_be_added/zh-TW.yml","hash":"45c84384a05fdb7e32a3e2d498ea180be7dccfa9","modified":1541580566731},{"_id":"themes/beantech/languages_to_be_added/ru.yml","hash":"2cfaf93704ea4ac3f374c69bab89ca31916faa33","modified":1541580566730},{"_id":"themes/beantech/layout/404.ejs","hash":"c9b488d74c21fe9f35f642a5d19a138099ddf8a8","modified":1541580566732},{"_id":"themes/beantech/layout/about.ejs","hash":"96c08fc3580b842ad9d8f37f2cdf02e6fa57d7bc","modified":1541580566742},{"_id":"themes/beantech/layout/index.ejs","hash":"f293cefe4bf9f9c6848dff08b6dac4aeb7948892","modified":1541580566743},{"_id":"themes/beantech/layout/archive.ejs","hash":"62781e8b0ce4de9c3db6042fedeaf13c26d138f8","modified":1541580566742},{"_id":"themes/beantech/layout/layout.ejs","hash":"389fc11a45676f94b77ebd2cb0d658a0358979c8","modified":1541580566745},{"_id":"themes/beantech/layout/keynote.ejs","hash":"e177b9e4a159f40b512f4ae1bfd928be4ab60840","modified":1541580566744},{"_id":"themes/beantech/layout/post.ejs","hash":"8aef246a0a5c7bc24b47db836ec07b37bc6f5ad6","modified":1541692199751},{"_id":"themes/beantech/layout/page.ejs","hash":"b6d161e11168c73122cbf2a41b7307bef4ab5dbd","modified":1541692415317},{"_id":"themes/beantech/layout/tags.ejs","hash":"63911a99e6daf9968bfdd7d69f0d3d697039902e","modified":1541580566749},{"_id":"source/_posts/RabbitMQ学习-1-概念与认识/v-host授权2.png","hash":"faac5113e412f275712979750ed753d42696373c","modified":1542780223246},{"_id":"source/_posts/RabbitMQ学习-1-概念与认识/v-host授权后.png","hash":"de55545d7621d45a61471f09f163e1ca4cc1415f","modified":1542780247065},{"_id":"source/_posts/RabbitMQ学习-1-概念与认识/异步处理.png","hash":"666bb259fc180c35ce51e090d6dfabfbda5a08ef","modified":1542767722125},{"_id":"source/_posts/RabbitMQ学习-1-概念与认识/日志收集与处理.png","hash":"19aebd9fd04bb76cbd64edfd2a7b63c8426315cd","modified":1542766790132},{"_id":"source/_posts/RabbitMQ学习-1-概念与认识/系统解耦.png","hash":"2c9ac9d22338ab6926704730cb28ed775b24b128","modified":1542767885748},{"_id":"source/_posts/RabbitMQ学习-1-概念与认识/秒杀抢购.png","hash":"1065b2ba7a9593c5879a2039b16fe157158d3455","modified":1542768240639},{"_id":"source/_posts/RabbitMQ学习-2-队列模型/简单队列.png","hash":"be0611cd80bb4ca21b65f9c28edb329a18475ab0","modified":1542782248986},{"_id":"source/_posts/RabbitMQ学习-2-队列模型/工作队列.png","hash":"059875c4bc4e3e79bb873acfc4f7f222ad885898","modified":1543104666114},{"_id":"source/_posts/基于Golang的gRPC使用笔记1/gRPC特点.png","hash":"1ff8aa50c81a7560bc3571af57848ec98d8e10f3","modified":1542004381200},{"_id":"source/_posts/基于Golang的gRPC使用笔记1/gRPC调用示例.png","hash":"0bd9f2344416c46b2d99612d47db8aafd734c7fa","modified":1542004252689},{"_id":"source/_posts/基于Golang的gRPC使用笔记1/rpc原理图.png","hash":"04ccbcfe8ff0734f2175bcaf7bbd3a3889f14a49","modified":1542003658824},{"_id":"source/img/404-bg.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1541580566645},{"_id":"source/img/signature/nebula-black.png","hash":"faf235e18821463843caefc127c750a227b3ed69","modified":1541728036564},{"_id":"source/img/signature/nebula-white.png","hash":"a3c2e03ae0a23beb01a15f37424835c001d93cfd","modified":1541728030087},{"_id":"themes/beantech/layout/_widget/category.ejs","hash":"c32e6fb8f3a07c5cbaffcebf93c357237c18b009","modified":1541580566739},{"_id":"themes/beantech/layout/_widget/archive.ejs","hash":"ad9fb0073d40fe90bfe3a1e3246e0b07e12b3ecf","modified":1541580566738},{"_id":"themes/beantech/layout/_widget/featured-tags.ejs","hash":"51543d9f7d41abdb4deff7ff949cd5ecad074853","modified":1541692709095},{"_id":"themes/beantech/layout/_widget/friends-blog.ejs","hash":"db2471d05df2ad0b3ec882595550e68163ffbc45","modified":1541692507534},{"_id":"themes/beantech/layout/_widget/recent-posts.ejs","hash":"305bd9feaf2484052ba2925a13ebb8723a885396","modified":1541671090453},{"_id":"themes/beantech/layout/_partial/footer.ejs","hash":"447d159e505f5dbd56b79f5994e038d46ddde509","modified":1541679641600},{"_id":"themes/beantech/layout/_widget/short-about.ejs","hash":"f3f4fd95fbb98090d6abd94b855d0a39c8bed9f5","modified":1541692753069},{"_id":"themes/beantech/layout/_partial/header.ejs","hash":"9aea336d3907735eedabcfb21c286cd54a01f45f","modified":1541580566734},{"_id":"themes/beantech/layout/_partial/head.ejs","hash":"258af22c0c8d5dce3f218f4cc8b2220f38a841b9","modified":1541580566734},{"_id":"themes/beantech/layout/_partial/pagination.ejs","hash":"cd61e4dbbf6020ad094c8e66ec06e8c38ebcd122","modified":1541580566736},{"_id":"themes/beantech/layout/_partial/nav.ejs","hash":"e65bfec3d14a9eb9f1e09b592bb34023e6bf6e83","modified":1541580566735},{"_id":"themes/beantech/layout/_partial/sidebar.ejs","hash":"bc7834dd769eeac94a76ffd9cfbb13a622861b62","modified":1541580566736},{"_id":"themes/beantech/layout/_partial/toc.ejs","hash":"a765433a33b3613f4664de2da48d0c58f68f8cd6","modified":1541580566737},{"_id":"themes/beantech/source/css/beantech.css","hash":"5e9bee0a553da83a3efd4e9bc975a0ebd13b1b7d","modified":1541580566752},{"_id":"themes/beantech/source/css/beantech.min.css","hash":"05a06230b1a9eca0b30cece54a397008cb77dc50","modified":1541580566753},{"_id":"themes/beantech/source/css/archive.styl","hash":"bcb216ef65804c97b1a5dbe5f519fc171a13aaf1","modified":1541580566751},{"_id":"themes/beantech/source/css/highlight.styl","hash":"831f8195f3577ba5bea374f2e24b90054d445055","modified":1541580566759},{"_id":"themes/beantech/source/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1541580566760},{"_id":"themes/beantech/source/css/signature.styl","hash":"63ae8051f59d5e69544647cc4173eabc81d99aae","modified":1541580566764},{"_id":"themes/beantech/source/css/rocket.styl","hash":"0abbccdbcd6cce70e8a0bab7152c38adc0b708f1","modified":1541580566764},{"_id":"themes/beantech/source/css/toc.styl","hash":"822aca17c885109452cc75a9aa384d9f3c07ea81","modified":1541580566765},{"_id":"themes/beantech/source/css/widget.styl","hash":"f996466e299c68274145ba5afaca9b6d1dd83114","modified":1541580566766},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1541580566768},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1541580566771},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1541580566773},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1541580566775},{"_id":"themes/beantech/source/js/bootstrap.min.js","hash":"313da686ebbe387064f2d1899c64ea562b81eb40","modified":1541580566779},{"_id":"themes/beantech/source/js/hux-blog.js","hash":"3d3c93e42a9990b2a2e6df5a08e9816f9a221e0f","modified":1541580566780},{"_id":"themes/beantech/source/js/hux-blog.min.js","hash":"ee99af17a1a69ac8d85a695fed0349ba202789ae","modified":1541580566781},{"_id":"themes/beantech/source/js/jquery.nav.js","hash":"bc6383fa2aa8f437978cf044a3b6f10a65114398","modified":1541580566788},{"_id":"themes/beantech/source/js/jquery.tagcloud.js","hash":"448017ff32f75f444ed7985d10a21b3ad92ab100","modified":1541580566788},{"_id":"themes/beantech/source/js/totop.js","hash":"f796b09b4f6177c3674a8c1542a8c92e8590cb5c","modified":1541580566790},{"_id":"themes/beantech/source/js/toc.js","hash":"4ffe95b7755b035ee1b41664fa72b0ebea29c3f8","modified":1541580566789},{"_id":"source/_posts/RabbitMQ学习-1-概念与认识/v-host授权.png","hash":"64bc4522873a247c08fd4f8251ff2b39601675bf","modified":1542780193599},{"_id":"source/_posts/RabbitMQ学习-1-概念与认识/v-host添加.png","hash":"6773b8d9e5de8d9de3cd509108ffd1e1ed888ee9","modified":1542780083770},{"_id":"source/_posts/微服务API网关框架-1/单节点场景网关.png","hash":"aace22510bf66be74488cbd53c0fc55ba66a0dbc","modified":1544165223471},{"_id":"source/_posts/微服务API网关框架-1/反向代理.png","hash":"505070cb7d764184993ddb9f5f22237feee0d366","modified":1544176907851},{"_id":"source/img/header_img/Iron-Man-3.jpg","hash":"62a9a76854503c327990cc8d10de293ab6e9588f","modified":1541580566658},{"_id":"themes/beantech/source/css/bootstrap.min.css","hash":"1818a346630e7133a1f194669f613f613fcfa97c","modified":1541580566758},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.svg","hash":"4dcf0ab896f5417047f881de91bad10dcbda48c6","modified":1541580566770},{"_id":"themes/beantech/source/js/bootstrap.js","hash":"5d69034fb6eded2e5961ea54dd47129a88cd5182","modified":1541580566778},{"_id":"themes/beantech/source/js/jquery.min.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1541580566787},{"_id":"source/_posts/RabbitMQ学习-1-概念与认识/vhost.png","hash":"b2cd3450e3df72495678acf9af9b994a5a461045","modified":1542779994853},{"_id":"source/_posts/hexo-theme-beantech/home_posts_tag-false.png","hash":"86a3a4320012981f2d42eabc6ea172425f2f941a","modified":1541580566636},{"_id":"source/_posts/微服务API网关框架-1/多节点场景网关.png","hash":"3796d6200be78e6b133ec0b6161be559f5f12136","modified":1544165266969},{"_id":"source/_posts/微服务API网关框架-1/架构.png","hash":"5ede75fb54a0656e433a75874fbd863f496db8eb","modified":1544166518917},{"_id":"source/_posts/微服务API网关框架-1/架构2.png","hash":"af2ebcc3de50bfbbc99dd9ec1e580a795b7a3e17","modified":1544166572643},{"_id":"source/_posts/微服务API网关框架-1/架构3.png","hash":"793e70019e84c2773cf0e2cb9f4ad3db749d9f69","modified":1544166622304},{"_id":"source/_posts/微服务API网关框架-1/正向代理.png","hash":"cf2fd43df3865613c8fbb6b64641a6c2df3ab069","modified":1544176776480},{"_id":"source/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1541580566656},{"_id":"themes/beantech/source/css/bootstrap.css","hash":"d1a24afac31222d70b4e001e0361ef045aa42043","modified":1541580566756},{"_id":"themes/beantech/source/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1541580566763},{"_id":"themes/beantech/source/css/images/ironman.png","hash":"2f0db0ab15d466c4065d9f6102fdf829726d9e3f","modified":1541580566762},{"_id":"source/_posts/RabbitMQ学习-1-概念与认识/用户管理-添加用户.png","hash":"48bf176c95fcbf511b37eec2bc66382054a0a844","modified":1542779870912},{"_id":"source/_posts/hexo-theme-beantech/home_posts_tag-true.png","hash":"a704520b43f26b88d650098f60689af3af5eb106","modified":1541580566638},{"_id":"source/img/header_img/tf-logo-dark.png","hash":"5c7bf8ade9de134f8c77a3c59e575abe9fc6cdd4","modified":1541580566710},{"_id":"themes/beantech/source/js/jquery.js","hash":"4bb763dc96da604aed08ac024a1a3f5de73eea39","modified":1541580566785},{"_id":"source/_posts/微服务API网关框架-1/新旧进程同在.png","hash":"d470602ee33a4515534404d0bbe2db93f8b6922a","modified":1544276814244},{"_id":"source/img/beantech-desktop.png","hash":"4a8f8b209c9db8fd5209f15b8e4590525e258b0f","modified":1541580566654},{"_id":"source/img/header_img/tag-bg.png","hash":"e83cd7b04ff85bcbc9bd3ebf5e57a55166e82568","modified":1541580566707},{"_id":"source/_posts/Lua脚本教程-1/Demo.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1541580566633},{"_id":"source/_posts/Lua脚本教程-2/Demo.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1541580566633},{"_id":"source/_posts/Lua脚本教程-3/Demo.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1541580566633},{"_id":"source/_posts/RabbitMQ学习-1-概念与认识/Demo.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1541580566633},{"_id":"source/_posts/RabbitMQ学习-2-队列模型/Demo.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1541580566633},{"_id":"source/_posts/hexo-theme-beantech/Demo.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1541580566633},{"_id":"source/_posts/微服务API网关框架-1/Demo.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1541580566633},{"_id":"source/_posts/基于Golang的gRPC使用笔记1/Demo.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1541580566633},{"_id":"source/_posts/微服务API网关框架-2/Demo.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1541580566633},{"_id":"source/img/header_img/home-bg-o.png","hash":"134ece4cb4c49c7ca1403a5afe7f46d0e2f9ecbb","modified":1541580566693},{"_id":"source/img/header_img/home-bg-2-dark.png","hash":"da6a3d5ca787bdc25e69655abd879b4f821aeb30","modified":1541580566682},{"_id":"source/img/header_img/archive-bg.png","hash":"6bf9c224543ec54e250309db89cbdf46e0c4b5ba","modified":1541580566669}],"Category":[],"Data":[],"Page":[{"layout":"404","description":"你来到了没有知识的荒原 :(","header-img":"img/404-bg.jpg","_content":"","source":"404.md","raw":"---\nlayout: 404\ndescription: \"你来到了没有知识的荒原 :(\"\nheader-img: \"img/404-bg.jpg\"\n---\n","date":"2018-11-07T08:49:26.620Z","updated":"2018-11-07T08:49:26.620Z","path":"404.html","title":"","comments":1,"_id":"cjpuya65d00009kujwcahgwp4","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"archive","title":"归档","header-img":"img/header_img/archive-bg.png","comments":0,"date":"2017-03-20T12:49:56.000Z","description":"时光匆匆流逝，记录的却是简单的过去","_content":"","source":"archive/index.md","raw":"---\nlayout: \"archive\"\ntitle: \"归档\"\nheader-img: \"img/header_img/archive-bg.png\"\ncomments: false\ndate: 2017-03-20 20:49:56\ndescription: \"时光匆匆流逝，记录的却是简单的过去\"\n---\n","updated":"2018-11-09T01:13:59.442Z","path":"archive/index.html","_id":"cjpuya67w00059kujk5o9t5jt","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"about","title":"关于我","date":"2018-11-08T16:00:00.000Z","description":"勿在浮沙筑高台，不为浮华易匠心","header-img":"img/header_img/Iron-Man-3.jpg","comments":1,"_content":"\n> 光有好奇心而不去實踐，等於自願放棄成功機會\n> 別為自己畫地自限，Just Do It！！\n","source":"about/index.md","raw":"---\nlayout: \"about\"\ntitle: \"关于我\"\ndate: 2018-11-09 00:00:00\ndescription: \"勿在浮沙筑高台，不为浮华易匠心\"\nheader-img: \"img/header_img/Iron-Man-3.jpg\"\ncomments: true\n---\n\n> 光有好奇心而不去實踐，等於自願放棄成功機會\n> 別為自己畫地自限，Just Do It！！\n","updated":"2018-11-09T01:17:01.596Z","path":"about/index.html","_id":"cjpuya68000079kujhjbj4oku","content":"<blockquote>\n<p>光有好奇心而不去實踐，等於自願放棄成功機會<br>\n別為自己畫地自限，Just Do It！！</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>光有好奇心而不去實踐，等於自願放棄成功機會<br>\n別為自己畫地自限，Just Do It！！</p>\n</blockquote>\n"},{"layout":"tags","title":"书签","description":"嗯，分类是个好习惯","header-img":"img/header_img/tag-bg.png","_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: \"书签\"\ndescription: \"嗯，分类是个好习惯\"\nheader-img: \"img/header_img/tag-bg.png\"\n---\n","date":"2018-11-09T01:23:09.047Z","updated":"2018-11-09T01:23:08.994Z","path":"tags/index.html","comments":1,"_id":"cjpuya68300099kujok49cjmq","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Lua脚本教程(1)--概念与基本语法","catalog":true,"date":"2018-12-17T01:22:13.000Z","subtitle":null,"header-img":"Demo.png","_content":"\n# Lua教程\n\n## 简介\n\n### 设计目的\n    其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。\n\n### Lua特性\n    轻量级: 它用标准C语言编写并以源代码形式开放，编译后仅仅一百余K，可以很方便的嵌入别的程序里。\n    可扩展: Lua提供了非常易于使用的扩展接口和机制：由宿主语言(通常是C或C++)提供这些功能，Lua可以使用它们，就像是本来就内置的功能一样。\n    其它特性:\n    支持面向过程(procedure-oriented)编程和函数式编程(functional programming)；\n    自动内存管理；只提供了一种通用类型的表（table），用它可以实现数组，哈希表，集合，对象；\n    语言内置模式匹配；闭包(closure)；函数也可以看做一个值；提供多线程（协同进程，并非操作系统所支持的线程）支持；\n    通过闭包和table可以很方便地支持面向对象编程所需要的一些关键机制，比如数据抽象，虚函数，继承和重载等。\n\n## Lua安装\n    http://www.runoob.com/lua/lua-environment.html\n\n## Lua基本语法\n   \n### 编程模式\n    1. 交互式编程 (shell)\n        与python的shell使用方法一致，直接在终端下运行lua命令即可\n    2. 脚本式编程\n        创建xxxx.lua文件，然后使用lua xxxx.lua命令或者是luajit xxxx.lua文件即可进行运行\n           \n### 注释\n    1.单行注释\n        --\n    2.多行注释\n        --[[\n        多行注释\n        多行注释\n        --]]   \n        \n### 标示符\n    Lua 是一个区分大小写的编程语言\n    Lua 标示符用于定义一个变量，函数获取其他用户定义的项。标示符以一个字母 A 到 Z 或 a 到 z 或下划线 _ 开头后加上0个或多个字母，下划线，数字(0到9)\n    Lua 不允许使用特殊字符如 @, $, 和 % 来定义标示符\n    最好不要使用下划线加大写字母的标示符，因为Lua的保留字也是这样的\n    一般约定，以下划线开头连接一串大写字母的名字（比如 _VERSION）被保留用于 Lua 内部全局变量\n\n### 关键词\n    and    break    do    else\n    elseif    end    false    for\n    function    if    in    local\n    nil    not    or    repeat\n    return    then    true    until\n    while\n\n### 变量\n    Lua 变量有三种类型：全局变量、局部变量、表中的域\n    变量在使用前，必须在代码中进行声明，即创建该变量\n    变量的默认值均为 nil。\n\n    1.全局变量\n        (1)在默认情况下，变量总是认为是全局的。\n        (2)全局变量不需要声明，给一个变量赋值后即创建了这个全局变量，访问一个没有初始化的全局变量也不会出错，只不过得到的结果是：nil。\n        (3)如果你想删除一个全局变量，只需要将变量赋值为nil。\n        (4)Lua 中的变量全是全局变量，那怕是语句块或是函数里，除非用 local 显式声明为局部变量。\n    2.局部变量\n        局部变量的作用域为从声明位置开始到所在语句块结束。\n    3.表中的域\n    \n#### 赋值\n    1. 使用\"=\"号进行赋值\n    2. Lua可以对多个变量同时赋值，变量列表和值列表的各个元素用逗号分开，赋值语句右边的值会依次赋给左边的变量\n        a,b=21,22\n    3. 赋值语句Lua会先计算右边所有的值然后再执行赋值操作，所以我们可以这样进行交换变量的值\n        x, y = y, x                     -- swap 'x' for 'y'\n        a[i], a[j] = a[j], a[i]         -- swap 'a[i]' for 'a[j]'  \n    4. 重点: 当变量个数和值的个数不一致时，Lua会一直以变量个数为基础采取以下策略\n        a. 变量个数 > 值的个数             按变量个数补足nil\n        b. 变量个数 < 值的个数             多余的值会被忽略\n        \n        a, b, c = 0, 1\n        print(a,b,c)             --> 0   1   nil  \n        \n        a, b = a+1, b+1, b+2     -- value of b+2 is ignored\n        print(a,b)               --> 1   2\n        \n        a, b, c = 0\n        print(a,b,c)             --> 0   nil   nil\n    5. 多值赋值经常用来交换变量，或将函数调用返回给变量\n           a, b = f()\n           f()返回两个值，第一个赋给a，第二个赋给b。\n           应该尽可能的使用局部变量，有两个好处：\n               1. 避免命名冲突。\n               2. 访问局部变量的速度比全局变量更快。\n### 数据类型\n    Lua是动态类型语言，变量不要类型定义,只需要为变量赋值。 值可以存储在变量中，作为参数传递或结果返回。\n    Lua中有8个基本类型分别为：nil、boolean、number、string、userdata、function、thread和table。\n\n    数据类型\t描述\n    nil\t            这个最简单，只有值nil属于该类，表示一个无效值（在条件表达式中相当于false）。\n    boolean\t        包含两个值：false和true。Lua认为false和nil为\"假\",其他任何值都是\"真\",包括0\n    number\t        表示双精度类型的实浮点数\n    string\t        字符串由一对双引号或单引号来表示\n    function\t    由 C 或 Lua 编写的函数\n    userdata\t    表示任意存储在变量中的C数据结构\n    thread\t        表示执行的独立线路，用于执行协同程序\n    table\t        Lua 中的表（table）其实是一个\"关联数组\"（associative arrays），数组的索引可以是数字或者是字符串。在 Lua 里，table 的创建是通过\"构造表达式\"来完成，最简单构造表达式是{}，用来创建一个空表。\n\n#### 获取数据的类型\n    重点: type(xxx) -- 返回的都是字符串形式的数据类型\n          type(type(xxx)) == \"string\"\n    \n    print(type(\"Hello world\"))      --> string      \n    print(type(10.4*3))             --> number\n    print(type(print))              --> function\n    print(type(type))               --> function\n    print(type(true))               --> boolean\n    print(type(nil))                --> nil\n    print(type(type(X)))            --> string\n\n#### 获取当前变量的数据类型是否与设想的一致\n    v = \"Hello World.\"\n    if type(v) == \"string\"\n    then\n        print(\"字符串类型\")\n    end\n\n#### nil (空值)\n    nil 类型表示一种没有任何有效值，它只有一个值 -- nil\n    作用:对于全局变量和 table，nil 还有一个\"删除\"作用，给全局变量或者 table 表里的变量赋一个 nil 值，等同于把它们删掉\n       \n        例子:\n            tab1 = { key1 = \"val1\", key2 = \"val2\", \"val3\" }\n            for k, v in pairs(tab1) do\n                print(k .. \" - \" .. v)\n            end\n             \n            tab1.key1 = nil\n            for k, v in pairs(tab1) do\n                print(k .. \" - \" .. v)\n            end\n\n#### boolean(布尔值)\n    boolean 类型只有两个可选值：true（真） 和 false（假），Lua 把 false 和 nil 看作是\"假\"，其他的都为\"真\",包括\"0\"也是真\n    \n#### number(数字)\n    Lua 默认只有一种 number 类型 -- double（双精度）类型（默认类型可以修改 luaconf.h 里的定义）\n    \n#### string(字符串)\n    1. 字符串由一对双引号或单引号来表示。\n        string1 = \"this is string1\"\n        string2 = 'this is string2'\n    2. 两个方括号 \"[[]]\" 来表示\"一块\"字符串,用于多行文本 \n        html = [[\n        <html>\n        <head></head>\n        <body>\n            <a href=\"http://www.runoob.com/\">菜鸟教程</a>\n        </body>\n        </html>\n        ]]\n    3. 在对一个数字字符串上进行算术操作时，Lua 会尝试将这个数字字符串转成一个数字\n        > print(\"2\" + 6)\n        8.0\n        > print(\"2\" + \"6\")\n        8.0\n        > print(\"2 + 6\")\n        2 + 6\n        > print(\"-2e2\" * \"6\")\n        -1200.0\n    4. 字符串连接符\"..\"\n         > print(\"a\" .. 'b')\n         ab\n         > print(157 .. 428)\n         157428\n         > \n    5. 计算字符串长度\n         > len = \"www.runoob.com\"\n         > print(#len)\n         14\n         > print(#\"www.runoob.com\")\n         14\n\n##### 字符串用法拓展\n    1. 常规的转义符号\n        \\a  响铃(BEL)\n        \\b  退格(BS) ，将当前位置移到前一列\n        \\f  换页(FF)，将当前位置移到下页开头\n        \\n  换行(LF) ，将当前位置移到下一行开头\n        \\r  回车(CR) ，将当前位置移到本行开头\n        \\t  水平制表(HT) （跳到下一个TAB位置）\n        \\v  垂直制表(VT)\n        \\\\  代表一个反斜线字符''\\'\n        \\'  代表一个单引号（撇号）字符\n        \\\"  代表一个双引号字符\n        \\0  空字符(NULL)\n        \\ddd    1到3位八进制数所代表的任意字符\n        \\xhh    1到2位十六进制所代表的任意字符\n    \n    2. 字符串操作\n        (1)string.upper(argument):字符串全部转为大写字母  \n        (2)string.lower(argument):字符串全部转为小写字母\n        (3)string.gsub(mainString,findString,replaceString,num):在字符串中替换,mainString为要替换的字符串， findString 为被替换的字符，replaceString 要替换的字符，num 替换次数（可以忽略，则全部替换）\n            > string.gsub(\"aaaa\",\"a\",\"z\",3);\n            zzza    3\n        (4)string.find (str, substr, [init, [end]]):在一个指定的目标字符串中搜索指定的内容(第三个参数为索引),返回其具体位置。不存在则返回 nil\n            > string.find(\"Hello Lua user\", \"Lua\", 1) \n            7    9\n        (5)string.reverse(arg):字符串反转    \n        (6)string.format(...):返回一个类似printf的格式化字符串\n            > string.format(\"the value is:%d\",4)\n            the value is:4\n        (7)string.char(arg) 和 string.byte(arg[,int]): char 将整型数字转成字符并连接， byte 转换字符为整数值(可以指定某个字符，默认第一个字符)。\n            > string.char(97,98,99,100)\n            abcd\n            > string.byte(\"ABCD\",4)\n            68\n            > string.byte(\"ABCD\")\n            65\n        (8)string.len(arg):计算字符串长度。\n        (9)string.rep(string, n):返回字符串string的n个拷贝\n        (10)\"..\" 符号: 链接两个字符串\n        (11)string.gmatch(str, pattern):回一个迭代器函数，每一次调用这个函数，返回一个在字符串 str 找到的下一个符合 pattern 描述的子串。如果参数 pattern 描述的字符串没有找到，迭代函数返回nil。\n            > for word in string.gmatch(\"Hello Lua user\", \"%a+\") do print(word) end\n            Hello\n            Lua\n            user\n        (12)string.match(str, pattern, init):string.match()只寻找源字串str中的第一个配对. 参数init可选, 指定搜寻过程的起点, 默认为1。 \n                                            在成功配对时, 函数将返回配对表达式中的所有捕获结果; 如果没有设置捕获标记, 则返回整个配对字符串. 当没有成功的配对时, 返回nil。\n             > = string.match(\"I have 2 questions for you.\", \"%d+ %a+\")\n             2 questions\n             > = string.format(\"%d, %q\", string.match(\"I have 2 questions for you.\", \"(%d+) (%a+)\"))\n             2, \"questions\"  \n    3.字符串格式化         \n         Lua 提供了 string.format() 函数来生成具有特定格式的字符串, 函数的第一个参数是格式 , 之后是对应格式中每个代号的各种数据。\n            %c - 接受一个数字, 并将其转化为ASCII码表中对应的字符\n            %d, %i - 接受一个数字并将其转化为有符号的整数格式\n            %o - 接受一个数字并将其转化为八进制数格式\n            %u - 接受一个数字并将其转化为无符号整数格式\n            %x - 接受一个数字并将其转化为十六进制数格式, 使用小写字母\n            %X - 接受一个数字并将其转化为十六进制数格式, 使用大写字母\n            %e - 接受一个数字并将其转化为科学记数法格式, 使用小写字母e\n            %E - 接受一个数字并将其转化为科学记数法格式, 使用大写字母E\n            %f - 接受一个数字并将其转化为浮点数格式\n            %g(%G) - 接受一个数字并将其转化为%e(%E, 对应%G)及%f中较短的一种格式\n            %q - 接受一个字符串并将其转化为可安全被Lua编译器读入的格式\n            %s - 接受一个字符串并按照给定的参数格式化该字符串\n         为进一步细化格式, 可以在%号后添加参数. 参数将以如下的顺序读入:\n            (1) 符号: 一个+号表示其后的数字转义符将让正数显示正号. 默认情况下只有负数显示符号.\n            (2) 占位符: 一个0, 在后面指定了字串宽度时占位用. 不填时的默认占位符是空格.\n            (3) 对齐标识: 在指定了字串宽度时, 默认为右对齐, 增加-号可以改为左对齐.\n            (4) 宽度数值\n            (5) 小数位数/字串裁切: 在宽度数值后增加的小数部分n, 若后接f(浮点数转义符, 如%6.3f)则设定该浮点数的小数只保留n位, 若后接s(字符串转义符, 如%5.3s)则设定该字符串只显示前n位\n         例子:\n            string1 = \"Lua\"\n            string2 = \"Tutorial\"\n            number1 = 10\n            number2 = 20\n            -- 基本字符串格式化\n            print(string.format(\"基本格式化 %s %s\",string1,string2))\n            -- 日期格式化\n            date = 2; month = 1; year = 2014\n            print(string.format(\"日期格式化 %02d/%02d/%03d\", date, month, year))\n            -- 十进制格式化\n            print(string.format(\"%.4f\",1/3))\n    4. 字符与整数相互转换  \n         -- 字符转换\n         -- 转换第一个字符\n         print(string.byte(\"Lua\"))\n         -- 转换第三个字符\n         print(string.byte(\"Lua\",3))\n         -- 转换末尾第一个字符\n         print(string.byte(\"Lua\",-1))\n         -- 第二个字符\n         print(string.byte(\"Lua\",2))\n         -- 转换末尾第二个字符\n         print(string.byte(\"Lua\",-2))\n         -- 整数 ASCII 码转换为字符\n         print(string.char(97))   \n\n##### 字符串--正则表达式\n     Lua 中的匹配模式直接用常规的字符串来描述。 它用于模式匹配函数 string.find, string.gmatch, string.gsub, string.match。\n     你还可以在模式串中使用字符类。\n     字符类指可以匹配一个特定字符集合内任何字符的模式项。比如，字符类%d匹配任意数字。所以你可以使用模式串 '%d%d/%d%d/%d%d%d%d' 搜索 dd/mm/yyyy 格式的日期：\n     下面的表列出了Lua支持的所有字符类：\n     单个字符(除 ^$()%.[]*+-? 外): 与该字符自身配对\n     .(点): 与任何字符配对\n     %a: 与任何字母配对\n     %c: 与任何控制符配对(例如\\n)\n     %d: 与任何数字配对\n     %l: 与任何小写字母配对\n     %p: 与任何标点(punctuation)配对\n     %s: 与空白字符配对\n     %u: 与任何大写字母配对\n     %w: 与任何字母/数字配对\n     %x: 与任何十六进制数配对\n     %z: 与任何代表0的字符配对\n     %x(此处x是非字母非数字字符): 与字符x配对. 主要用来处理表达式中有功能的字符(^$()%.[]*+-?)的配对问题, 例如%%与%配对\n     [数个字符类]: 与任何[]中包含的字符类配对. 例如[%w_]与任何字母/数字, 或下划线符号(_)配对\n     [^数个字符类]: 与任何不包含在[]中的字符类配对. 例如[^%s]与任何非空白字符配对        \n     \n     当上述的字符类用大写书写时, 表示与非此字符类的任何字符配对. 例如, %S表示与任何非空白字符配对.例如，'%A'非字母的字符:\n     > print(string.gsub(\"hello, up-down!\", \"%A\", \".\"))\n     hello..up.down.    4\n     数字4不是字符串结果的一部分，他是gsub返回的第二个结果，代表发生替换的次数。\n     在模式匹配中有一些特殊字符，他们有特殊的意义，Lua中的特殊字符如下：\n     ( ) . % + - * ? [ ^ $\n     '%' 用作特殊字符的转义字符，因此 '%.' 匹配点；'%%' 匹配字符 '%'。转义字符 '%'不仅可以用来转义特殊字符，还可以用于所有的非字母的字符。\n      \n      模式条目可以是：\n          单个字符类匹配该类别中任意单个字符；\n          单个字符类跟一个 '*'， 将匹配零或多个该类的字符。 这个条目总是匹配尽可能长的串；\n          单个字符类跟一个 '+'， 将匹配一或更多个该类的字符。 这个条目总是匹配尽可能长的串；\n          单个字符类跟一个 '-'， 将匹配零或更多个该类的字符。 和 '*' 不同， 这个条目总是匹配尽可能短的串；\n          单个字符类跟一个 '?'， 将匹配零或一个该类的字符。 只要有可能，它会匹配一个；\n          %n， 这里的 n 可以从 1 到 9； 这个条目匹配一个等于 n 号捕获物（后面有描述）的子串。\n          %bxy， 这里的 x 和 y 是两个明确的字符； 这个条目匹配以 x 开始 y 结束， 且其中 x 和 y 保持 平衡 的字符串。 意思是，如果从左到右读这个字符串，对每次读到一个 x 就 +1 ，读到一个 y 就 -1， 最终结束处的那个 y 是第一个记数到 0 的 y。 举个例子，条目 %b() 可以匹配到括号平衡的表达式。\n          %f[set]， 指 边境模式； 这个条目会匹配到一个位于 set 内某个字符之前的一个空串， 且这个位置的前一个字符不属于 set 。 集合 set 的含义如前面所述。 匹配出的那个空串之开始和结束点的计算就看成该处有个字符 '\\0' 一样。\n      模式：\n        模式 指一个模式条目的序列。 在模式最前面加上符号 '^' 将锚定从字符串的开始处做匹配。 在模式最后面加上符号 '$' 将使匹配过程锚定到字符串的结尾。 如果 '^' 和 '$' 出现在其它位置，它们均没有特殊含义，只表示自身。\n      捕获：\n        模式可以在内部用小括号括起一个子模式； 这些子模式被称为 捕获物。 当匹配成功时，由 捕获物 匹配到的字符串中的子串被保存起来用于未来的用途。 捕获物以它们左括号的次序来编号。 例如，对于模式 \"(a*(.)%w(%s*))\" ， 字符串中匹配到 \"a*(.)%w(%s*)\" 的部分保存在第一个捕获物中 （因此是编号 1 ）； 由 \".\" 匹配到的字符是 2 号捕获物， 匹配到 \"%s*\" 的那部分是 3 号。\n      作为一个特例，空的捕获 () 将捕获到当前字符串的位置（它是一个数字）。 例如，如果将模式 \"()aa()\" 作用到字符串 \"flaaap\" 上，将产生两个捕获物： 3 和 5 。\n            \n#### table(表)   \n    在 Lua 里，table 的创获取数据的类型建是通过\"构造表达式\"来完成，最简单构造表达式是{}，用来创建一个空表\n    也可以在表里添加一些数据，直接初始化表:\n    1. 初始化表与移除引用\n        -- 创建一个空的 table\n        local tbl1 = {}         \n        -- 直接初始表\n        local tbl2 = {\"apple\", \"pear\", \"orange\", \"grape\"}\n        -- 初始化表\n        mytable = {} \n        -- 指定值\n        mytable[1]= \"Lua\"\n        -- 移除引用\n        mytable = nil\n        -- lua 垃圾回收会释放内存\n    \n    2. -- 创建一个空的 table\n       local tbl1 = {}\n       -- 直接初始表\n       local tbl2 = {\"apple\", \"pear\", \"orange\", \"grape\"}\n    \n    3. Lua 中的表（table）其实是一个\"关联数组\"（associative arrays），数组的索引可以是数字或者是字符串\n      table 不会固定长度大小，有新数据添加时 table 长度会自动增长，没初始的 table 都是 nil。\n      重点: 不同于其他语言的数组把 0 作为数组的初始索引，在 Lua 里表的默认初始索引一般以 1 开始  \n            local tbl = {\"apple\", \"pear\", \"orange\", \"grape\"}\n            for key, val in pairs(tbl) do\n               print(\"Key\", key)\n            end\n    4. 索引,对 table 的索引使用方括号 []。Lua 也提供了\".\"操作\n        > site = {}\n        > site[\"key\"] = \"www.w3cschool.cc\"\n        > print(site[\"key\"])\n        www.w3cschool.cc\n        > print(site.key)\n        www.w3cschool.cc\n\n##### table -- 操作\n    1.table.concat (table [, sep [, start [, end]]]):concat是concatenate(连锁, 连接)的缩写. table.concat()函数列出参数中指定table的数组部分从start位置到end位置的所有元素, 元素间以指定的分隔符(sep)隔开。\n    2.table.insert (table, [pos,] value):在table的数组部分指定位置(pos)插入值为value的一个元素. pos参数可选, 默认为数组部分末尾.\n    3.table.remove (table [, pos]):返回table数组部分位于pos位置的元素. 其后的元素会被前移. pos参数可选, 默认为table长度, 即从最后一个元素删起。\n    4.table.sort (table [, comp]):对给定的table进行升序排序\n\n##### table -- table间连接,table中的插入,移除,排序\n    使用 concat() 方法来连接两个 table\n        fruits = {\"banana\",\"orange\",\"apple\"}\n        -- 返回 table 连接后的字符串\n        print(\"连接后的字符串 \",table.concat(fruits)\n        -- 指定连接字符\n        print(\"连接后的字符串 \",table.concat(fruits,\", \"))\n        -- 指定索引来连接 table\n        print(\"连接后的字符串 \",table.concat(fruits,\", \", 2,3))\n        \n        fruits = {\"banana\",\"orange\",\"apple\"}\n        -- 在末尾插入\n        table.insert(fruits,\"mango\")\n        print(\"索引为 4 的元素为 \",fruits[4])\n        \n        -- 在索引为 2 的键处插入\n        table.insert(fruits,2,\"grapes\")\n        print(\"索引为 2 的元素为 \",fruits[2])\n        \n        print(\"最后一个元素为 \",fruits[5])\n        table.remove(fruits)\n        print(\"移除后最后一个元素为 \",fruits[5])    \n        \n        --排序\n        fruits = {\"banana\",\"orange\",\"apple\",\"grapes\"}\n        print(\"排序前\")\n        for k,v in ipairs(fruits) do\n            print(k,v)\n        end\n        \n        table.sort(fruits)\n        print(\"排序后\")\n        for k,v in ipairs(fruits) do\n            print(k,v)\n        end\n\n##### table -- 数组\n    1. 一维数组\n        array = {\"Lua\", \"Tutorial\"}\n        \n        for i= 0, 2 do\n           print(array[i])\n        end\n    2. 多维数组\n         -- 初始化数组\n         array = {}\n         for i=1,3 do\n            array[i] = {}\n               for j=1,3 do\n                  array[i][j] = i*j\n               end\n         end\n         \n         -- 访问数组\n         for i=1,3 do\n            for j=1,3 do\n               print(array[i][j])\n            end\n         end   \n        \n#### function（函数）\n    1.在 Lua 中，函数是被看作是\"一类公民（First-Class Value）\"\n        function factorial1(n)\n            if n == 0 then\n                return 1\n            else\n                return n * factorial1(n - 1)\n            end\n        end\n        print(factorial1(5))\n        factorial2 = factorial1\n        print(factorial2(5))\n     \n    2.function 可以以匿名函数（anonymous function）的方式通过参数传递\n        -- function_test2.lua 脚本文件\n        function testFun(tab,fun)\n            for k ,v in pairs(tab) do\n                print(fun(k,v));\n            end\n        end\n        \n        \n        tab={key1=\"val1\",key2=\"val2\"};\n        testFun(tab,\n        function(key,val)--匿名函数\n            return key..\"=\"..val;\n        end\n        );  \n    3. 多返回值\n        Lua函数中，在return后列出要返回的值的列表即可返回多值\n            function maximum (a)\n                local mi = 1             -- 最大值索引\n                local m = a[mi]          -- 最大值\n                for i,val in ipairs(a) do\n                   if val > m then\n                       mi = i\n                       m = val\n                   end\n                end\n                return m, mi\n            end\n            \n            print(maximum({8,10,23,12,5}))     \n\n##### 函数定义\n    optional_function_scope function function_name( argument1, argument2, argument3..., argumentn)\n        function_body\n        return result_params_comma_separated\n    end\n    \n    optional_function_scope: 该参数是可选的制定函数是全局函数还是局部函数，未设置该参数默认为全局函数，如果你需要设置函数为局部函数需要使用关键字 local。\n    function_name: 指定函数名称。\n    argument1, argument2, argument3..., argumentn: 函数参数，多个参数以逗号隔开，函数也可以不带参数。\n    function_body: 函数体，函数中需要执行的代码语句块。\n    result_params_comma_separated: 函数返回值，Lua语言函数可以返回多个值，每个值以逗号隔开。\n    \n##### 函数的可变参数\n       1. 在函数参数列表中使用三点 ... 表示函数有可变的参数\n            function add(...)  \n            local s = 0  \n              for i, v in ipairs{...} do   --> {...} 表示一个由所有变长参数构成的数组  \n                s = s + v  \n              end  \n              return s  \n            end  \n            print(add(3,4,5,6,7))  --->25\n       2. select(\"#\",...) 来获取可变参数的数量\n                function average(...)\n                   result = 0\n                   local arg={...}\n                   for i,v in ipairs(arg) do\n                      result = result + v\n                   end\n                   print(\"总共传入 \" .. select(\"#\",...) .. \" 个数\")\n                   return result/select(\"#\",...)\n                end\n                \n                print(\"平均值为\",average(10,5,3,4,5,6))\n            \n            在遍历变长参数的时候只需要使用 {…}，然而变长参数可能会包含一些 nil，那么就可以用 select 函数来访问变长参数了：select('#', …) 或者 select(n, …)\n            select('#', …) 返回可变参数的长度\n            select(n, …) 用于访问 n 到 select('#',…) 的参数\n            调用select时，必须传入一个固定实参selector(选择开关)和一系列变长参数。如果selector为数字n,那么select返回它的第n个可变实参，否则只能为字符串\"#\",这样select会返回变长参数的总数\n                do  \n                    function foo(...)  \n                        for i = 1, select('#', ...) do  -->获取参数总数\n                            local arg = select(i, ...); -->读取参数\n                            print(\"arg\", arg);  \n                        end  \n                    end  \n                  \n                    foo(1, 2, 3, 4);  \n                end\n        \n#### thread(线程)\n    在 Lua 里，最主要的线程是协同程序（coroutine）。\n    协程跟线程（thread）差不多，拥有自己独立的栈、局部变量和指令指针，可以跟其他协同程序共享全局变量和其他大部分东西。\n    线程跟协程的区别：线程可以同时多个运行，而协程任意时刻只能运行一个，并且处于运行状态的协程只有被挂起（suspend）时才会暂停。\n    \n#### userdata(自定义类型)     \n    userdata 是一种用户自定义数据，用于表示一种由应用程序或 C/C++ 语言库所创建的类型，可以将任意 C/C++ 的任意数据类型的数据（通常是 struct 和 指针）存储到 Lua 变量中调用。\n","source":"_posts/Lua脚本教程-1.md","raw":"---\ntitle: Lua脚本教程(1)--概念与基本语法\ncatalog: true\ndate: 2018-12-17 09:22:13\nsubtitle:\nheader-img: \"Demo.png\"\ntags: Lua\n---\n\n# Lua教程\n\n## 简介\n\n### 设计目的\n    其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。\n\n### Lua特性\n    轻量级: 它用标准C语言编写并以源代码形式开放，编译后仅仅一百余K，可以很方便的嵌入别的程序里。\n    可扩展: Lua提供了非常易于使用的扩展接口和机制：由宿主语言(通常是C或C++)提供这些功能，Lua可以使用它们，就像是本来就内置的功能一样。\n    其它特性:\n    支持面向过程(procedure-oriented)编程和函数式编程(functional programming)；\n    自动内存管理；只提供了一种通用类型的表（table），用它可以实现数组，哈希表，集合，对象；\n    语言内置模式匹配；闭包(closure)；函数也可以看做一个值；提供多线程（协同进程，并非操作系统所支持的线程）支持；\n    通过闭包和table可以很方便地支持面向对象编程所需要的一些关键机制，比如数据抽象，虚函数，继承和重载等。\n\n## Lua安装\n    http://www.runoob.com/lua/lua-environment.html\n\n## Lua基本语法\n   \n### 编程模式\n    1. 交互式编程 (shell)\n        与python的shell使用方法一致，直接在终端下运行lua命令即可\n    2. 脚本式编程\n        创建xxxx.lua文件，然后使用lua xxxx.lua命令或者是luajit xxxx.lua文件即可进行运行\n           \n### 注释\n    1.单行注释\n        --\n    2.多行注释\n        --[[\n        多行注释\n        多行注释\n        --]]   \n        \n### 标示符\n    Lua 是一个区分大小写的编程语言\n    Lua 标示符用于定义一个变量，函数获取其他用户定义的项。标示符以一个字母 A 到 Z 或 a 到 z 或下划线 _ 开头后加上0个或多个字母，下划线，数字(0到9)\n    Lua 不允许使用特殊字符如 @, $, 和 % 来定义标示符\n    最好不要使用下划线加大写字母的标示符，因为Lua的保留字也是这样的\n    一般约定，以下划线开头连接一串大写字母的名字（比如 _VERSION）被保留用于 Lua 内部全局变量\n\n### 关键词\n    and    break    do    else\n    elseif    end    false    for\n    function    if    in    local\n    nil    not    or    repeat\n    return    then    true    until\n    while\n\n### 变量\n    Lua 变量有三种类型：全局变量、局部变量、表中的域\n    变量在使用前，必须在代码中进行声明，即创建该变量\n    变量的默认值均为 nil。\n\n    1.全局变量\n        (1)在默认情况下，变量总是认为是全局的。\n        (2)全局变量不需要声明，给一个变量赋值后即创建了这个全局变量，访问一个没有初始化的全局变量也不会出错，只不过得到的结果是：nil。\n        (3)如果你想删除一个全局变量，只需要将变量赋值为nil。\n        (4)Lua 中的变量全是全局变量，那怕是语句块或是函数里，除非用 local 显式声明为局部变量。\n    2.局部变量\n        局部变量的作用域为从声明位置开始到所在语句块结束。\n    3.表中的域\n    \n#### 赋值\n    1. 使用\"=\"号进行赋值\n    2. Lua可以对多个变量同时赋值，变量列表和值列表的各个元素用逗号分开，赋值语句右边的值会依次赋给左边的变量\n        a,b=21,22\n    3. 赋值语句Lua会先计算右边所有的值然后再执行赋值操作，所以我们可以这样进行交换变量的值\n        x, y = y, x                     -- swap 'x' for 'y'\n        a[i], a[j] = a[j], a[i]         -- swap 'a[i]' for 'a[j]'  \n    4. 重点: 当变量个数和值的个数不一致时，Lua会一直以变量个数为基础采取以下策略\n        a. 变量个数 > 值的个数             按变量个数补足nil\n        b. 变量个数 < 值的个数             多余的值会被忽略\n        \n        a, b, c = 0, 1\n        print(a,b,c)             --> 0   1   nil  \n        \n        a, b = a+1, b+1, b+2     -- value of b+2 is ignored\n        print(a,b)               --> 1   2\n        \n        a, b, c = 0\n        print(a,b,c)             --> 0   nil   nil\n    5. 多值赋值经常用来交换变量，或将函数调用返回给变量\n           a, b = f()\n           f()返回两个值，第一个赋给a，第二个赋给b。\n           应该尽可能的使用局部变量，有两个好处：\n               1. 避免命名冲突。\n               2. 访问局部变量的速度比全局变量更快。\n### 数据类型\n    Lua是动态类型语言，变量不要类型定义,只需要为变量赋值。 值可以存储在变量中，作为参数传递或结果返回。\n    Lua中有8个基本类型分别为：nil、boolean、number、string、userdata、function、thread和table。\n\n    数据类型\t描述\n    nil\t            这个最简单，只有值nil属于该类，表示一个无效值（在条件表达式中相当于false）。\n    boolean\t        包含两个值：false和true。Lua认为false和nil为\"假\",其他任何值都是\"真\",包括0\n    number\t        表示双精度类型的实浮点数\n    string\t        字符串由一对双引号或单引号来表示\n    function\t    由 C 或 Lua 编写的函数\n    userdata\t    表示任意存储在变量中的C数据结构\n    thread\t        表示执行的独立线路，用于执行协同程序\n    table\t        Lua 中的表（table）其实是一个\"关联数组\"（associative arrays），数组的索引可以是数字或者是字符串。在 Lua 里，table 的创建是通过\"构造表达式\"来完成，最简单构造表达式是{}，用来创建一个空表。\n\n#### 获取数据的类型\n    重点: type(xxx) -- 返回的都是字符串形式的数据类型\n          type(type(xxx)) == \"string\"\n    \n    print(type(\"Hello world\"))      --> string      \n    print(type(10.4*3))             --> number\n    print(type(print))              --> function\n    print(type(type))               --> function\n    print(type(true))               --> boolean\n    print(type(nil))                --> nil\n    print(type(type(X)))            --> string\n\n#### 获取当前变量的数据类型是否与设想的一致\n    v = \"Hello World.\"\n    if type(v) == \"string\"\n    then\n        print(\"字符串类型\")\n    end\n\n#### nil (空值)\n    nil 类型表示一种没有任何有效值，它只有一个值 -- nil\n    作用:对于全局变量和 table，nil 还有一个\"删除\"作用，给全局变量或者 table 表里的变量赋一个 nil 值，等同于把它们删掉\n       \n        例子:\n            tab1 = { key1 = \"val1\", key2 = \"val2\", \"val3\" }\n            for k, v in pairs(tab1) do\n                print(k .. \" - \" .. v)\n            end\n             \n            tab1.key1 = nil\n            for k, v in pairs(tab1) do\n                print(k .. \" - \" .. v)\n            end\n\n#### boolean(布尔值)\n    boolean 类型只有两个可选值：true（真） 和 false（假），Lua 把 false 和 nil 看作是\"假\"，其他的都为\"真\",包括\"0\"也是真\n    \n#### number(数字)\n    Lua 默认只有一种 number 类型 -- double（双精度）类型（默认类型可以修改 luaconf.h 里的定义）\n    \n#### string(字符串)\n    1. 字符串由一对双引号或单引号来表示。\n        string1 = \"this is string1\"\n        string2 = 'this is string2'\n    2. 两个方括号 \"[[]]\" 来表示\"一块\"字符串,用于多行文本 \n        html = [[\n        <html>\n        <head></head>\n        <body>\n            <a href=\"http://www.runoob.com/\">菜鸟教程</a>\n        </body>\n        </html>\n        ]]\n    3. 在对一个数字字符串上进行算术操作时，Lua 会尝试将这个数字字符串转成一个数字\n        > print(\"2\" + 6)\n        8.0\n        > print(\"2\" + \"6\")\n        8.0\n        > print(\"2 + 6\")\n        2 + 6\n        > print(\"-2e2\" * \"6\")\n        -1200.0\n    4. 字符串连接符\"..\"\n         > print(\"a\" .. 'b')\n         ab\n         > print(157 .. 428)\n         157428\n         > \n    5. 计算字符串长度\n         > len = \"www.runoob.com\"\n         > print(#len)\n         14\n         > print(#\"www.runoob.com\")\n         14\n\n##### 字符串用法拓展\n    1. 常规的转义符号\n        \\a  响铃(BEL)\n        \\b  退格(BS) ，将当前位置移到前一列\n        \\f  换页(FF)，将当前位置移到下页开头\n        \\n  换行(LF) ，将当前位置移到下一行开头\n        \\r  回车(CR) ，将当前位置移到本行开头\n        \\t  水平制表(HT) （跳到下一个TAB位置）\n        \\v  垂直制表(VT)\n        \\\\  代表一个反斜线字符''\\'\n        \\'  代表一个单引号（撇号）字符\n        \\\"  代表一个双引号字符\n        \\0  空字符(NULL)\n        \\ddd    1到3位八进制数所代表的任意字符\n        \\xhh    1到2位十六进制所代表的任意字符\n    \n    2. 字符串操作\n        (1)string.upper(argument):字符串全部转为大写字母  \n        (2)string.lower(argument):字符串全部转为小写字母\n        (3)string.gsub(mainString,findString,replaceString,num):在字符串中替换,mainString为要替换的字符串， findString 为被替换的字符，replaceString 要替换的字符，num 替换次数（可以忽略，则全部替换）\n            > string.gsub(\"aaaa\",\"a\",\"z\",3);\n            zzza    3\n        (4)string.find (str, substr, [init, [end]]):在一个指定的目标字符串中搜索指定的内容(第三个参数为索引),返回其具体位置。不存在则返回 nil\n            > string.find(\"Hello Lua user\", \"Lua\", 1) \n            7    9\n        (5)string.reverse(arg):字符串反转    \n        (6)string.format(...):返回一个类似printf的格式化字符串\n            > string.format(\"the value is:%d\",4)\n            the value is:4\n        (7)string.char(arg) 和 string.byte(arg[,int]): char 将整型数字转成字符并连接， byte 转换字符为整数值(可以指定某个字符，默认第一个字符)。\n            > string.char(97,98,99,100)\n            abcd\n            > string.byte(\"ABCD\",4)\n            68\n            > string.byte(\"ABCD\")\n            65\n        (8)string.len(arg):计算字符串长度。\n        (9)string.rep(string, n):返回字符串string的n个拷贝\n        (10)\"..\" 符号: 链接两个字符串\n        (11)string.gmatch(str, pattern):回一个迭代器函数，每一次调用这个函数，返回一个在字符串 str 找到的下一个符合 pattern 描述的子串。如果参数 pattern 描述的字符串没有找到，迭代函数返回nil。\n            > for word in string.gmatch(\"Hello Lua user\", \"%a+\") do print(word) end\n            Hello\n            Lua\n            user\n        (12)string.match(str, pattern, init):string.match()只寻找源字串str中的第一个配对. 参数init可选, 指定搜寻过程的起点, 默认为1。 \n                                            在成功配对时, 函数将返回配对表达式中的所有捕获结果; 如果没有设置捕获标记, 则返回整个配对字符串. 当没有成功的配对时, 返回nil。\n             > = string.match(\"I have 2 questions for you.\", \"%d+ %a+\")\n             2 questions\n             > = string.format(\"%d, %q\", string.match(\"I have 2 questions for you.\", \"(%d+) (%a+)\"))\n             2, \"questions\"  \n    3.字符串格式化         \n         Lua 提供了 string.format() 函数来生成具有特定格式的字符串, 函数的第一个参数是格式 , 之后是对应格式中每个代号的各种数据。\n            %c - 接受一个数字, 并将其转化为ASCII码表中对应的字符\n            %d, %i - 接受一个数字并将其转化为有符号的整数格式\n            %o - 接受一个数字并将其转化为八进制数格式\n            %u - 接受一个数字并将其转化为无符号整数格式\n            %x - 接受一个数字并将其转化为十六进制数格式, 使用小写字母\n            %X - 接受一个数字并将其转化为十六进制数格式, 使用大写字母\n            %e - 接受一个数字并将其转化为科学记数法格式, 使用小写字母e\n            %E - 接受一个数字并将其转化为科学记数法格式, 使用大写字母E\n            %f - 接受一个数字并将其转化为浮点数格式\n            %g(%G) - 接受一个数字并将其转化为%e(%E, 对应%G)及%f中较短的一种格式\n            %q - 接受一个字符串并将其转化为可安全被Lua编译器读入的格式\n            %s - 接受一个字符串并按照给定的参数格式化该字符串\n         为进一步细化格式, 可以在%号后添加参数. 参数将以如下的顺序读入:\n            (1) 符号: 一个+号表示其后的数字转义符将让正数显示正号. 默认情况下只有负数显示符号.\n            (2) 占位符: 一个0, 在后面指定了字串宽度时占位用. 不填时的默认占位符是空格.\n            (3) 对齐标识: 在指定了字串宽度时, 默认为右对齐, 增加-号可以改为左对齐.\n            (4) 宽度数值\n            (5) 小数位数/字串裁切: 在宽度数值后增加的小数部分n, 若后接f(浮点数转义符, 如%6.3f)则设定该浮点数的小数只保留n位, 若后接s(字符串转义符, 如%5.3s)则设定该字符串只显示前n位\n         例子:\n            string1 = \"Lua\"\n            string2 = \"Tutorial\"\n            number1 = 10\n            number2 = 20\n            -- 基本字符串格式化\n            print(string.format(\"基本格式化 %s %s\",string1,string2))\n            -- 日期格式化\n            date = 2; month = 1; year = 2014\n            print(string.format(\"日期格式化 %02d/%02d/%03d\", date, month, year))\n            -- 十进制格式化\n            print(string.format(\"%.4f\",1/3))\n    4. 字符与整数相互转换  \n         -- 字符转换\n         -- 转换第一个字符\n         print(string.byte(\"Lua\"))\n         -- 转换第三个字符\n         print(string.byte(\"Lua\",3))\n         -- 转换末尾第一个字符\n         print(string.byte(\"Lua\",-1))\n         -- 第二个字符\n         print(string.byte(\"Lua\",2))\n         -- 转换末尾第二个字符\n         print(string.byte(\"Lua\",-2))\n         -- 整数 ASCII 码转换为字符\n         print(string.char(97))   \n\n##### 字符串--正则表达式\n     Lua 中的匹配模式直接用常规的字符串来描述。 它用于模式匹配函数 string.find, string.gmatch, string.gsub, string.match。\n     你还可以在模式串中使用字符类。\n     字符类指可以匹配一个特定字符集合内任何字符的模式项。比如，字符类%d匹配任意数字。所以你可以使用模式串 '%d%d/%d%d/%d%d%d%d' 搜索 dd/mm/yyyy 格式的日期：\n     下面的表列出了Lua支持的所有字符类：\n     单个字符(除 ^$()%.[]*+-? 外): 与该字符自身配对\n     .(点): 与任何字符配对\n     %a: 与任何字母配对\n     %c: 与任何控制符配对(例如\\n)\n     %d: 与任何数字配对\n     %l: 与任何小写字母配对\n     %p: 与任何标点(punctuation)配对\n     %s: 与空白字符配对\n     %u: 与任何大写字母配对\n     %w: 与任何字母/数字配对\n     %x: 与任何十六进制数配对\n     %z: 与任何代表0的字符配对\n     %x(此处x是非字母非数字字符): 与字符x配对. 主要用来处理表达式中有功能的字符(^$()%.[]*+-?)的配对问题, 例如%%与%配对\n     [数个字符类]: 与任何[]中包含的字符类配对. 例如[%w_]与任何字母/数字, 或下划线符号(_)配对\n     [^数个字符类]: 与任何不包含在[]中的字符类配对. 例如[^%s]与任何非空白字符配对        \n     \n     当上述的字符类用大写书写时, 表示与非此字符类的任何字符配对. 例如, %S表示与任何非空白字符配对.例如，'%A'非字母的字符:\n     > print(string.gsub(\"hello, up-down!\", \"%A\", \".\"))\n     hello..up.down.    4\n     数字4不是字符串结果的一部分，他是gsub返回的第二个结果，代表发生替换的次数。\n     在模式匹配中有一些特殊字符，他们有特殊的意义，Lua中的特殊字符如下：\n     ( ) . % + - * ? [ ^ $\n     '%' 用作特殊字符的转义字符，因此 '%.' 匹配点；'%%' 匹配字符 '%'。转义字符 '%'不仅可以用来转义特殊字符，还可以用于所有的非字母的字符。\n      \n      模式条目可以是：\n          单个字符类匹配该类别中任意单个字符；\n          单个字符类跟一个 '*'， 将匹配零或多个该类的字符。 这个条目总是匹配尽可能长的串；\n          单个字符类跟一个 '+'， 将匹配一或更多个该类的字符。 这个条目总是匹配尽可能长的串；\n          单个字符类跟一个 '-'， 将匹配零或更多个该类的字符。 和 '*' 不同， 这个条目总是匹配尽可能短的串；\n          单个字符类跟一个 '?'， 将匹配零或一个该类的字符。 只要有可能，它会匹配一个；\n          %n， 这里的 n 可以从 1 到 9； 这个条目匹配一个等于 n 号捕获物（后面有描述）的子串。\n          %bxy， 这里的 x 和 y 是两个明确的字符； 这个条目匹配以 x 开始 y 结束， 且其中 x 和 y 保持 平衡 的字符串。 意思是，如果从左到右读这个字符串，对每次读到一个 x 就 +1 ，读到一个 y 就 -1， 最终结束处的那个 y 是第一个记数到 0 的 y。 举个例子，条目 %b() 可以匹配到括号平衡的表达式。\n          %f[set]， 指 边境模式； 这个条目会匹配到一个位于 set 内某个字符之前的一个空串， 且这个位置的前一个字符不属于 set 。 集合 set 的含义如前面所述。 匹配出的那个空串之开始和结束点的计算就看成该处有个字符 '\\0' 一样。\n      模式：\n        模式 指一个模式条目的序列。 在模式最前面加上符号 '^' 将锚定从字符串的开始处做匹配。 在模式最后面加上符号 '$' 将使匹配过程锚定到字符串的结尾。 如果 '^' 和 '$' 出现在其它位置，它们均没有特殊含义，只表示自身。\n      捕获：\n        模式可以在内部用小括号括起一个子模式； 这些子模式被称为 捕获物。 当匹配成功时，由 捕获物 匹配到的字符串中的子串被保存起来用于未来的用途。 捕获物以它们左括号的次序来编号。 例如，对于模式 \"(a*(.)%w(%s*))\" ， 字符串中匹配到 \"a*(.)%w(%s*)\" 的部分保存在第一个捕获物中 （因此是编号 1 ）； 由 \".\" 匹配到的字符是 2 号捕获物， 匹配到 \"%s*\" 的那部分是 3 号。\n      作为一个特例，空的捕获 () 将捕获到当前字符串的位置（它是一个数字）。 例如，如果将模式 \"()aa()\" 作用到字符串 \"flaaap\" 上，将产生两个捕获物： 3 和 5 。\n            \n#### table(表)   \n    在 Lua 里，table 的创获取数据的类型建是通过\"构造表达式\"来完成，最简单构造表达式是{}，用来创建一个空表\n    也可以在表里添加一些数据，直接初始化表:\n    1. 初始化表与移除引用\n        -- 创建一个空的 table\n        local tbl1 = {}         \n        -- 直接初始表\n        local tbl2 = {\"apple\", \"pear\", \"orange\", \"grape\"}\n        -- 初始化表\n        mytable = {} \n        -- 指定值\n        mytable[1]= \"Lua\"\n        -- 移除引用\n        mytable = nil\n        -- lua 垃圾回收会释放内存\n    \n    2. -- 创建一个空的 table\n       local tbl1 = {}\n       -- 直接初始表\n       local tbl2 = {\"apple\", \"pear\", \"orange\", \"grape\"}\n    \n    3. Lua 中的表（table）其实是一个\"关联数组\"（associative arrays），数组的索引可以是数字或者是字符串\n      table 不会固定长度大小，有新数据添加时 table 长度会自动增长，没初始的 table 都是 nil。\n      重点: 不同于其他语言的数组把 0 作为数组的初始索引，在 Lua 里表的默认初始索引一般以 1 开始  \n            local tbl = {\"apple\", \"pear\", \"orange\", \"grape\"}\n            for key, val in pairs(tbl) do\n               print(\"Key\", key)\n            end\n    4. 索引,对 table 的索引使用方括号 []。Lua 也提供了\".\"操作\n        > site = {}\n        > site[\"key\"] = \"www.w3cschool.cc\"\n        > print(site[\"key\"])\n        www.w3cschool.cc\n        > print(site.key)\n        www.w3cschool.cc\n\n##### table -- 操作\n    1.table.concat (table [, sep [, start [, end]]]):concat是concatenate(连锁, 连接)的缩写. table.concat()函数列出参数中指定table的数组部分从start位置到end位置的所有元素, 元素间以指定的分隔符(sep)隔开。\n    2.table.insert (table, [pos,] value):在table的数组部分指定位置(pos)插入值为value的一个元素. pos参数可选, 默认为数组部分末尾.\n    3.table.remove (table [, pos]):返回table数组部分位于pos位置的元素. 其后的元素会被前移. pos参数可选, 默认为table长度, 即从最后一个元素删起。\n    4.table.sort (table [, comp]):对给定的table进行升序排序\n\n##### table -- table间连接,table中的插入,移除,排序\n    使用 concat() 方法来连接两个 table\n        fruits = {\"banana\",\"orange\",\"apple\"}\n        -- 返回 table 连接后的字符串\n        print(\"连接后的字符串 \",table.concat(fruits)\n        -- 指定连接字符\n        print(\"连接后的字符串 \",table.concat(fruits,\", \"))\n        -- 指定索引来连接 table\n        print(\"连接后的字符串 \",table.concat(fruits,\", \", 2,3))\n        \n        fruits = {\"banana\",\"orange\",\"apple\"}\n        -- 在末尾插入\n        table.insert(fruits,\"mango\")\n        print(\"索引为 4 的元素为 \",fruits[4])\n        \n        -- 在索引为 2 的键处插入\n        table.insert(fruits,2,\"grapes\")\n        print(\"索引为 2 的元素为 \",fruits[2])\n        \n        print(\"最后一个元素为 \",fruits[5])\n        table.remove(fruits)\n        print(\"移除后最后一个元素为 \",fruits[5])    \n        \n        --排序\n        fruits = {\"banana\",\"orange\",\"apple\",\"grapes\"}\n        print(\"排序前\")\n        for k,v in ipairs(fruits) do\n            print(k,v)\n        end\n        \n        table.sort(fruits)\n        print(\"排序后\")\n        for k,v in ipairs(fruits) do\n            print(k,v)\n        end\n\n##### table -- 数组\n    1. 一维数组\n        array = {\"Lua\", \"Tutorial\"}\n        \n        for i= 0, 2 do\n           print(array[i])\n        end\n    2. 多维数组\n         -- 初始化数组\n         array = {}\n         for i=1,3 do\n            array[i] = {}\n               for j=1,3 do\n                  array[i][j] = i*j\n               end\n         end\n         \n         -- 访问数组\n         for i=1,3 do\n            for j=1,3 do\n               print(array[i][j])\n            end\n         end   \n        \n#### function（函数）\n    1.在 Lua 中，函数是被看作是\"一类公民（First-Class Value）\"\n        function factorial1(n)\n            if n == 0 then\n                return 1\n            else\n                return n * factorial1(n - 1)\n            end\n        end\n        print(factorial1(5))\n        factorial2 = factorial1\n        print(factorial2(5))\n     \n    2.function 可以以匿名函数（anonymous function）的方式通过参数传递\n        -- function_test2.lua 脚本文件\n        function testFun(tab,fun)\n            for k ,v in pairs(tab) do\n                print(fun(k,v));\n            end\n        end\n        \n        \n        tab={key1=\"val1\",key2=\"val2\"};\n        testFun(tab,\n        function(key,val)--匿名函数\n            return key..\"=\"..val;\n        end\n        );  \n    3. 多返回值\n        Lua函数中，在return后列出要返回的值的列表即可返回多值\n            function maximum (a)\n                local mi = 1             -- 最大值索引\n                local m = a[mi]          -- 最大值\n                for i,val in ipairs(a) do\n                   if val > m then\n                       mi = i\n                       m = val\n                   end\n                end\n                return m, mi\n            end\n            \n            print(maximum({8,10,23,12,5}))     \n\n##### 函数定义\n    optional_function_scope function function_name( argument1, argument2, argument3..., argumentn)\n        function_body\n        return result_params_comma_separated\n    end\n    \n    optional_function_scope: 该参数是可选的制定函数是全局函数还是局部函数，未设置该参数默认为全局函数，如果你需要设置函数为局部函数需要使用关键字 local。\n    function_name: 指定函数名称。\n    argument1, argument2, argument3..., argumentn: 函数参数，多个参数以逗号隔开，函数也可以不带参数。\n    function_body: 函数体，函数中需要执行的代码语句块。\n    result_params_comma_separated: 函数返回值，Lua语言函数可以返回多个值，每个值以逗号隔开。\n    \n##### 函数的可变参数\n       1. 在函数参数列表中使用三点 ... 表示函数有可变的参数\n            function add(...)  \n            local s = 0  \n              for i, v in ipairs{...} do   --> {...} 表示一个由所有变长参数构成的数组  \n                s = s + v  \n              end  \n              return s  \n            end  \n            print(add(3,4,5,6,7))  --->25\n       2. select(\"#\",...) 来获取可变参数的数量\n                function average(...)\n                   result = 0\n                   local arg={...}\n                   for i,v in ipairs(arg) do\n                      result = result + v\n                   end\n                   print(\"总共传入 \" .. select(\"#\",...) .. \" 个数\")\n                   return result/select(\"#\",...)\n                end\n                \n                print(\"平均值为\",average(10,5,3,4,5,6))\n            \n            在遍历变长参数的时候只需要使用 {…}，然而变长参数可能会包含一些 nil，那么就可以用 select 函数来访问变长参数了：select('#', …) 或者 select(n, …)\n            select('#', …) 返回可变参数的长度\n            select(n, …) 用于访问 n 到 select('#',…) 的参数\n            调用select时，必须传入一个固定实参selector(选择开关)和一系列变长参数。如果selector为数字n,那么select返回它的第n个可变实参，否则只能为字符串\"#\",这样select会返回变长参数的总数\n                do  \n                    function foo(...)  \n                        for i = 1, select('#', ...) do  -->获取参数总数\n                            local arg = select(i, ...); -->读取参数\n                            print(\"arg\", arg);  \n                        end  \n                    end  \n                  \n                    foo(1, 2, 3, 4);  \n                end\n        \n#### thread(线程)\n    在 Lua 里，最主要的线程是协同程序（coroutine）。\n    协程跟线程（thread）差不多，拥有自己独立的栈、局部变量和指令指针，可以跟其他协同程序共享全局变量和其他大部分东西。\n    线程跟协程的区别：线程可以同时多个运行，而协程任意时刻只能运行一个，并且处于运行状态的协程只有被挂起（suspend）时才会暂停。\n    \n#### userdata(自定义类型)     \n    userdata 是一种用户自定义数据，用于表示一种由应用程序或 C/C++ 语言库所创建的类型，可以将任意 C/C++ 的任意数据类型的数据（通常是 struct 和 指针）存储到 Lua 变量中调用。\n","slug":"Lua脚本教程-1","published":1,"updated":"2018-12-17T03:47:40.091Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpuya66h00019kuj0g0pfq9l","content":"<h1><span id=\"lua教程\">Lua教程</span></h1>\n<h2><span id=\"简介\">简介</span></h2>\n<h3><span id=\"设计目的\">设计目的</span></h3>\n<pre><code>其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。\n</code></pre>\n<h3><span id=\"lua特性\">Lua特性</span></h3>\n<pre><code>轻量级: 它用标准C语言编写并以源代码形式开放，编译后仅仅一百余K，可以很方便的嵌入别的程序里。\n可扩展: Lua提供了非常易于使用的扩展接口和机制：由宿主语言(通常是C或C++)提供这些功能，Lua可以使用它们，就像是本来就内置的功能一样。\n其它特性:\n支持面向过程(procedure-oriented)编程和函数式编程(functional programming)；\n自动内存管理；只提供了一种通用类型的表（table），用它可以实现数组，哈希表，集合，对象；\n语言内置模式匹配；闭包(closure)；函数也可以看做一个值；提供多线程（协同进程，并非操作系统所支持的线程）支持；\n通过闭包和table可以很方便地支持面向对象编程所需要的一些关键机制，比如数据抽象，虚函数，继承和重载等。\n</code></pre>\n<h2><span id=\"lua安装\">Lua安装</span></h2>\n<pre><code>http://www.runoob.com/lua/lua-environment.html\n</code></pre>\n<h2><span id=\"lua基本语法\">Lua基本语法</span></h2>\n<h3><span id=\"编程模式\">编程模式</span></h3>\n<pre><code>1. 交互式编程 (shell)\n    与python的shell使用方法一致，直接在终端下运行lua命令即可\n2. 脚本式编程\n    创建xxxx.lua文件，然后使用lua xxxx.lua命令或者是luajit xxxx.lua文件即可进行运行\n</code></pre>\n<h3><span id=\"注释\">注释</span></h3>\n<pre><code>1.单行注释\n    --\n2.多行注释\n    --[[\n    多行注释\n    多行注释\n    --]]   \n</code></pre>\n<h3><span id=\"标示符\">标示符</span></h3>\n<pre><code>Lua 是一个区分大小写的编程语言\nLua 标示符用于定义一个变量，函数获取其他用户定义的项。标示符以一个字母 A 到 Z 或 a 到 z 或下划线 _ 开头后加上0个或多个字母，下划线，数字(0到9)\nLua 不允许使用特殊字符如 @, $, 和 % 来定义标示符\n最好不要使用下划线加大写字母的标示符，因为Lua的保留字也是这样的\n一般约定，以下划线开头连接一串大写字母的名字（比如 _VERSION）被保留用于 Lua 内部全局变量\n</code></pre>\n<h3><span id=\"关键词\">关键词</span></h3>\n<pre><code>and    break    do    else\nelseif    end    false    for\nfunction    if    in    local\nnil    not    or    repeat\nreturn    then    true    until\nwhile\n</code></pre>\n<h3><span id=\"变量\">变量</span></h3>\n<pre><code>Lua 变量有三种类型：全局变量、局部变量、表中的域\n变量在使用前，必须在代码中进行声明，即创建该变量\n变量的默认值均为 nil。\n\n1.全局变量\n    (1)在默认情况下，变量总是认为是全局的。\n    (2)全局变量不需要声明，给一个变量赋值后即创建了这个全局变量，访问一个没有初始化的全局变量也不会出错，只不过得到的结果是：nil。\n    (3)如果你想删除一个全局变量，只需要将变量赋值为nil。\n    (4)Lua 中的变量全是全局变量，那怕是语句块或是函数里，除非用 local 显式声明为局部变量。\n2.局部变量\n    局部变量的作用域为从声明位置开始到所在语句块结束。\n3.表中的域\n</code></pre>\n<h4><span id=\"赋值\">赋值</span></h4>\n<pre><code>1. 使用&quot;=&quot;号进行赋值\n2. Lua可以对多个变量同时赋值，变量列表和值列表的各个元素用逗号分开，赋值语句右边的值会依次赋给左边的变量\n    a,b=21,22\n3. 赋值语句Lua会先计算右边所有的值然后再执行赋值操作，所以我们可以这样进行交换变量的值\n    x, y = y, x                     -- swap 'x' for 'y'\n    a[i], a[j] = a[j], a[i]         -- swap 'a[i]' for 'a[j]'  \n4. 重点: 当变量个数和值的个数不一致时，Lua会一直以变量个数为基础采取以下策略\n    a. 变量个数 &gt; 值的个数             按变量个数补足nil\n    b. 变量个数 &lt; 值的个数             多余的值会被忽略\n    \n    a, b, c = 0, 1\n    print(a,b,c)             --&gt; 0   1   nil  \n    \n    a, b = a+1, b+1, b+2     -- value of b+2 is ignored\n    print(a,b)               --&gt; 1   2\n    \n    a, b, c = 0\n    print(a,b,c)             --&gt; 0   nil   nil\n5. 多值赋值经常用来交换变量，或将函数调用返回给变量\n       a, b = f()\n       f()返回两个值，第一个赋给a，第二个赋给b。\n       应该尽可能的使用局部变量，有两个好处：\n           1. 避免命名冲突。\n           2. 访问局部变量的速度比全局变量更快。\n</code></pre>\n<h3><span id=\"数据类型\">数据类型</span></h3>\n<pre><code>Lua是动态类型语言，变量不要类型定义,只需要为变量赋值。 值可以存储在变量中，作为参数传递或结果返回。\nLua中有8个基本类型分别为：nil、boolean、number、string、userdata、function、thread和table。\n\n数据类型\t描述\nnil\t            这个最简单，只有值nil属于该类，表示一个无效值（在条件表达式中相当于false）。\nboolean\t        包含两个值：false和true。Lua认为false和nil为&quot;假&quot;,其他任何值都是&quot;真&quot;,包括0\nnumber\t        表示双精度类型的实浮点数\nstring\t        字符串由一对双引号或单引号来表示\nfunction\t    由 C 或 Lua 编写的函数\nuserdata\t    表示任意存储在变量中的C数据结构\nthread\t        表示执行的独立线路，用于执行协同程序\ntable\t        Lua 中的表（table）其实是一个&quot;关联数组&quot;（associative arrays），数组的索引可以是数字或者是字符串。在 Lua 里，table 的创建是通过&quot;构造表达式&quot;来完成，最简单构造表达式是{}，用来创建一个空表。\n</code></pre>\n<h4><span id=\"获取数据的类型\">获取数据的类型</span></h4>\n<pre><code>重点: type(xxx) -- 返回的都是字符串形式的数据类型\n      type(type(xxx)) == &quot;string&quot;\n\nprint(type(&quot;Hello world&quot;))      --&gt; string      \nprint(type(10.4*3))             --&gt; number\nprint(type(print))              --&gt; function\nprint(type(type))               --&gt; function\nprint(type(true))               --&gt; boolean\nprint(type(nil))                --&gt; nil\nprint(type(type(X)))            --&gt; string\n</code></pre>\n<h4><span id=\"获取当前变量的数据类型是否与设想的一致\">获取当前变量的数据类型是否与设想的一致</span></h4>\n<pre><code>v = &quot;Hello World.&quot;\nif type(v) == &quot;string&quot;\nthen\n    print(&quot;字符串类型&quot;)\nend\n</code></pre>\n<h4><span id=\"nil-空值\">nil (空值)</span></h4>\n<pre><code>nil 类型表示一种没有任何有效值，它只有一个值 -- nil\n作用:对于全局变量和 table，nil 还有一个&quot;删除&quot;作用，给全局变量或者 table 表里的变量赋一个 nil 值，等同于把它们删掉\n   \n    例子:\n        tab1 = { key1 = &quot;val1&quot;, key2 = &quot;val2&quot;, &quot;val3&quot; }\n        for k, v in pairs(tab1) do\n            print(k .. &quot; - &quot; .. v)\n        end\n         \n        tab1.key1 = nil\n        for k, v in pairs(tab1) do\n            print(k .. &quot; - &quot; .. v)\n        end\n</code></pre>\n<h4><span id=\"boolean布尔值\">boolean(布尔值)</span></h4>\n<pre><code>boolean 类型只有两个可选值：true（真） 和 false（假），Lua 把 false 和 nil 看作是&quot;假&quot;，其他的都为&quot;真&quot;,包括&quot;0&quot;也是真\n</code></pre>\n<h4><span id=\"number数字\">number(数字)</span></h4>\n<pre><code>Lua 默认只有一种 number 类型 -- double（双精度）类型（默认类型可以修改 luaconf.h 里的定义）\n</code></pre>\n<h4><span id=\"string字符串\">string(字符串)</span></h4>\n<pre><code>1. 字符串由一对双引号或单引号来表示。\n    string1 = &quot;this is string1&quot;\n    string2 = 'this is string2'\n2. 两个方括号 &quot;[[]]&quot; 来表示&quot;一块&quot;字符串,用于多行文本 \n    html = [[\n    &lt;html&gt;\n    &lt;head&gt;&lt;/head&gt;\n    &lt;body&gt;\n        &lt;a href=&quot;http://www.runoob.com/&quot;&gt;菜鸟教程&lt;/a&gt;\n    &lt;/body&gt;\n    &lt;/html&gt;\n    ]]\n3. 在对一个数字字符串上进行算术操作时，Lua 会尝试将这个数字字符串转成一个数字\n    &gt; print(&quot;2&quot; + 6)\n    8.0\n    &gt; print(&quot;2&quot; + &quot;6&quot;)\n    8.0\n    &gt; print(&quot;2 + 6&quot;)\n    2 + 6\n    &gt; print(&quot;-2e2&quot; * &quot;6&quot;)\n    -1200.0\n4. 字符串连接符&quot;..&quot;\n     &gt; print(&quot;a&quot; .. 'b')\n     ab\n     &gt; print(157 .. 428)\n     157428\n     &gt; \n5. 计算字符串长度\n     &gt; len = &quot;www.runoob.com&quot;\n     &gt; print(#len)\n     14\n     &gt; print(#&quot;www.runoob.com&quot;)\n     14\n</code></pre>\n<h5><span id=\"字符串用法拓展\">字符串用法拓展</span></h5>\n<pre><code>1. 常规的转义符号\n    \\a  响铃(BEL)\n    \\b  退格(BS) ，将当前位置移到前一列\n    \\f  换页(FF)，将当前位置移到下页开头\n    \\n  换行(LF) ，将当前位置移到下一行开头\n    \\r  回车(CR) ，将当前位置移到本行开头\n    \\t  水平制表(HT) （跳到下一个TAB位置）\n    \\v  垂直制表(VT)\n    \\\\  代表一个反斜线字符''\\'\n    \\'  代表一个单引号（撇号）字符\n    \\&quot;  代表一个双引号字符\n    \\0  空字符(NULL)\n    \\ddd    1到3位八进制数所代表的任意字符\n    \\xhh    1到2位十六进制所代表的任意字符\n\n2. 字符串操作\n    (1)string.upper(argument):字符串全部转为大写字母  \n    (2)string.lower(argument):字符串全部转为小写字母\n    (3)string.gsub(mainString,findString,replaceString,num):在字符串中替换,mainString为要替换的字符串， findString 为被替换的字符，replaceString 要替换的字符，num 替换次数（可以忽略，则全部替换）\n        &gt; string.gsub(&quot;aaaa&quot;,&quot;a&quot;,&quot;z&quot;,3);\n        zzza    3\n    (4)string.find (str, substr, [init, [end]]):在一个指定的目标字符串中搜索指定的内容(第三个参数为索引),返回其具体位置。不存在则返回 nil\n        &gt; string.find(&quot;Hello Lua user&quot;, &quot;Lua&quot;, 1) \n        7    9\n    (5)string.reverse(arg):字符串反转    \n    (6)string.format(...):返回一个类似printf的格式化字符串\n        &gt; string.format(&quot;the value is:%d&quot;,4)\n        the value is:4\n    (7)string.char(arg) 和 string.byte(arg[,int]): char 将整型数字转成字符并连接， byte 转换字符为整数值(可以指定某个字符，默认第一个字符)。\n        &gt; string.char(97,98,99,100)\n        abcd\n        &gt; string.byte(&quot;ABCD&quot;,4)\n        68\n        &gt; string.byte(&quot;ABCD&quot;)\n        65\n    (8)string.len(arg):计算字符串长度。\n    (9)string.rep(string, n):返回字符串string的n个拷贝\n    (10)&quot;..&quot; 符号: 链接两个字符串\n    (11)string.gmatch(str, pattern):回一个迭代器函数，每一次调用这个函数，返回一个在字符串 str 找到的下一个符合 pattern 描述的子串。如果参数 pattern 描述的字符串没有找到，迭代函数返回nil。\n        &gt; for word in string.gmatch(&quot;Hello Lua user&quot;, &quot;%a+&quot;) do print(word) end\n        Hello\n        Lua\n        user\n    (12)string.match(str, pattern, init):string.match()只寻找源字串str中的第一个配对. 参数init可选, 指定搜寻过程的起点, 默认为1。 \n                                        在成功配对时, 函数将返回配对表达式中的所有捕获结果; 如果没有设置捕获标记, 则返回整个配对字符串. 当没有成功的配对时, 返回nil。\n         &gt; = string.match(&quot;I have 2 questions for you.&quot;, &quot;%d+ %a+&quot;)\n         2 questions\n         &gt; = string.format(&quot;%d, %q&quot;, string.match(&quot;I have 2 questions for you.&quot;, &quot;(%d+) (%a+)&quot;))\n         2, &quot;questions&quot;  \n3.字符串格式化         \n     Lua 提供了 string.format() 函数来生成具有特定格式的字符串, 函数的第一个参数是格式 , 之后是对应格式中每个代号的各种数据。\n        %c - 接受一个数字, 并将其转化为ASCII码表中对应的字符\n        %d, %i - 接受一个数字并将其转化为有符号的整数格式\n        %o - 接受一个数字并将其转化为八进制数格式\n        %u - 接受一个数字并将其转化为无符号整数格式\n        %x - 接受一个数字并将其转化为十六进制数格式, 使用小写字母\n        %X - 接受一个数字并将其转化为十六进制数格式, 使用大写字母\n        %e - 接受一个数字并将其转化为科学记数法格式, 使用小写字母e\n        %E - 接受一个数字并将其转化为科学记数法格式, 使用大写字母E\n        %f - 接受一个数字并将其转化为浮点数格式\n        %g(%G) - 接受一个数字并将其转化为%e(%E, 对应%G)及%f中较短的一种格式\n        %q - 接受一个字符串并将其转化为可安全被Lua编译器读入的格式\n        %s - 接受一个字符串并按照给定的参数格式化该字符串\n     为进一步细化格式, 可以在%号后添加参数. 参数将以如下的顺序读入:\n        (1) 符号: 一个+号表示其后的数字转义符将让正数显示正号. 默认情况下只有负数显示符号.\n        (2) 占位符: 一个0, 在后面指定了字串宽度时占位用. 不填时的默认占位符是空格.\n        (3) 对齐标识: 在指定了字串宽度时, 默认为右对齐, 增加-号可以改为左对齐.\n        (4) 宽度数值\n        (5) 小数位数/字串裁切: 在宽度数值后增加的小数部分n, 若后接f(浮点数转义符, 如%6.3f)则设定该浮点数的小数只保留n位, 若后接s(字符串转义符, 如%5.3s)则设定该字符串只显示前n位\n     例子:\n        string1 = &quot;Lua&quot;\n        string2 = &quot;Tutorial&quot;\n        number1 = 10\n        number2 = 20\n        -- 基本字符串格式化\n        print(string.format(&quot;基本格式化 %s %s&quot;,string1,string2))\n        -- 日期格式化\n        date = 2; month = 1; year = 2014\n        print(string.format(&quot;日期格式化 %02d/%02d/%03d&quot;, date, month, year))\n        -- 十进制格式化\n        print(string.format(&quot;%.4f&quot;,1/3))\n4. 字符与整数相互转换  \n     -- 字符转换\n     -- 转换第一个字符\n     print(string.byte(&quot;Lua&quot;))\n     -- 转换第三个字符\n     print(string.byte(&quot;Lua&quot;,3))\n     -- 转换末尾第一个字符\n     print(string.byte(&quot;Lua&quot;,-1))\n     -- 第二个字符\n     print(string.byte(&quot;Lua&quot;,2))\n     -- 转换末尾第二个字符\n     print(string.byte(&quot;Lua&quot;,-2))\n     -- 整数 ASCII 码转换为字符\n     print(string.char(97))   \n</code></pre>\n<h5><span id=\"字符串正则表达式\">字符串–正则表达式</span></h5>\n<pre><code> Lua 中的匹配模式直接用常规的字符串来描述。 它用于模式匹配函数 string.find, string.gmatch, string.gsub, string.match。\n 你还可以在模式串中使用字符类。\n 字符类指可以匹配一个特定字符集合内任何字符的模式项。比如，字符类%d匹配任意数字。所以你可以使用模式串 '%d%d/%d%d/%d%d%d%d' 搜索 dd/mm/yyyy 格式的日期：\n 下面的表列出了Lua支持的所有字符类：\n 单个字符(除 ^$()%.[]*+-? 外): 与该字符自身配对\n .(点): 与任何字符配对\n %a: 与任何字母配对\n %c: 与任何控制符配对(例如\\n)\n %d: 与任何数字配对\n %l: 与任何小写字母配对\n %p: 与任何标点(punctuation)配对\n %s: 与空白字符配对\n %u: 与任何大写字母配对\n %w: 与任何字母/数字配对\n %x: 与任何十六进制数配对\n %z: 与任何代表0的字符配对\n %x(此处x是非字母非数字字符): 与字符x配对. 主要用来处理表达式中有功能的字符(^$()%.[]*+-?)的配对问题, 例如%%与%配对\n [数个字符类]: 与任何[]中包含的字符类配对. 例如[%w_]与任何字母/数字, 或下划线符号(_)配对\n [^数个字符类]: 与任何不包含在[]中的字符类配对. 例如[^%s]与任何非空白字符配对        \n \n 当上述的字符类用大写书写时, 表示与非此字符类的任何字符配对. 例如, %S表示与任何非空白字符配对.例如，'%A'非字母的字符:\n &gt; print(string.gsub(&quot;hello, up-down!&quot;, &quot;%A&quot;, &quot;.&quot;))\n hello..up.down.    4\n 数字4不是字符串结果的一部分，他是gsub返回的第二个结果，代表发生替换的次数。\n 在模式匹配中有一些特殊字符，他们有特殊的意义，Lua中的特殊字符如下：\n ( ) . % + - * ? [ ^ $\n '%' 用作特殊字符的转义字符，因此 '%.' 匹配点；'%%' 匹配字符 '%'。转义字符 '%'不仅可以用来转义特殊字符，还可以用于所有的非字母的字符。\n  \n  模式条目可以是：\n      单个字符类匹配该类别中任意单个字符；\n      单个字符类跟一个 '*'， 将匹配零或多个该类的字符。 这个条目总是匹配尽可能长的串；\n      单个字符类跟一个 '+'， 将匹配一或更多个该类的字符。 这个条目总是匹配尽可能长的串；\n      单个字符类跟一个 '-'， 将匹配零或更多个该类的字符。 和 '*' 不同， 这个条目总是匹配尽可能短的串；\n      单个字符类跟一个 '?'， 将匹配零或一个该类的字符。 只要有可能，它会匹配一个；\n      %n， 这里的 n 可以从 1 到 9； 这个条目匹配一个等于 n 号捕获物（后面有描述）的子串。\n      %bxy， 这里的 x 和 y 是两个明确的字符； 这个条目匹配以 x 开始 y 结束， 且其中 x 和 y 保持 平衡 的字符串。 意思是，如果从左到右读这个字符串，对每次读到一个 x 就 +1 ，读到一个 y 就 -1， 最终结束处的那个 y 是第一个记数到 0 的 y。 举个例子，条目 %b() 可以匹配到括号平衡的表达式。\n      %f[set]， 指 边境模式； 这个条目会匹配到一个位于 set 内某个字符之前的一个空串， 且这个位置的前一个字符不属于 set 。 集合 set 的含义如前面所述。 匹配出的那个空串之开始和结束点的计算就看成该处有个字符 '\\0' 一样。\n  模式：\n    模式 指一个模式条目的序列。 在模式最前面加上符号 '^' 将锚定从字符串的开始处做匹配。 在模式最后面加上符号 '$' 将使匹配过程锚定到字符串的结尾。 如果 '^' 和 '$' 出现在其它位置，它们均没有特殊含义，只表示自身。\n  捕获：\n    模式可以在内部用小括号括起一个子模式； 这些子模式被称为 捕获物。 当匹配成功时，由 捕获物 匹配到的字符串中的子串被保存起来用于未来的用途。 捕获物以它们左括号的次序来编号。 例如，对于模式 &quot;(a*(.)%w(%s*))&quot; ， 字符串中匹配到 &quot;a*(.)%w(%s*)&quot; 的部分保存在第一个捕获物中 （因此是编号 1 ）； 由 &quot;.&quot; 匹配到的字符是 2 号捕获物， 匹配到 &quot;%s*&quot; 的那部分是 3 号。\n  作为一个特例，空的捕获 () 将捕获到当前字符串的位置（它是一个数字）。 例如，如果将模式 &quot;()aa()&quot; 作用到字符串 &quot;flaaap&quot; 上，将产生两个捕获物： 3 和 5 。\n</code></pre>\n<h4><span id=\"table表\">table(表)</span></h4>\n<pre><code>在 Lua 里，table 的创获取数据的类型建是通过&quot;构造表达式&quot;来完成，最简单构造表达式是{}，用来创建一个空表\n也可以在表里添加一些数据，直接初始化表:\n1. 初始化表与移除引用\n    -- 创建一个空的 table\n    local tbl1 = {}         \n    -- 直接初始表\n    local tbl2 = {&quot;apple&quot;, &quot;pear&quot;, &quot;orange&quot;, &quot;grape&quot;}\n    -- 初始化表\n    mytable = {} \n    -- 指定值\n    mytable[1]= &quot;Lua&quot;\n    -- 移除引用\n    mytable = nil\n    -- lua 垃圾回收会释放内存\n\n2. -- 创建一个空的 table\n   local tbl1 = {}\n   -- 直接初始表\n   local tbl2 = {&quot;apple&quot;, &quot;pear&quot;, &quot;orange&quot;, &quot;grape&quot;}\n\n3. Lua 中的表（table）其实是一个&quot;关联数组&quot;（associative arrays），数组的索引可以是数字或者是字符串\n  table 不会固定长度大小，有新数据添加时 table 长度会自动增长，没初始的 table 都是 nil。\n  重点: 不同于其他语言的数组把 0 作为数组的初始索引，在 Lua 里表的默认初始索引一般以 1 开始  \n        local tbl = {&quot;apple&quot;, &quot;pear&quot;, &quot;orange&quot;, &quot;grape&quot;}\n        for key, val in pairs(tbl) do\n           print(&quot;Key&quot;, key)\n        end\n4. 索引,对 table 的索引使用方括号 []。Lua 也提供了&quot;.&quot;操作\n    &gt; site = {}\n    &gt; site[&quot;key&quot;] = &quot;www.w3cschool.cc&quot;\n    &gt; print(site[&quot;key&quot;])\n    www.w3cschool.cc\n    &gt; print(site.key)\n    www.w3cschool.cc\n</code></pre>\n<h5><span id=\"table-操作\">table – 操作</span></h5>\n<pre><code>1.table.concat (table [, sep [, start [, end]]]):concat是concatenate(连锁, 连接)的缩写. table.concat()函数列出参数中指定table的数组部分从start位置到end位置的所有元素, 元素间以指定的分隔符(sep)隔开。\n2.table.insert (table, [pos,] value):在table的数组部分指定位置(pos)插入值为value的一个元素. pos参数可选, 默认为数组部分末尾.\n3.table.remove (table [, pos]):返回table数组部分位于pos位置的元素. 其后的元素会被前移. pos参数可选, 默认为table长度, 即从最后一个元素删起。\n4.table.sort (table [, comp]):对给定的table进行升序排序\n</code></pre>\n<h5><span id=\"table-table间连接table中的插入移除排序\">table – table间连接,table中的插入,移除,排序</span></h5>\n<pre><code>使用 concat() 方法来连接两个 table\n    fruits = {&quot;banana&quot;,&quot;orange&quot;,&quot;apple&quot;}\n    -- 返回 table 连接后的字符串\n    print(&quot;连接后的字符串 &quot;,table.concat(fruits)\n    -- 指定连接字符\n    print(&quot;连接后的字符串 &quot;,table.concat(fruits,&quot;, &quot;))\n    -- 指定索引来连接 table\n    print(&quot;连接后的字符串 &quot;,table.concat(fruits,&quot;, &quot;, 2,3))\n    \n    fruits = {&quot;banana&quot;,&quot;orange&quot;,&quot;apple&quot;}\n    -- 在末尾插入\n    table.insert(fruits,&quot;mango&quot;)\n    print(&quot;索引为 4 的元素为 &quot;,fruits[4])\n    \n    -- 在索引为 2 的键处插入\n    table.insert(fruits,2,&quot;grapes&quot;)\n    print(&quot;索引为 2 的元素为 &quot;,fruits[2])\n    \n    print(&quot;最后一个元素为 &quot;,fruits[5])\n    table.remove(fruits)\n    print(&quot;移除后最后一个元素为 &quot;,fruits[5])    \n    \n    --排序\n    fruits = {&quot;banana&quot;,&quot;orange&quot;,&quot;apple&quot;,&quot;grapes&quot;}\n    print(&quot;排序前&quot;)\n    for k,v in ipairs(fruits) do\n        print(k,v)\n    end\n    \n    table.sort(fruits)\n    print(&quot;排序后&quot;)\n    for k,v in ipairs(fruits) do\n        print(k,v)\n    end\n</code></pre>\n<h5><span id=\"table-数组\">table – 数组</span></h5>\n<pre><code>1. 一维数组\n    array = {&quot;Lua&quot;, &quot;Tutorial&quot;}\n    \n    for i= 0, 2 do\n       print(array[i])\n    end\n2. 多维数组\n     -- 初始化数组\n     array = {}\n     for i=1,3 do\n        array[i] = {}\n           for j=1,3 do\n              array[i][j] = i*j\n           end\n     end\n     \n     -- 访问数组\n     for i=1,3 do\n        for j=1,3 do\n           print(array[i][j])\n        end\n     end   \n</code></pre>\n<h4><span id=\"function函数\">function（函数）</span></h4>\n<pre><code>1.在 Lua 中，函数是被看作是&quot;一类公民（First-Class Value）&quot;\n    function factorial1(n)\n        if n == 0 then\n            return 1\n        else\n            return n * factorial1(n - 1)\n        end\n    end\n    print(factorial1(5))\n    factorial2 = factorial1\n    print(factorial2(5))\n \n2.function 可以以匿名函数（anonymous function）的方式通过参数传递\n    -- function_test2.lua 脚本文件\n    function testFun(tab,fun)\n        for k ,v in pairs(tab) do\n            print(fun(k,v));\n        end\n    end\n    \n    \n    tab={key1=&quot;val1&quot;,key2=&quot;val2&quot;};\n    testFun(tab,\n    function(key,val)--匿名函数\n        return key..&quot;=&quot;..val;\n    end\n    );  \n3. 多返回值\n    Lua函数中，在return后列出要返回的值的列表即可返回多值\n        function maximum (a)\n            local mi = 1             -- 最大值索引\n            local m = a[mi]          -- 最大值\n            for i,val in ipairs(a) do\n               if val &gt; m then\n                   mi = i\n                   m = val\n               end\n            end\n            return m, mi\n        end\n        \n        print(maximum({8,10,23,12,5}))     \n</code></pre>\n<h5><span id=\"函数定义\">函数定义</span></h5>\n<pre><code>optional_function_scope function function_name( argument1, argument2, argument3..., argumentn)\n    function_body\n    return result_params_comma_separated\nend\n\noptional_function_scope: 该参数是可选的制定函数是全局函数还是局部函数，未设置该参数默认为全局函数，如果你需要设置函数为局部函数需要使用关键字 local。\nfunction_name: 指定函数名称。\nargument1, argument2, argument3..., argumentn: 函数参数，多个参数以逗号隔开，函数也可以不带参数。\nfunction_body: 函数体，函数中需要执行的代码语句块。\nresult_params_comma_separated: 函数返回值，Lua语言函数可以返回多个值，每个值以逗号隔开。\n</code></pre>\n<h5><span id=\"函数的可变参数\">函数的可变参数</span></h5>\n<pre><code>   1. 在函数参数列表中使用三点 ... 表示函数有可变的参数\n        function add(...)  \n        local s = 0  \n          for i, v in ipairs{...} do   --&gt; {...} 表示一个由所有变长参数构成的数组  \n            s = s + v  \n          end  \n          return s  \n        end  \n        print(add(3,4,5,6,7))  ---&gt;25\n   2. select(&quot;#&quot;,...) 来获取可变参数的数量\n            function average(...)\n               result = 0\n               local arg={...}\n               for i,v in ipairs(arg) do\n                  result = result + v\n               end\n               print(&quot;总共传入 &quot; .. select(&quot;#&quot;,...) .. &quot; 个数&quot;)\n               return result/select(&quot;#&quot;,...)\n            end\n            \n            print(&quot;平均值为&quot;,average(10,5,3,4,5,6))\n        \n        在遍历变长参数的时候只需要使用 {…}，然而变长参数可能会包含一些 nil，那么就可以用 select 函数来访问变长参数了：select('#', …) 或者 select(n, …)\n        select('#', …) 返回可变参数的长度\n        select(n, …) 用于访问 n 到 select('#',…) 的参数\n        调用select时，必须传入一个固定实参selector(选择开关)和一系列变长参数。如果selector为数字n,那么select返回它的第n个可变实参，否则只能为字符串&quot;#&quot;,这样select会返回变长参数的总数\n            do  \n                function foo(...)  \n                    for i = 1, select('#', ...) do  --&gt;获取参数总数\n                        local arg = select(i, ...); --&gt;读取参数\n                        print(&quot;arg&quot;, arg);  \n                    end  \n                end  \n              \n                foo(1, 2, 3, 4);  \n            end\n</code></pre>\n<h4><span id=\"thread线程\">thread(线程)</span></h4>\n<pre><code>在 Lua 里，最主要的线程是协同程序（coroutine）。\n协程跟线程（thread）差不多，拥有自己独立的栈、局部变量和指令指针，可以跟其他协同程序共享全局变量和其他大部分东西。\n线程跟协程的区别：线程可以同时多个运行，而协程任意时刻只能运行一个，并且处于运行状态的协程只有被挂起（suspend）时才会暂停。\n</code></pre>\n<h4><span id=\"userdata自定义类型\">userdata(自定义类型)</span></h4>\n<pre><code>userdata 是一种用户自定义数据，用于表示一种由应用程序或 C/C++ 语言库所创建的类型，可以将任意 C/C++ 的任意数据类型的数据（通常是 struct 和 指针）存储到 Lua 变量中调用。\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1>Lua教程</h1>\n<h2>简介</h2>\n<h3>设计目的</h3>\n<pre><code>其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。\n</code></pre>\n<h3>Lua特性</h3>\n<pre><code>轻量级: 它用标准C语言编写并以源代码形式开放，编译后仅仅一百余K，可以很方便的嵌入别的程序里。\n可扩展: Lua提供了非常易于使用的扩展接口和机制：由宿主语言(通常是C或C++)提供这些功能，Lua可以使用它们，就像是本来就内置的功能一样。\n其它特性:\n支持面向过程(procedure-oriented)编程和函数式编程(functional programming)；\n自动内存管理；只提供了一种通用类型的表（table），用它可以实现数组，哈希表，集合，对象；\n语言内置模式匹配；闭包(closure)；函数也可以看做一个值；提供多线程（协同进程，并非操作系统所支持的线程）支持；\n通过闭包和table可以很方便地支持面向对象编程所需要的一些关键机制，比如数据抽象，虚函数，继承和重载等。\n</code></pre>\n<h2>Lua安装</h2>\n<pre><code>http://www.runoob.com/lua/lua-environment.html\n</code></pre>\n<h2>Lua基本语法</h2>\n<h3>编程模式</h3>\n<pre><code>1. 交互式编程 (shell)\n    与python的shell使用方法一致，直接在终端下运行lua命令即可\n2. 脚本式编程\n    创建xxxx.lua文件，然后使用lua xxxx.lua命令或者是luajit xxxx.lua文件即可进行运行\n</code></pre>\n<h3>注释</h3>\n<pre><code>1.单行注释\n    --\n2.多行注释\n    --[[\n    多行注释\n    多行注释\n    --]]   \n</code></pre>\n<h3>标示符</h3>\n<pre><code>Lua 是一个区分大小写的编程语言\nLua 标示符用于定义一个变量，函数获取其他用户定义的项。标示符以一个字母 A 到 Z 或 a 到 z 或下划线 _ 开头后加上0个或多个字母，下划线，数字(0到9)\nLua 不允许使用特殊字符如 @, $, 和 % 来定义标示符\n最好不要使用下划线加大写字母的标示符，因为Lua的保留字也是这样的\n一般约定，以下划线开头连接一串大写字母的名字（比如 _VERSION）被保留用于 Lua 内部全局变量\n</code></pre>\n<h3>关键词</h3>\n<pre><code>and    break    do    else\nelseif    end    false    for\nfunction    if    in    local\nnil    not    or    repeat\nreturn    then    true    until\nwhile\n</code></pre>\n<h3>变量</h3>\n<pre><code>Lua 变量有三种类型：全局变量、局部变量、表中的域\n变量在使用前，必须在代码中进行声明，即创建该变量\n变量的默认值均为 nil。\n\n1.全局变量\n    (1)在默认情况下，变量总是认为是全局的。\n    (2)全局变量不需要声明，给一个变量赋值后即创建了这个全局变量，访问一个没有初始化的全局变量也不会出错，只不过得到的结果是：nil。\n    (3)如果你想删除一个全局变量，只需要将变量赋值为nil。\n    (4)Lua 中的变量全是全局变量，那怕是语句块或是函数里，除非用 local 显式声明为局部变量。\n2.局部变量\n    局部变量的作用域为从声明位置开始到所在语句块结束。\n3.表中的域\n</code></pre>\n<h4>赋值</h4>\n<pre><code>1. 使用&quot;=&quot;号进行赋值\n2. Lua可以对多个变量同时赋值，变量列表和值列表的各个元素用逗号分开，赋值语句右边的值会依次赋给左边的变量\n    a,b=21,22\n3. 赋值语句Lua会先计算右边所有的值然后再执行赋值操作，所以我们可以这样进行交换变量的值\n    x, y = y, x                     -- swap 'x' for 'y'\n    a[i], a[j] = a[j], a[i]         -- swap 'a[i]' for 'a[j]'  \n4. 重点: 当变量个数和值的个数不一致时，Lua会一直以变量个数为基础采取以下策略\n    a. 变量个数 &gt; 值的个数             按变量个数补足nil\n    b. 变量个数 &lt; 值的个数             多余的值会被忽略\n    \n    a, b, c = 0, 1\n    print(a,b,c)             --&gt; 0   1   nil  \n    \n    a, b = a+1, b+1, b+2     -- value of b+2 is ignored\n    print(a,b)               --&gt; 1   2\n    \n    a, b, c = 0\n    print(a,b,c)             --&gt; 0   nil   nil\n5. 多值赋值经常用来交换变量，或将函数调用返回给变量\n       a, b = f()\n       f()返回两个值，第一个赋给a，第二个赋给b。\n       应该尽可能的使用局部变量，有两个好处：\n           1. 避免命名冲突。\n           2. 访问局部变量的速度比全局变量更快。\n</code></pre>\n<h3>数据类型</h3>\n<pre><code>Lua是动态类型语言，变量不要类型定义,只需要为变量赋值。 值可以存储在变量中，作为参数传递或结果返回。\nLua中有8个基本类型分别为：nil、boolean、number、string、userdata、function、thread和table。\n\n数据类型\t描述\nnil\t            这个最简单，只有值nil属于该类，表示一个无效值（在条件表达式中相当于false）。\nboolean\t        包含两个值：false和true。Lua认为false和nil为&quot;假&quot;,其他任何值都是&quot;真&quot;,包括0\nnumber\t        表示双精度类型的实浮点数\nstring\t        字符串由一对双引号或单引号来表示\nfunction\t    由 C 或 Lua 编写的函数\nuserdata\t    表示任意存储在变量中的C数据结构\nthread\t        表示执行的独立线路，用于执行协同程序\ntable\t        Lua 中的表（table）其实是一个&quot;关联数组&quot;（associative arrays），数组的索引可以是数字或者是字符串。在 Lua 里，table 的创建是通过&quot;构造表达式&quot;来完成，最简单构造表达式是{}，用来创建一个空表。\n</code></pre>\n<h4>获取数据的类型</h4>\n<pre><code>重点: type(xxx) -- 返回的都是字符串形式的数据类型\n      type(type(xxx)) == &quot;string&quot;\n\nprint(type(&quot;Hello world&quot;))      --&gt; string      \nprint(type(10.4*3))             --&gt; number\nprint(type(print))              --&gt; function\nprint(type(type))               --&gt; function\nprint(type(true))               --&gt; boolean\nprint(type(nil))                --&gt; nil\nprint(type(type(X)))            --&gt; string\n</code></pre>\n<h4>获取当前变量的数据类型是否与设想的一致</h4>\n<pre><code>v = &quot;Hello World.&quot;\nif type(v) == &quot;string&quot;\nthen\n    print(&quot;字符串类型&quot;)\nend\n</code></pre>\n<h4>nil (空值)</h4>\n<pre><code>nil 类型表示一种没有任何有效值，它只有一个值 -- nil\n作用:对于全局变量和 table，nil 还有一个&quot;删除&quot;作用，给全局变量或者 table 表里的变量赋一个 nil 值，等同于把它们删掉\n   \n    例子:\n        tab1 = { key1 = &quot;val1&quot;, key2 = &quot;val2&quot;, &quot;val3&quot; }\n        for k, v in pairs(tab1) do\n            print(k .. &quot; - &quot; .. v)\n        end\n         \n        tab1.key1 = nil\n        for k, v in pairs(tab1) do\n            print(k .. &quot; - &quot; .. v)\n        end\n</code></pre>\n<h4>boolean(布尔值)</h4>\n<pre><code>boolean 类型只有两个可选值：true（真） 和 false（假），Lua 把 false 和 nil 看作是&quot;假&quot;，其他的都为&quot;真&quot;,包括&quot;0&quot;也是真\n</code></pre>\n<h4>number(数字)</h4>\n<pre><code>Lua 默认只有一种 number 类型 -- double（双精度）类型（默认类型可以修改 luaconf.h 里的定义）\n</code></pre>\n<h4>string(字符串)</h4>\n<pre><code>1. 字符串由一对双引号或单引号来表示。\n    string1 = &quot;this is string1&quot;\n    string2 = 'this is string2'\n2. 两个方括号 &quot;[[]]&quot; 来表示&quot;一块&quot;字符串,用于多行文本 \n    html = [[\n    &lt;html&gt;\n    &lt;head&gt;&lt;/head&gt;\n    &lt;body&gt;\n        &lt;a href=&quot;http://www.runoob.com/&quot;&gt;菜鸟教程&lt;/a&gt;\n    &lt;/body&gt;\n    &lt;/html&gt;\n    ]]\n3. 在对一个数字字符串上进行算术操作时，Lua 会尝试将这个数字字符串转成一个数字\n    &gt; print(&quot;2&quot; + 6)\n    8.0\n    &gt; print(&quot;2&quot; + &quot;6&quot;)\n    8.0\n    &gt; print(&quot;2 + 6&quot;)\n    2 + 6\n    &gt; print(&quot;-2e2&quot; * &quot;6&quot;)\n    -1200.0\n4. 字符串连接符&quot;..&quot;\n     &gt; print(&quot;a&quot; .. 'b')\n     ab\n     &gt; print(157 .. 428)\n     157428\n     &gt; \n5. 计算字符串长度\n     &gt; len = &quot;www.runoob.com&quot;\n     &gt; print(#len)\n     14\n     &gt; print(#&quot;www.runoob.com&quot;)\n     14\n</code></pre>\n<h5>字符串用法拓展</h5>\n<pre><code>1. 常规的转义符号\n    \\a  响铃(BEL)\n    \\b  退格(BS) ，将当前位置移到前一列\n    \\f  换页(FF)，将当前位置移到下页开头\n    \\n  换行(LF) ，将当前位置移到下一行开头\n    \\r  回车(CR) ，将当前位置移到本行开头\n    \\t  水平制表(HT) （跳到下一个TAB位置）\n    \\v  垂直制表(VT)\n    \\\\  代表一个反斜线字符''\\'\n    \\'  代表一个单引号（撇号）字符\n    \\&quot;  代表一个双引号字符\n    \\0  空字符(NULL)\n    \\ddd    1到3位八进制数所代表的任意字符\n    \\xhh    1到2位十六进制所代表的任意字符\n\n2. 字符串操作\n    (1)string.upper(argument):字符串全部转为大写字母  \n    (2)string.lower(argument):字符串全部转为小写字母\n    (3)string.gsub(mainString,findString,replaceString,num):在字符串中替换,mainString为要替换的字符串， findString 为被替换的字符，replaceString 要替换的字符，num 替换次数（可以忽略，则全部替换）\n        &gt; string.gsub(&quot;aaaa&quot;,&quot;a&quot;,&quot;z&quot;,3);\n        zzza    3\n    (4)string.find (str, substr, [init, [end]]):在一个指定的目标字符串中搜索指定的内容(第三个参数为索引),返回其具体位置。不存在则返回 nil\n        &gt; string.find(&quot;Hello Lua user&quot;, &quot;Lua&quot;, 1) \n        7    9\n    (5)string.reverse(arg):字符串反转    \n    (6)string.format(...):返回一个类似printf的格式化字符串\n        &gt; string.format(&quot;the value is:%d&quot;,4)\n        the value is:4\n    (7)string.char(arg) 和 string.byte(arg[,int]): char 将整型数字转成字符并连接， byte 转换字符为整数值(可以指定某个字符，默认第一个字符)。\n        &gt; string.char(97,98,99,100)\n        abcd\n        &gt; string.byte(&quot;ABCD&quot;,4)\n        68\n        &gt; string.byte(&quot;ABCD&quot;)\n        65\n    (8)string.len(arg):计算字符串长度。\n    (9)string.rep(string, n):返回字符串string的n个拷贝\n    (10)&quot;..&quot; 符号: 链接两个字符串\n    (11)string.gmatch(str, pattern):回一个迭代器函数，每一次调用这个函数，返回一个在字符串 str 找到的下一个符合 pattern 描述的子串。如果参数 pattern 描述的字符串没有找到，迭代函数返回nil。\n        &gt; for word in string.gmatch(&quot;Hello Lua user&quot;, &quot;%a+&quot;) do print(word) end\n        Hello\n        Lua\n        user\n    (12)string.match(str, pattern, init):string.match()只寻找源字串str中的第一个配对. 参数init可选, 指定搜寻过程的起点, 默认为1。 \n                                        在成功配对时, 函数将返回配对表达式中的所有捕获结果; 如果没有设置捕获标记, 则返回整个配对字符串. 当没有成功的配对时, 返回nil。\n         &gt; = string.match(&quot;I have 2 questions for you.&quot;, &quot;%d+ %a+&quot;)\n         2 questions\n         &gt; = string.format(&quot;%d, %q&quot;, string.match(&quot;I have 2 questions for you.&quot;, &quot;(%d+) (%a+)&quot;))\n         2, &quot;questions&quot;  \n3.字符串格式化         \n     Lua 提供了 string.format() 函数来生成具有特定格式的字符串, 函数的第一个参数是格式 , 之后是对应格式中每个代号的各种数据。\n        %c - 接受一个数字, 并将其转化为ASCII码表中对应的字符\n        %d, %i - 接受一个数字并将其转化为有符号的整数格式\n        %o - 接受一个数字并将其转化为八进制数格式\n        %u - 接受一个数字并将其转化为无符号整数格式\n        %x - 接受一个数字并将其转化为十六进制数格式, 使用小写字母\n        %X - 接受一个数字并将其转化为十六进制数格式, 使用大写字母\n        %e - 接受一个数字并将其转化为科学记数法格式, 使用小写字母e\n        %E - 接受一个数字并将其转化为科学记数法格式, 使用大写字母E\n        %f - 接受一个数字并将其转化为浮点数格式\n        %g(%G) - 接受一个数字并将其转化为%e(%E, 对应%G)及%f中较短的一种格式\n        %q - 接受一个字符串并将其转化为可安全被Lua编译器读入的格式\n        %s - 接受一个字符串并按照给定的参数格式化该字符串\n     为进一步细化格式, 可以在%号后添加参数. 参数将以如下的顺序读入:\n        (1) 符号: 一个+号表示其后的数字转义符将让正数显示正号. 默认情况下只有负数显示符号.\n        (2) 占位符: 一个0, 在后面指定了字串宽度时占位用. 不填时的默认占位符是空格.\n        (3) 对齐标识: 在指定了字串宽度时, 默认为右对齐, 增加-号可以改为左对齐.\n        (4) 宽度数值\n        (5) 小数位数/字串裁切: 在宽度数值后增加的小数部分n, 若后接f(浮点数转义符, 如%6.3f)则设定该浮点数的小数只保留n位, 若后接s(字符串转义符, 如%5.3s)则设定该字符串只显示前n位\n     例子:\n        string1 = &quot;Lua&quot;\n        string2 = &quot;Tutorial&quot;\n        number1 = 10\n        number2 = 20\n        -- 基本字符串格式化\n        print(string.format(&quot;基本格式化 %s %s&quot;,string1,string2))\n        -- 日期格式化\n        date = 2; month = 1; year = 2014\n        print(string.format(&quot;日期格式化 %02d/%02d/%03d&quot;, date, month, year))\n        -- 十进制格式化\n        print(string.format(&quot;%.4f&quot;,1/3))\n4. 字符与整数相互转换  \n     -- 字符转换\n     -- 转换第一个字符\n     print(string.byte(&quot;Lua&quot;))\n     -- 转换第三个字符\n     print(string.byte(&quot;Lua&quot;,3))\n     -- 转换末尾第一个字符\n     print(string.byte(&quot;Lua&quot;,-1))\n     -- 第二个字符\n     print(string.byte(&quot;Lua&quot;,2))\n     -- 转换末尾第二个字符\n     print(string.byte(&quot;Lua&quot;,-2))\n     -- 整数 ASCII 码转换为字符\n     print(string.char(97))   \n</code></pre>\n<h5>字符串–正则表达式</h5>\n<pre><code> Lua 中的匹配模式直接用常规的字符串来描述。 它用于模式匹配函数 string.find, string.gmatch, string.gsub, string.match。\n 你还可以在模式串中使用字符类。\n 字符类指可以匹配一个特定字符集合内任何字符的模式项。比如，字符类%d匹配任意数字。所以你可以使用模式串 '%d%d/%d%d/%d%d%d%d' 搜索 dd/mm/yyyy 格式的日期：\n 下面的表列出了Lua支持的所有字符类：\n 单个字符(除 ^$()%.[]*+-? 外): 与该字符自身配对\n .(点): 与任何字符配对\n %a: 与任何字母配对\n %c: 与任何控制符配对(例如\\n)\n %d: 与任何数字配对\n %l: 与任何小写字母配对\n %p: 与任何标点(punctuation)配对\n %s: 与空白字符配对\n %u: 与任何大写字母配对\n %w: 与任何字母/数字配对\n %x: 与任何十六进制数配对\n %z: 与任何代表0的字符配对\n %x(此处x是非字母非数字字符): 与字符x配对. 主要用来处理表达式中有功能的字符(^$()%.[]*+-?)的配对问题, 例如%%与%配对\n [数个字符类]: 与任何[]中包含的字符类配对. 例如[%w_]与任何字母/数字, 或下划线符号(_)配对\n [^数个字符类]: 与任何不包含在[]中的字符类配对. 例如[^%s]与任何非空白字符配对        \n \n 当上述的字符类用大写书写时, 表示与非此字符类的任何字符配对. 例如, %S表示与任何非空白字符配对.例如，'%A'非字母的字符:\n &gt; print(string.gsub(&quot;hello, up-down!&quot;, &quot;%A&quot;, &quot;.&quot;))\n hello..up.down.    4\n 数字4不是字符串结果的一部分，他是gsub返回的第二个结果，代表发生替换的次数。\n 在模式匹配中有一些特殊字符，他们有特殊的意义，Lua中的特殊字符如下：\n ( ) . % + - * ? [ ^ $\n '%' 用作特殊字符的转义字符，因此 '%.' 匹配点；'%%' 匹配字符 '%'。转义字符 '%'不仅可以用来转义特殊字符，还可以用于所有的非字母的字符。\n  \n  模式条目可以是：\n      单个字符类匹配该类别中任意单个字符；\n      单个字符类跟一个 '*'， 将匹配零或多个该类的字符。 这个条目总是匹配尽可能长的串；\n      单个字符类跟一个 '+'， 将匹配一或更多个该类的字符。 这个条目总是匹配尽可能长的串；\n      单个字符类跟一个 '-'， 将匹配零或更多个该类的字符。 和 '*' 不同， 这个条目总是匹配尽可能短的串；\n      单个字符类跟一个 '?'， 将匹配零或一个该类的字符。 只要有可能，它会匹配一个；\n      %n， 这里的 n 可以从 1 到 9； 这个条目匹配一个等于 n 号捕获物（后面有描述）的子串。\n      %bxy， 这里的 x 和 y 是两个明确的字符； 这个条目匹配以 x 开始 y 结束， 且其中 x 和 y 保持 平衡 的字符串。 意思是，如果从左到右读这个字符串，对每次读到一个 x 就 +1 ，读到一个 y 就 -1， 最终结束处的那个 y 是第一个记数到 0 的 y。 举个例子，条目 %b() 可以匹配到括号平衡的表达式。\n      %f[set]， 指 边境模式； 这个条目会匹配到一个位于 set 内某个字符之前的一个空串， 且这个位置的前一个字符不属于 set 。 集合 set 的含义如前面所述。 匹配出的那个空串之开始和结束点的计算就看成该处有个字符 '\\0' 一样。\n  模式：\n    模式 指一个模式条目的序列。 在模式最前面加上符号 '^' 将锚定从字符串的开始处做匹配。 在模式最后面加上符号 '$' 将使匹配过程锚定到字符串的结尾。 如果 '^' 和 '$' 出现在其它位置，它们均没有特殊含义，只表示自身。\n  捕获：\n    模式可以在内部用小括号括起一个子模式； 这些子模式被称为 捕获物。 当匹配成功时，由 捕获物 匹配到的字符串中的子串被保存起来用于未来的用途。 捕获物以它们左括号的次序来编号。 例如，对于模式 &quot;(a*(.)%w(%s*))&quot; ， 字符串中匹配到 &quot;a*(.)%w(%s*)&quot; 的部分保存在第一个捕获物中 （因此是编号 1 ）； 由 &quot;.&quot; 匹配到的字符是 2 号捕获物， 匹配到 &quot;%s*&quot; 的那部分是 3 号。\n  作为一个特例，空的捕获 () 将捕获到当前字符串的位置（它是一个数字）。 例如，如果将模式 &quot;()aa()&quot; 作用到字符串 &quot;flaaap&quot; 上，将产生两个捕获物： 3 和 5 。\n</code></pre>\n<h4>table(表)</h4>\n<pre><code>在 Lua 里，table 的创获取数据的类型建是通过&quot;构造表达式&quot;来完成，最简单构造表达式是{}，用来创建一个空表\n也可以在表里添加一些数据，直接初始化表:\n1. 初始化表与移除引用\n    -- 创建一个空的 table\n    local tbl1 = {}         \n    -- 直接初始表\n    local tbl2 = {&quot;apple&quot;, &quot;pear&quot;, &quot;orange&quot;, &quot;grape&quot;}\n    -- 初始化表\n    mytable = {} \n    -- 指定值\n    mytable[1]= &quot;Lua&quot;\n    -- 移除引用\n    mytable = nil\n    -- lua 垃圾回收会释放内存\n\n2. -- 创建一个空的 table\n   local tbl1 = {}\n   -- 直接初始表\n   local tbl2 = {&quot;apple&quot;, &quot;pear&quot;, &quot;orange&quot;, &quot;grape&quot;}\n\n3. Lua 中的表（table）其实是一个&quot;关联数组&quot;（associative arrays），数组的索引可以是数字或者是字符串\n  table 不会固定长度大小，有新数据添加时 table 长度会自动增长，没初始的 table 都是 nil。\n  重点: 不同于其他语言的数组把 0 作为数组的初始索引，在 Lua 里表的默认初始索引一般以 1 开始  \n        local tbl = {&quot;apple&quot;, &quot;pear&quot;, &quot;orange&quot;, &quot;grape&quot;}\n        for key, val in pairs(tbl) do\n           print(&quot;Key&quot;, key)\n        end\n4. 索引,对 table 的索引使用方括号 []。Lua 也提供了&quot;.&quot;操作\n    &gt; site = {}\n    &gt; site[&quot;key&quot;] = &quot;www.w3cschool.cc&quot;\n    &gt; print(site[&quot;key&quot;])\n    www.w3cschool.cc\n    &gt; print(site.key)\n    www.w3cschool.cc\n</code></pre>\n<h5>table – 操作</h5>\n<pre><code>1.table.concat (table [, sep [, start [, end]]]):concat是concatenate(连锁, 连接)的缩写. table.concat()函数列出参数中指定table的数组部分从start位置到end位置的所有元素, 元素间以指定的分隔符(sep)隔开。\n2.table.insert (table, [pos,] value):在table的数组部分指定位置(pos)插入值为value的一个元素. pos参数可选, 默认为数组部分末尾.\n3.table.remove (table [, pos]):返回table数组部分位于pos位置的元素. 其后的元素会被前移. pos参数可选, 默认为table长度, 即从最后一个元素删起。\n4.table.sort (table [, comp]):对给定的table进行升序排序\n</code></pre>\n<h5>table – table间连接,table中的插入,移除,排序</h5>\n<pre><code>使用 concat() 方法来连接两个 table\n    fruits = {&quot;banana&quot;,&quot;orange&quot;,&quot;apple&quot;}\n    -- 返回 table 连接后的字符串\n    print(&quot;连接后的字符串 &quot;,table.concat(fruits)\n    -- 指定连接字符\n    print(&quot;连接后的字符串 &quot;,table.concat(fruits,&quot;, &quot;))\n    -- 指定索引来连接 table\n    print(&quot;连接后的字符串 &quot;,table.concat(fruits,&quot;, &quot;, 2,3))\n    \n    fruits = {&quot;banana&quot;,&quot;orange&quot;,&quot;apple&quot;}\n    -- 在末尾插入\n    table.insert(fruits,&quot;mango&quot;)\n    print(&quot;索引为 4 的元素为 &quot;,fruits[4])\n    \n    -- 在索引为 2 的键处插入\n    table.insert(fruits,2,&quot;grapes&quot;)\n    print(&quot;索引为 2 的元素为 &quot;,fruits[2])\n    \n    print(&quot;最后一个元素为 &quot;,fruits[5])\n    table.remove(fruits)\n    print(&quot;移除后最后一个元素为 &quot;,fruits[5])    \n    \n    --排序\n    fruits = {&quot;banana&quot;,&quot;orange&quot;,&quot;apple&quot;,&quot;grapes&quot;}\n    print(&quot;排序前&quot;)\n    for k,v in ipairs(fruits) do\n        print(k,v)\n    end\n    \n    table.sort(fruits)\n    print(&quot;排序后&quot;)\n    for k,v in ipairs(fruits) do\n        print(k,v)\n    end\n</code></pre>\n<h5>table – 数组</h5>\n<pre><code>1. 一维数组\n    array = {&quot;Lua&quot;, &quot;Tutorial&quot;}\n    \n    for i= 0, 2 do\n       print(array[i])\n    end\n2. 多维数组\n     -- 初始化数组\n     array = {}\n     for i=1,3 do\n        array[i] = {}\n           for j=1,3 do\n              array[i][j] = i*j\n           end\n     end\n     \n     -- 访问数组\n     for i=1,3 do\n        for j=1,3 do\n           print(array[i][j])\n        end\n     end   \n</code></pre>\n<h4>function（函数）</h4>\n<pre><code>1.在 Lua 中，函数是被看作是&quot;一类公民（First-Class Value）&quot;\n    function factorial1(n)\n        if n == 0 then\n            return 1\n        else\n            return n * factorial1(n - 1)\n        end\n    end\n    print(factorial1(5))\n    factorial2 = factorial1\n    print(factorial2(5))\n \n2.function 可以以匿名函数（anonymous function）的方式通过参数传递\n    -- function_test2.lua 脚本文件\n    function testFun(tab,fun)\n        for k ,v in pairs(tab) do\n            print(fun(k,v));\n        end\n    end\n    \n    \n    tab={key1=&quot;val1&quot;,key2=&quot;val2&quot;};\n    testFun(tab,\n    function(key,val)--匿名函数\n        return key..&quot;=&quot;..val;\n    end\n    );  \n3. 多返回值\n    Lua函数中，在return后列出要返回的值的列表即可返回多值\n        function maximum (a)\n            local mi = 1             -- 最大值索引\n            local m = a[mi]          -- 最大值\n            for i,val in ipairs(a) do\n               if val &gt; m then\n                   mi = i\n                   m = val\n               end\n            end\n            return m, mi\n        end\n        \n        print(maximum({8,10,23,12,5}))     \n</code></pre>\n<h5>函数定义</h5>\n<pre><code>optional_function_scope function function_name( argument1, argument2, argument3..., argumentn)\n    function_body\n    return result_params_comma_separated\nend\n\noptional_function_scope: 该参数是可选的制定函数是全局函数还是局部函数，未设置该参数默认为全局函数，如果你需要设置函数为局部函数需要使用关键字 local。\nfunction_name: 指定函数名称。\nargument1, argument2, argument3..., argumentn: 函数参数，多个参数以逗号隔开，函数也可以不带参数。\nfunction_body: 函数体，函数中需要执行的代码语句块。\nresult_params_comma_separated: 函数返回值，Lua语言函数可以返回多个值，每个值以逗号隔开。\n</code></pre>\n<h5>函数的可变参数</h5>\n<pre><code>   1. 在函数参数列表中使用三点 ... 表示函数有可变的参数\n        function add(...)  \n        local s = 0  \n          for i, v in ipairs{...} do   --&gt; {...} 表示一个由所有变长参数构成的数组  \n            s = s + v  \n          end  \n          return s  \n        end  \n        print(add(3,4,5,6,7))  ---&gt;25\n   2. select(&quot;#&quot;,...) 来获取可变参数的数量\n            function average(...)\n               result = 0\n               local arg={...}\n               for i,v in ipairs(arg) do\n                  result = result + v\n               end\n               print(&quot;总共传入 &quot; .. select(&quot;#&quot;,...) .. &quot; 个数&quot;)\n               return result/select(&quot;#&quot;,...)\n            end\n            \n            print(&quot;平均值为&quot;,average(10,5,3,4,5,6))\n        \n        在遍历变长参数的时候只需要使用 {…}，然而变长参数可能会包含一些 nil，那么就可以用 select 函数来访问变长参数了：select('#', …) 或者 select(n, …)\n        select('#', …) 返回可变参数的长度\n        select(n, …) 用于访问 n 到 select('#',…) 的参数\n        调用select时，必须传入一个固定实参selector(选择开关)和一系列变长参数。如果selector为数字n,那么select返回它的第n个可变实参，否则只能为字符串&quot;#&quot;,这样select会返回变长参数的总数\n            do  \n                function foo(...)  \n                    for i = 1, select('#', ...) do  --&gt;获取参数总数\n                        local arg = select(i, ...); --&gt;读取参数\n                        print(&quot;arg&quot;, arg);  \n                    end  \n                end  \n              \n                foo(1, 2, 3, 4);  \n            end\n</code></pre>\n<h4>thread(线程)</h4>\n<pre><code>在 Lua 里，最主要的线程是协同程序（coroutine）。\n协程跟线程（thread）差不多，拥有自己独立的栈、局部变量和指令指针，可以跟其他协同程序共享全局变量和其他大部分东西。\n线程跟协程的区别：线程可以同时多个运行，而协程任意时刻只能运行一个，并且处于运行状态的协程只有被挂起（suspend）时才会暂停。\n</code></pre>\n<h4>userdata(自定义类型)</h4>\n<pre><code>userdata 是一种用户自定义数据，用于表示一种由应用程序或 C/C++ 语言库所创建的类型，可以将任意 C/C++ 的任意数据类型的数据（通常是 struct 和 指针）存储到 Lua 变量中调用。\n</code></pre>\n"},{"title":"Lua脚本教程(3) -- 模块与包,元表(Metatable)，协程，文件I/O，错误处理,面向对象与数据库访问","catalog":true,"date":"2018-12-17T03:50:45.000Z","subtitle":null,"header-img":"Demo.png","_content":"\n## 模块与包\n    Lua 加入了标准的模块管理机制，可以把一些公用的代码放在一个文件里，以 API 接口的形式在其他地方调用，有利于代码的重用和降低代码耦合度。\n    Lua 的模块是由变量、函数等已知元素组成的 table，因此创建一个模块很简单，就是创建一个 table，然后把需要导出的常量、函数放入其中，最后返回这个 table 就行。\n    demo:\n       -- 文件名为 module.lua\n       -- 定义一个名为 module 的模块\n       module = {}\n        \n       -- 定义一个常量\n       module.constant = \"这是一个常量\"\n        \n       -- 定义一个函数\n       function module.func1()\n           io.write(\"这是一个公有函数！\\n\")\n       end\n        \n       local function func2()\n           print(\"这是一个私有函数！\")\n       end\n        \n       function module.func3()\n           func2()\n       end\n        \n       return module\n    \n    模块引用\n        require 函数\n        Lua提供了一个名为require的函数用来加载模块。要加载一个模块，只需要简单地调用就可以了。\n        \n        require(\"<模块名>\")\n        或者\n        require \"<模块名>\"\n        \n        -- test_module.lua 文件\n        -- module 模块为上文提到到 module.lua\n        require(\"module\")\n         \n        print(module.constant)\n         \n        module.func3()\n        \n    加载机制\n        加载模块路径\n        对于自定义的模块，模块文件不是放在哪个文件目录都行，函数 require 有它自己的文件路径加载策略，它会尝试从 Lua 文件或 C 程序库中加载模块。\n        require 用于搜索 Lua 文件的路径是存放在全局变量 package.path 中，当 Lua 启动后，会以环境变量 LUA_PATH 的值来初始这个环境变量。如果没有找到该环境变量，则使用一个编译时定义的默认路径来初始化。\n        当然，如果没有 LUA_PATH 这个环境变量，也可以自定义设置，在当前用户根目录下打开 .profile 文件（没有则创建，打开 .bashrc 文件也可以），例如把 \"~/lua/\" 路径加入 LUA_PATH 环境变量里：\n            #LUA_PATH\n            export LUA_PATH=\"~/lua/?.lua;;\"   \n        文件路径以 \";\" 号分隔，最后的 2 个 \";;\" 表示新加的路径后面加上原来的默认路径。\n\n    C语言包（非重点）-- 参考：http://www.runoob.com/lua/lua-modules-packages.html\n       Lua和C是很容易结合的，使用C为Lua写包。 \n       与Lua中写包不同，C包在使用以前必须首先加载并连接，在大多数系统中最容易的实现方式是通过动态连接库机制。\n       Lua在一个叫loadlib的函数内提供了所有的动态连接的功能。这个函数有两个参数:库的绝对路径和初始化函数。\n    \n## 元表(Metatable)\n    http://www.runoob.com/lua/lua-metatables.html\n    \n\n## 协程\n    http://www.runoob.com/lua/lua-coroutine.html\n\n## 文件I/O\n    http://www.runoob.com/lua/lua-file-io.html\n\n## 错误处理\n    错误种类\n        1. 语法错误\n            语法错误通常是由于对程序的组件（如运算符、表达式）使用不当引起的\n        2. 运行错误\n            运行错误是程序可以正常执行，但是会输出报错信息\n\n    错误处理\n       使用两个函数：assert 和 error 来处理错误\n       assert函数:\n           local function add(a,b)\n              assert(type(a) == \"number\", \"a 不是一个数字\")\n              assert(type(b) == \"number\", \"b 不是一个数字\")\n              return a+b\n           end\n           add(10)\n           \n           执行以上程序会出现如下错误：\n           lua: test.lua:3: b 不是一个数字\n           stack traceback:\n               [C]: in function 'assert'\n               test.lua:3: in local 'add'\n               test.lua:6: in main chunk\n               [C]: in ?         \n        \n       现象:实例中assert首先检查第一个参数，若没问题，assert不做任何事情；否则，assert以第二个参数作为错误信息抛出     \n\n       error函数:\n         格式: error (message [, level])\n            功能：终止正在执行的函数，并返回message的内容作为错误信息(error函数永远都不会返回)\n            通常情况下，error会附加一些错误位置的信息到message头部。\n            Level参数指示获得错误的位置:\n            Level=1[默认]：为调用error位置(文件+行号)\n            Level=2：指出哪个调用error的函数的函数\n            Level=0:不添加错误位置信息      \n\n    pcall 和 xpcall、debug(非重点内容)\n      Lua中处理错误，可以使用函数pcall（protected call）来包装需要执行的代码。\n      pcall接收一个函数和要传递给后者的参数，并执行，执行结果：有错误、无错误；返回值true或者或false, errorinfo\n          if pcall(function_name,...) then\n          -- 没有错误\n          else\n          -- 一些错误\n          end\n        简单例子:\n            > =pcall(function(i) print(i) end, 33)\n            33\n            true\n            > =pcall(function(i) print(i) error('error..') end, 33)\n            33\n            false        stdin:1: error..        \n        \n        pcall以一种\"保护模式\"来调用第一个参数，因此pcall可以捕获函数执行中的任何错误。\n        通常在错误发生时，希望落得更多的调试信息，而不只是发生错误的位置。但pcall返回时，它已经销毁了调用桟的部分内容。\n        Lua提供了xpcall函数，xpcall接收第二个参数——一个错误处理函数，当错误发生时，Lua会在调用桟展开（unwind）前调用错误处理函数，于是就可以在这个函数中使用debug库来获取关于错误的额外信息了。\n        debug库提供了两个通用的错误处理函数，返回的调试内容会多一点:\n        debug.debug：提供一个Lua提示符，让用户来检查错误的原因\n        debug.traceback：根据调用桟来构建一个扩展的错误消息\n\n## 面向对象\n    面向对象的特征: 封装 继承 多态（lua没有多态）\n    \n    封装\n        Lua中的表不仅在某种意义上是一种对象。像对象一样，表也有状态（成员变量）；也有与对象的值独立的本性，特别是拥有两个不同值的对象（table）代表两个不同的对象；一个对象在不同的时候也可以有不同的值，但他始终是一个对象；与对象类似，表的生命周期与其由什么创建、在哪创建没有关系。对象有他们的成员函数，表也有：\n           Account = {balance = 0}\n           function Account.withdraw (v)\n               Account.balance = Account.balance - v\n           end \n           \n        简单完整实例\n           -- Meta class\n           Shape = {area = 0}\n           \n           -- 基础类方法 new -- 创建对象\n           function Shape:new (o,side)\n             o = o or {}\n             setmetatable(o, self)\n             self.__index = self\n             side = side or 0\n             self.area = side*side;\n             return o\n           end\n           \n           -- 基础类方法 printArea\n           function Shape:printArea ()\n             print(\"面积为 \",self.area) -- 访问属性\n           end\n           \n           -- 创建对象\n           myshape = Shape:new(nil,10)\n           \n           myshape:printArea()   -- 访问成员函数\n    \n    继承\n        继承是指一个对象直接使用另一对象的属性和方法\n             -- Meta class\n            Shape = {area = 0}\n            -- 基础类方法 new\n            function Shape:new (o,side)\n              o = o or {}\n              setmetatable(o, self)\n              self.__index = self\n              side = side or 0\n              self.area = side*side;\n              return o\n            end\n            -- 基础类方法 printArea\n            function Shape:printArea ()\n              print(\"面积为 \",self.area)\n            end\n            \n            -- 创建对象\n            myshape = Shape:new(nil,10)\n            myshape:printArea()\n            \n            Square = Shape:new()\n            -- 派生类方法 new\n            function Square:new (o,side)\n              o = o or Shape:new(o,side)\n              setmetatable(o, self)\n              self.__index = self\n              return o\n            end\n            \n            -- 派生类方法 printArea\n            function Square:printArea ()\n              print(\"正方形面积为 \",self.area)\n            end\n            \n            -- 创建对象\n            mysquare = Square:new(nil,10)\n            mysquare:printArea()\n            \n            Rectangle = Shape:new()\n            -- 派生类方法 new\n            function Rectangle:new (o,length,breadth)\n              o = o or Shape:new(o)\n              setmetatable(o, self)\n              self.__index = self\n              self.area = length * breadth\n              return o\n            end\n            \n            -- 派生类方法 printArea\n            function Rectangle:printArea ()\n              print(\"矩形面积为 \",self.area)\n            end\n            \n            -- 创建对象\n            myrectangle = Rectangle:new(nil,10,20)\n            myrectangle:printArea()\n            \n    重写\n        -- 派生类方法 printArea\n        function Square:printArea ()\n          print(\"正方形面积 \",self.area)\n        end        \n\n## 数据库访问\n    Lua 连接MySql 数据库\n    \n    require \"luasql.mysql\"\n    \n    --创建环境对象\n    env = luasql.mysql()\n    \n    --连接数据库\n    conn = env:connect(\"数据库名\",\"用户名\",\"密码\",\"IP地址\",端口)\n    \n    --设置数据库的编码格式\n    conn:execute\"SET NAMES UTF8\"\n    \n    --执行数据库操作\n    cur = conn:execute(\"select * from role\")\n    \n    row = cur:fetch({},\"a\")\n    \n    --文件对象的创建\n    file = io.open(\"role.txt\",\"w+\");\n    \n    while row do\n        var = string.format(\"%d %s\\n\", row.id, row.name)\n    \n        print(var)\n    \n        file:write(var)\n    \n        row = cur:fetch(row,\"a\")\n    end\n    \n    \n    file:close()  --关闭文件对象\n    conn:close()  --关闭数据库连接\n    env:close()   --关闭数据库环境    \n","source":"_posts/Lua脚本教程-3.md","raw":"---\ntitle: Lua脚本教程(3) -- 模块与包,元表(Metatable)，协程，文件I/O，错误处理,面向对象与数据库访问\ncatalog: true\ndate: 2018-12-17 11:50:45\nsubtitle:\nheader-img: \"Demo.png\"\ntags:\n---\n\n## 模块与包\n    Lua 加入了标准的模块管理机制，可以把一些公用的代码放在一个文件里，以 API 接口的形式在其他地方调用，有利于代码的重用和降低代码耦合度。\n    Lua 的模块是由变量、函数等已知元素组成的 table，因此创建一个模块很简单，就是创建一个 table，然后把需要导出的常量、函数放入其中，最后返回这个 table 就行。\n    demo:\n       -- 文件名为 module.lua\n       -- 定义一个名为 module 的模块\n       module = {}\n        \n       -- 定义一个常量\n       module.constant = \"这是一个常量\"\n        \n       -- 定义一个函数\n       function module.func1()\n           io.write(\"这是一个公有函数！\\n\")\n       end\n        \n       local function func2()\n           print(\"这是一个私有函数！\")\n       end\n        \n       function module.func3()\n           func2()\n       end\n        \n       return module\n    \n    模块引用\n        require 函数\n        Lua提供了一个名为require的函数用来加载模块。要加载一个模块，只需要简单地调用就可以了。\n        \n        require(\"<模块名>\")\n        或者\n        require \"<模块名>\"\n        \n        -- test_module.lua 文件\n        -- module 模块为上文提到到 module.lua\n        require(\"module\")\n         \n        print(module.constant)\n         \n        module.func3()\n        \n    加载机制\n        加载模块路径\n        对于自定义的模块，模块文件不是放在哪个文件目录都行，函数 require 有它自己的文件路径加载策略，它会尝试从 Lua 文件或 C 程序库中加载模块。\n        require 用于搜索 Lua 文件的路径是存放在全局变量 package.path 中，当 Lua 启动后，会以环境变量 LUA_PATH 的值来初始这个环境变量。如果没有找到该环境变量，则使用一个编译时定义的默认路径来初始化。\n        当然，如果没有 LUA_PATH 这个环境变量，也可以自定义设置，在当前用户根目录下打开 .profile 文件（没有则创建，打开 .bashrc 文件也可以），例如把 \"~/lua/\" 路径加入 LUA_PATH 环境变量里：\n            #LUA_PATH\n            export LUA_PATH=\"~/lua/?.lua;;\"   \n        文件路径以 \";\" 号分隔，最后的 2 个 \";;\" 表示新加的路径后面加上原来的默认路径。\n\n    C语言包（非重点）-- 参考：http://www.runoob.com/lua/lua-modules-packages.html\n       Lua和C是很容易结合的，使用C为Lua写包。 \n       与Lua中写包不同，C包在使用以前必须首先加载并连接，在大多数系统中最容易的实现方式是通过动态连接库机制。\n       Lua在一个叫loadlib的函数内提供了所有的动态连接的功能。这个函数有两个参数:库的绝对路径和初始化函数。\n    \n## 元表(Metatable)\n    http://www.runoob.com/lua/lua-metatables.html\n    \n\n## 协程\n    http://www.runoob.com/lua/lua-coroutine.html\n\n## 文件I/O\n    http://www.runoob.com/lua/lua-file-io.html\n\n## 错误处理\n    错误种类\n        1. 语法错误\n            语法错误通常是由于对程序的组件（如运算符、表达式）使用不当引起的\n        2. 运行错误\n            运行错误是程序可以正常执行，但是会输出报错信息\n\n    错误处理\n       使用两个函数：assert 和 error 来处理错误\n       assert函数:\n           local function add(a,b)\n              assert(type(a) == \"number\", \"a 不是一个数字\")\n              assert(type(b) == \"number\", \"b 不是一个数字\")\n              return a+b\n           end\n           add(10)\n           \n           执行以上程序会出现如下错误：\n           lua: test.lua:3: b 不是一个数字\n           stack traceback:\n               [C]: in function 'assert'\n               test.lua:3: in local 'add'\n               test.lua:6: in main chunk\n               [C]: in ?         \n        \n       现象:实例中assert首先检查第一个参数，若没问题，assert不做任何事情；否则，assert以第二个参数作为错误信息抛出     \n\n       error函数:\n         格式: error (message [, level])\n            功能：终止正在执行的函数，并返回message的内容作为错误信息(error函数永远都不会返回)\n            通常情况下，error会附加一些错误位置的信息到message头部。\n            Level参数指示获得错误的位置:\n            Level=1[默认]：为调用error位置(文件+行号)\n            Level=2：指出哪个调用error的函数的函数\n            Level=0:不添加错误位置信息      \n\n    pcall 和 xpcall、debug(非重点内容)\n      Lua中处理错误，可以使用函数pcall（protected call）来包装需要执行的代码。\n      pcall接收一个函数和要传递给后者的参数，并执行，执行结果：有错误、无错误；返回值true或者或false, errorinfo\n          if pcall(function_name,...) then\n          -- 没有错误\n          else\n          -- 一些错误\n          end\n        简单例子:\n            > =pcall(function(i) print(i) end, 33)\n            33\n            true\n            > =pcall(function(i) print(i) error('error..') end, 33)\n            33\n            false        stdin:1: error..        \n        \n        pcall以一种\"保护模式\"来调用第一个参数，因此pcall可以捕获函数执行中的任何错误。\n        通常在错误发生时，希望落得更多的调试信息，而不只是发生错误的位置。但pcall返回时，它已经销毁了调用桟的部分内容。\n        Lua提供了xpcall函数，xpcall接收第二个参数——一个错误处理函数，当错误发生时，Lua会在调用桟展开（unwind）前调用错误处理函数，于是就可以在这个函数中使用debug库来获取关于错误的额外信息了。\n        debug库提供了两个通用的错误处理函数，返回的调试内容会多一点:\n        debug.debug：提供一个Lua提示符，让用户来检查错误的原因\n        debug.traceback：根据调用桟来构建一个扩展的错误消息\n\n## 面向对象\n    面向对象的特征: 封装 继承 多态（lua没有多态）\n    \n    封装\n        Lua中的表不仅在某种意义上是一种对象。像对象一样，表也有状态（成员变量）；也有与对象的值独立的本性，特别是拥有两个不同值的对象（table）代表两个不同的对象；一个对象在不同的时候也可以有不同的值，但他始终是一个对象；与对象类似，表的生命周期与其由什么创建、在哪创建没有关系。对象有他们的成员函数，表也有：\n           Account = {balance = 0}\n           function Account.withdraw (v)\n               Account.balance = Account.balance - v\n           end \n           \n        简单完整实例\n           -- Meta class\n           Shape = {area = 0}\n           \n           -- 基础类方法 new -- 创建对象\n           function Shape:new (o,side)\n             o = o or {}\n             setmetatable(o, self)\n             self.__index = self\n             side = side or 0\n             self.area = side*side;\n             return o\n           end\n           \n           -- 基础类方法 printArea\n           function Shape:printArea ()\n             print(\"面积为 \",self.area) -- 访问属性\n           end\n           \n           -- 创建对象\n           myshape = Shape:new(nil,10)\n           \n           myshape:printArea()   -- 访问成员函数\n    \n    继承\n        继承是指一个对象直接使用另一对象的属性和方法\n             -- Meta class\n            Shape = {area = 0}\n            -- 基础类方法 new\n            function Shape:new (o,side)\n              o = o or {}\n              setmetatable(o, self)\n              self.__index = self\n              side = side or 0\n              self.area = side*side;\n              return o\n            end\n            -- 基础类方法 printArea\n            function Shape:printArea ()\n              print(\"面积为 \",self.area)\n            end\n            \n            -- 创建对象\n            myshape = Shape:new(nil,10)\n            myshape:printArea()\n            \n            Square = Shape:new()\n            -- 派生类方法 new\n            function Square:new (o,side)\n              o = o or Shape:new(o,side)\n              setmetatable(o, self)\n              self.__index = self\n              return o\n            end\n            \n            -- 派生类方法 printArea\n            function Square:printArea ()\n              print(\"正方形面积为 \",self.area)\n            end\n            \n            -- 创建对象\n            mysquare = Square:new(nil,10)\n            mysquare:printArea()\n            \n            Rectangle = Shape:new()\n            -- 派生类方法 new\n            function Rectangle:new (o,length,breadth)\n              o = o or Shape:new(o)\n              setmetatable(o, self)\n              self.__index = self\n              self.area = length * breadth\n              return o\n            end\n            \n            -- 派生类方法 printArea\n            function Rectangle:printArea ()\n              print(\"矩形面积为 \",self.area)\n            end\n            \n            -- 创建对象\n            myrectangle = Rectangle:new(nil,10,20)\n            myrectangle:printArea()\n            \n    重写\n        -- 派生类方法 printArea\n        function Square:printArea ()\n          print(\"正方形面积 \",self.area)\n        end        \n\n## 数据库访问\n    Lua 连接MySql 数据库\n    \n    require \"luasql.mysql\"\n    \n    --创建环境对象\n    env = luasql.mysql()\n    \n    --连接数据库\n    conn = env:connect(\"数据库名\",\"用户名\",\"密码\",\"IP地址\",端口)\n    \n    --设置数据库的编码格式\n    conn:execute\"SET NAMES UTF8\"\n    \n    --执行数据库操作\n    cur = conn:execute(\"select * from role\")\n    \n    row = cur:fetch({},\"a\")\n    \n    --文件对象的创建\n    file = io.open(\"role.txt\",\"w+\");\n    \n    while row do\n        var = string.format(\"%d %s\\n\", row.id, row.name)\n    \n        print(var)\n    \n        file:write(var)\n    \n        row = cur:fetch(row,\"a\")\n    end\n    \n    \n    file:close()  --关闭文件对象\n    conn:close()  --关闭数据库连接\n    env:close()   --关闭数据库环境    \n","slug":"Lua脚本教程-3","published":1,"updated":"2018-12-17T06:08:45.107Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpuya67u00049kuj1ssfmc7f","content":"<h2><span id=\"模块与包\">模块与包</span></h2>\n<pre><code>Lua 加入了标准的模块管理机制，可以把一些公用的代码放在一个文件里，以 API 接口的形式在其他地方调用，有利于代码的重用和降低代码耦合度。\nLua 的模块是由变量、函数等已知元素组成的 table，因此创建一个模块很简单，就是创建一个 table，然后把需要导出的常量、函数放入其中，最后返回这个 table 就行。\ndemo:\n   -- 文件名为 module.lua\n   -- 定义一个名为 module 的模块\n   module = {}\n    \n   -- 定义一个常量\n   module.constant = &quot;这是一个常量&quot;\n    \n   -- 定义一个函数\n   function module.func1()\n       io.write(&quot;这是一个公有函数！\\n&quot;)\n   end\n    \n   local function func2()\n       print(&quot;这是一个私有函数！&quot;)\n   end\n    \n   function module.func3()\n       func2()\n   end\n    \n   return module\n\n模块引用\n    require 函数\n    Lua提供了一个名为require的函数用来加载模块。要加载一个模块，只需要简单地调用就可以了。\n    \n    require(&quot;&lt;模块名&gt;&quot;)\n    或者\n    require &quot;&lt;模块名&gt;&quot;\n    \n    -- test_module.lua 文件\n    -- module 模块为上文提到到 module.lua\n    require(&quot;module&quot;)\n     \n    print(module.constant)\n     \n    module.func3()\n    \n加载机制\n    加载模块路径\n    对于自定义的模块，模块文件不是放在哪个文件目录都行，函数 require 有它自己的文件路径加载策略，它会尝试从 Lua 文件或 C 程序库中加载模块。\n    require 用于搜索 Lua 文件的路径是存放在全局变量 package.path 中，当 Lua 启动后，会以环境变量 LUA_PATH 的值来初始这个环境变量。如果没有找到该环境变量，则使用一个编译时定义的默认路径来初始化。\n    当然，如果没有 LUA_PATH 这个环境变量，也可以自定义设置，在当前用户根目录下打开 .profile 文件（没有则创建，打开 .bashrc 文件也可以），例如把 &quot;~/lua/&quot; 路径加入 LUA_PATH 环境变量里：\n        #LUA_PATH\n        export LUA_PATH=&quot;~/lua/?.lua;;&quot;   \n    文件路径以 &quot;;&quot; 号分隔，最后的 2 个 &quot;;;&quot; 表示新加的路径后面加上原来的默认路径。\n\nC语言包（非重点）-- 参考：http://www.runoob.com/lua/lua-modules-packages.html\n   Lua和C是很容易结合的，使用C为Lua写包。 \n   与Lua中写包不同，C包在使用以前必须首先加载并连接，在大多数系统中最容易的实现方式是通过动态连接库机制。\n   Lua在一个叫loadlib的函数内提供了所有的动态连接的功能。这个函数有两个参数:库的绝对路径和初始化函数。\n</code></pre>\n<h2><span id=\"元表metatable\">元表(Metatable)</span></h2>\n<pre><code>http://www.runoob.com/lua/lua-metatables.html\n</code></pre>\n<h2><span id=\"协程\">协程</span></h2>\n<pre><code>http://www.runoob.com/lua/lua-coroutine.html\n</code></pre>\n<h2><span id=\"文件io\">文件I/O</span></h2>\n<pre><code>http://www.runoob.com/lua/lua-file-io.html\n</code></pre>\n<h2><span id=\"错误处理\">错误处理</span></h2>\n<pre><code>错误种类\n    1. 语法错误\n        语法错误通常是由于对程序的组件（如运算符、表达式）使用不当引起的\n    2. 运行错误\n        运行错误是程序可以正常执行，但是会输出报错信息\n\n错误处理\n   使用两个函数：assert 和 error 来处理错误\n   assert函数:\n       local function add(a,b)\n          assert(type(a) == &quot;number&quot;, &quot;a 不是一个数字&quot;)\n          assert(type(b) == &quot;number&quot;, &quot;b 不是一个数字&quot;)\n          return a+b\n       end\n       add(10)\n       \n       执行以上程序会出现如下错误：\n       lua: test.lua:3: b 不是一个数字\n       stack traceback:\n           [C]: in function 'assert'\n           test.lua:3: in local 'add'\n           test.lua:6: in main chunk\n           [C]: in ?         \n    \n   现象:实例中assert首先检查第一个参数，若没问题，assert不做任何事情；否则，assert以第二个参数作为错误信息抛出     \n\n   error函数:\n     格式: error (message [, level])\n        功能：终止正在执行的函数，并返回message的内容作为错误信息(error函数永远都不会返回)\n        通常情况下，error会附加一些错误位置的信息到message头部。\n        Level参数指示获得错误的位置:\n        Level=1[默认]：为调用error位置(文件+行号)\n        Level=2：指出哪个调用error的函数的函数\n        Level=0:不添加错误位置信息      \n\npcall 和 xpcall、debug(非重点内容)\n  Lua中处理错误，可以使用函数pcall（protected call）来包装需要执行的代码。\n  pcall接收一个函数和要传递给后者的参数，并执行，执行结果：有错误、无错误；返回值true或者或false, errorinfo\n      if pcall(function_name,...) then\n      -- 没有错误\n      else\n      -- 一些错误\n      end\n    简单例子:\n        &gt; =pcall(function(i) print(i) end, 33)\n        33\n        true\n        &gt; =pcall(function(i) print(i) error('error..') end, 33)\n        33\n        false        stdin:1: error..        \n    \n    pcall以一种&quot;保护模式&quot;来调用第一个参数，因此pcall可以捕获函数执行中的任何错误。\n    通常在错误发生时，希望落得更多的调试信息，而不只是发生错误的位置。但pcall返回时，它已经销毁了调用桟的部分内容。\n    Lua提供了xpcall函数，xpcall接收第二个参数——一个错误处理函数，当错误发生时，Lua会在调用桟展开（unwind）前调用错误处理函数，于是就可以在这个函数中使用debug库来获取关于错误的额外信息了。\n    debug库提供了两个通用的错误处理函数，返回的调试内容会多一点:\n    debug.debug：提供一个Lua提示符，让用户来检查错误的原因\n    debug.traceback：根据调用桟来构建一个扩展的错误消息\n</code></pre>\n<h2><span id=\"面向对象\">面向对象</span></h2>\n<pre><code>面向对象的特征: 封装 继承 多态（lua没有多态）\n\n封装\n    Lua中的表不仅在某种意义上是一种对象。像对象一样，表也有状态（成员变量）；也有与对象的值独立的本性，特别是拥有两个不同值的对象（table）代表两个不同的对象；一个对象在不同的时候也可以有不同的值，但他始终是一个对象；与对象类似，表的生命周期与其由什么创建、在哪创建没有关系。对象有他们的成员函数，表也有：\n       Account = {balance = 0}\n       function Account.withdraw (v)\n           Account.balance = Account.balance - v\n       end \n       \n    简单完整实例\n       -- Meta class\n       Shape = {area = 0}\n       \n       -- 基础类方法 new -- 创建对象\n       function Shape:new (o,side)\n         o = o or {}\n         setmetatable(o, self)\n         self.__index = self\n         side = side or 0\n         self.area = side*side;\n         return o\n       end\n       \n       -- 基础类方法 printArea\n       function Shape:printArea ()\n         print(&quot;面积为 &quot;,self.area) -- 访问属性\n       end\n       \n       -- 创建对象\n       myshape = Shape:new(nil,10)\n       \n       myshape:printArea()   -- 访问成员函数\n\n继承\n    继承是指一个对象直接使用另一对象的属性和方法\n         -- Meta class\n        Shape = {area = 0}\n        -- 基础类方法 new\n        function Shape:new (o,side)\n          o = o or {}\n          setmetatable(o, self)\n          self.__index = self\n          side = side or 0\n          self.area = side*side;\n          return o\n        end\n        -- 基础类方法 printArea\n        function Shape:printArea ()\n          print(&quot;面积为 &quot;,self.area)\n        end\n        \n        -- 创建对象\n        myshape = Shape:new(nil,10)\n        myshape:printArea()\n        \n        Square = Shape:new()\n        -- 派生类方法 new\n        function Square:new (o,side)\n          o = o or Shape:new(o,side)\n          setmetatable(o, self)\n          self.__index = self\n          return o\n        end\n        \n        -- 派生类方法 printArea\n        function Square:printArea ()\n          print(&quot;正方形面积为 &quot;,self.area)\n        end\n        \n        -- 创建对象\n        mysquare = Square:new(nil,10)\n        mysquare:printArea()\n        \n        Rectangle = Shape:new()\n        -- 派生类方法 new\n        function Rectangle:new (o,length,breadth)\n          o = o or Shape:new(o)\n          setmetatable(o, self)\n          self.__index = self\n          self.area = length * breadth\n          return o\n        end\n        \n        -- 派生类方法 printArea\n        function Rectangle:printArea ()\n          print(&quot;矩形面积为 &quot;,self.area)\n        end\n        \n        -- 创建对象\n        myrectangle = Rectangle:new(nil,10,20)\n        myrectangle:printArea()\n        \n重写\n    -- 派生类方法 printArea\n    function Square:printArea ()\n      print(&quot;正方形面积 &quot;,self.area)\n    end        \n</code></pre>\n<h2><span id=\"数据库访问\">数据库访问</span></h2>\n<pre><code>Lua 连接MySql 数据库\n\nrequire &quot;luasql.mysql&quot;\n\n--创建环境对象\nenv = luasql.mysql()\n\n--连接数据库\nconn = env:connect(&quot;数据库名&quot;,&quot;用户名&quot;,&quot;密码&quot;,&quot;IP地址&quot;,端口)\n\n--设置数据库的编码格式\nconn:execute&quot;SET NAMES UTF8&quot;\n\n--执行数据库操作\ncur = conn:execute(&quot;select * from role&quot;)\n\nrow = cur:fetch({},&quot;a&quot;)\n\n--文件对象的创建\nfile = io.open(&quot;role.txt&quot;,&quot;w+&quot;);\n\nwhile row do\n    var = string.format(&quot;%d %s\\n&quot;, row.id, row.name)\n\n    print(var)\n\n    file:write(var)\n\n    row = cur:fetch(row,&quot;a&quot;)\nend\n\n\nfile:close()  --关闭文件对象\nconn:close()  --关闭数据库连接\nenv:close()   --关闭数据库环境\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2>模块与包</h2>\n<pre><code>Lua 加入了标准的模块管理机制，可以把一些公用的代码放在一个文件里，以 API 接口的形式在其他地方调用，有利于代码的重用和降低代码耦合度。\nLua 的模块是由变量、函数等已知元素组成的 table，因此创建一个模块很简单，就是创建一个 table，然后把需要导出的常量、函数放入其中，最后返回这个 table 就行。\ndemo:\n   -- 文件名为 module.lua\n   -- 定义一个名为 module 的模块\n   module = {}\n    \n   -- 定义一个常量\n   module.constant = &quot;这是一个常量&quot;\n    \n   -- 定义一个函数\n   function module.func1()\n       io.write(&quot;这是一个公有函数！\\n&quot;)\n   end\n    \n   local function func2()\n       print(&quot;这是一个私有函数！&quot;)\n   end\n    \n   function module.func3()\n       func2()\n   end\n    \n   return module\n\n模块引用\n    require 函数\n    Lua提供了一个名为require的函数用来加载模块。要加载一个模块，只需要简单地调用就可以了。\n    \n    require(&quot;&lt;模块名&gt;&quot;)\n    或者\n    require &quot;&lt;模块名&gt;&quot;\n    \n    -- test_module.lua 文件\n    -- module 模块为上文提到到 module.lua\n    require(&quot;module&quot;)\n     \n    print(module.constant)\n     \n    module.func3()\n    \n加载机制\n    加载模块路径\n    对于自定义的模块，模块文件不是放在哪个文件目录都行，函数 require 有它自己的文件路径加载策略，它会尝试从 Lua 文件或 C 程序库中加载模块。\n    require 用于搜索 Lua 文件的路径是存放在全局变量 package.path 中，当 Lua 启动后，会以环境变量 LUA_PATH 的值来初始这个环境变量。如果没有找到该环境变量，则使用一个编译时定义的默认路径来初始化。\n    当然，如果没有 LUA_PATH 这个环境变量，也可以自定义设置，在当前用户根目录下打开 .profile 文件（没有则创建，打开 .bashrc 文件也可以），例如把 &quot;~/lua/&quot; 路径加入 LUA_PATH 环境变量里：\n        #LUA_PATH\n        export LUA_PATH=&quot;~/lua/?.lua;;&quot;   \n    文件路径以 &quot;;&quot; 号分隔，最后的 2 个 &quot;;;&quot; 表示新加的路径后面加上原来的默认路径。\n\nC语言包（非重点）-- 参考：http://www.runoob.com/lua/lua-modules-packages.html\n   Lua和C是很容易结合的，使用C为Lua写包。 \n   与Lua中写包不同，C包在使用以前必须首先加载并连接，在大多数系统中最容易的实现方式是通过动态连接库机制。\n   Lua在一个叫loadlib的函数内提供了所有的动态连接的功能。这个函数有两个参数:库的绝对路径和初始化函数。\n</code></pre>\n<h2>元表(Metatable)</h2>\n<pre><code>http://www.runoob.com/lua/lua-metatables.html\n</code></pre>\n<h2>协程</h2>\n<pre><code>http://www.runoob.com/lua/lua-coroutine.html\n</code></pre>\n<h2>文件I/O</h2>\n<pre><code>http://www.runoob.com/lua/lua-file-io.html\n</code></pre>\n<h2>错误处理</h2>\n<pre><code>错误种类\n    1. 语法错误\n        语法错误通常是由于对程序的组件（如运算符、表达式）使用不当引起的\n    2. 运行错误\n        运行错误是程序可以正常执行，但是会输出报错信息\n\n错误处理\n   使用两个函数：assert 和 error 来处理错误\n   assert函数:\n       local function add(a,b)\n          assert(type(a) == &quot;number&quot;, &quot;a 不是一个数字&quot;)\n          assert(type(b) == &quot;number&quot;, &quot;b 不是一个数字&quot;)\n          return a+b\n       end\n       add(10)\n       \n       执行以上程序会出现如下错误：\n       lua: test.lua:3: b 不是一个数字\n       stack traceback:\n           [C]: in function 'assert'\n           test.lua:3: in local 'add'\n           test.lua:6: in main chunk\n           [C]: in ?         \n    \n   现象:实例中assert首先检查第一个参数，若没问题，assert不做任何事情；否则，assert以第二个参数作为错误信息抛出     \n\n   error函数:\n     格式: error (message [, level])\n        功能：终止正在执行的函数，并返回message的内容作为错误信息(error函数永远都不会返回)\n        通常情况下，error会附加一些错误位置的信息到message头部。\n        Level参数指示获得错误的位置:\n        Level=1[默认]：为调用error位置(文件+行号)\n        Level=2：指出哪个调用error的函数的函数\n        Level=0:不添加错误位置信息      \n\npcall 和 xpcall、debug(非重点内容)\n  Lua中处理错误，可以使用函数pcall（protected call）来包装需要执行的代码。\n  pcall接收一个函数和要传递给后者的参数，并执行，执行结果：有错误、无错误；返回值true或者或false, errorinfo\n      if pcall(function_name,...) then\n      -- 没有错误\n      else\n      -- 一些错误\n      end\n    简单例子:\n        &gt; =pcall(function(i) print(i) end, 33)\n        33\n        true\n        &gt; =pcall(function(i) print(i) error('error..') end, 33)\n        33\n        false        stdin:1: error..        \n    \n    pcall以一种&quot;保护模式&quot;来调用第一个参数，因此pcall可以捕获函数执行中的任何错误。\n    通常在错误发生时，希望落得更多的调试信息，而不只是发生错误的位置。但pcall返回时，它已经销毁了调用桟的部分内容。\n    Lua提供了xpcall函数，xpcall接收第二个参数——一个错误处理函数，当错误发生时，Lua会在调用桟展开（unwind）前调用错误处理函数，于是就可以在这个函数中使用debug库来获取关于错误的额外信息了。\n    debug库提供了两个通用的错误处理函数，返回的调试内容会多一点:\n    debug.debug：提供一个Lua提示符，让用户来检查错误的原因\n    debug.traceback：根据调用桟来构建一个扩展的错误消息\n</code></pre>\n<h2>面向对象</h2>\n<pre><code>面向对象的特征: 封装 继承 多态（lua没有多态）\n\n封装\n    Lua中的表不仅在某种意义上是一种对象。像对象一样，表也有状态（成员变量）；也有与对象的值独立的本性，特别是拥有两个不同值的对象（table）代表两个不同的对象；一个对象在不同的时候也可以有不同的值，但他始终是一个对象；与对象类似，表的生命周期与其由什么创建、在哪创建没有关系。对象有他们的成员函数，表也有：\n       Account = {balance = 0}\n       function Account.withdraw (v)\n           Account.balance = Account.balance - v\n       end \n       \n    简单完整实例\n       -- Meta class\n       Shape = {area = 0}\n       \n       -- 基础类方法 new -- 创建对象\n       function Shape:new (o,side)\n         o = o or {}\n         setmetatable(o, self)\n         self.__index = self\n         side = side or 0\n         self.area = side*side;\n         return o\n       end\n       \n       -- 基础类方法 printArea\n       function Shape:printArea ()\n         print(&quot;面积为 &quot;,self.area) -- 访问属性\n       end\n       \n       -- 创建对象\n       myshape = Shape:new(nil,10)\n       \n       myshape:printArea()   -- 访问成员函数\n\n继承\n    继承是指一个对象直接使用另一对象的属性和方法\n         -- Meta class\n        Shape = {area = 0}\n        -- 基础类方法 new\n        function Shape:new (o,side)\n          o = o or {}\n          setmetatable(o, self)\n          self.__index = self\n          side = side or 0\n          self.area = side*side;\n          return o\n        end\n        -- 基础类方法 printArea\n        function Shape:printArea ()\n          print(&quot;面积为 &quot;,self.area)\n        end\n        \n        -- 创建对象\n        myshape = Shape:new(nil,10)\n        myshape:printArea()\n        \n        Square = Shape:new()\n        -- 派生类方法 new\n        function Square:new (o,side)\n          o = o or Shape:new(o,side)\n          setmetatable(o, self)\n          self.__index = self\n          return o\n        end\n        \n        -- 派生类方法 printArea\n        function Square:printArea ()\n          print(&quot;正方形面积为 &quot;,self.area)\n        end\n        \n        -- 创建对象\n        mysquare = Square:new(nil,10)\n        mysquare:printArea()\n        \n        Rectangle = Shape:new()\n        -- 派生类方法 new\n        function Rectangle:new (o,length,breadth)\n          o = o or Shape:new(o)\n          setmetatable(o, self)\n          self.__index = self\n          self.area = length * breadth\n          return o\n        end\n        \n        -- 派生类方法 printArea\n        function Rectangle:printArea ()\n          print(&quot;矩形面积为 &quot;,self.area)\n        end\n        \n        -- 创建对象\n        myrectangle = Rectangle:new(nil,10,20)\n        myrectangle:printArea()\n        \n重写\n    -- 派生类方法 printArea\n    function Square:printArea ()\n      print(&quot;正方形面积 &quot;,self.area)\n    end        \n</code></pre>\n<h2>数据库访问</h2>\n<pre><code>Lua 连接MySql 数据库\n\nrequire &quot;luasql.mysql&quot;\n\n--创建环境对象\nenv = luasql.mysql()\n\n--连接数据库\nconn = env:connect(&quot;数据库名&quot;,&quot;用户名&quot;,&quot;密码&quot;,&quot;IP地址&quot;,端口)\n\n--设置数据库的编码格式\nconn:execute&quot;SET NAMES UTF8&quot;\n\n--执行数据库操作\ncur = conn:execute(&quot;select * from role&quot;)\n\nrow = cur:fetch({},&quot;a&quot;)\n\n--文件对象的创建\nfile = io.open(&quot;role.txt&quot;,&quot;w+&quot;);\n\nwhile row do\n    var = string.format(&quot;%d %s\\n&quot;, row.id, row.name)\n\n    print(var)\n\n    file:write(var)\n\n    row = cur:fetch(row,&quot;a&quot;)\nend\n\n\nfile:close()  --关闭文件对象\nconn:close()  --关闭数据库连接\nenv:close()   --关闭数据库环境\n</code></pre>\n"},{"title":"Lua脚本教程(2)--运算符,循环,迭代器与流程控制","catalog":true,"date":"2018-12-17T02:42:43.000Z","subtitle":null,"header-img":"Demo.png","_content":"## 运算符\n    Lua提供了以下几种运算符类型:\n        算术运算符\n        关系运算符\n        逻辑运算符\n        其他运算符 (..,#)\n    \n### 算术运算符\n    操作符         描述          实例\n    +              加法          A + B 输出结果 30\n    -              减法          A - B 输出结果 -10\n    *              乘法          A * B 输出结果 200\n    /              除法          B / A w输出结果 2\n    %              取余          B % A 输出结果 0\n    ^              乘幂          A^2 输出结果 100\n    -              负号          -A 输出结果v -10\n\n### 关系运算符\n    操作符          描述\t                                                                        实例\n    ==              等于，检测两个值是否相等，相等返回 true，否则返回 false\t                    (A == B) 为 false。\n    ~=              不等于，检测两个值是否相等，相等返回 false，否则返回 true\t                    (A ~= B) 为 true。\n    >               大于，如果左边的值大于右边的值，返回 true，否则返回 false\t                    (A > B) 为 false。\n    <               小于，如果左边的值大于右边的值，返回 false，否则返回 true\t                    (A < B) 为 true。\n    >=              大于等于，如果左边的值大于等于右边的值，返回 true，否则返回 false\t            (A >= B) 返回 false。\n    <=              小于等于， 如果左边的值小于等于右边的值，返回 true，否则返回 false\t        (A <= B) 返回 true。     \n\n### 逻辑运算符\n    操作符\t        描述                                                                 实例\n    and             逻辑与操作符。 若 A 为 false，则返回 A，否则返回 B。\t                 (A and B) 为 false。\n    or              逻辑或操作符。 若 A 为 true，则返回 A，否则返回 B。\t                 (A or B) 为 true。\n    not             逻辑非操作符。与逻辑运算结果相反，如果条件为 true，逻辑非为 false。    not(A and B) 为 true。\n\n### 运算符优先级\n    从高到低的顺序：\n        ^\n        not    - (unary)\n        *      /\n        +      -\n        ..\n        <      >      <=     >=     ~=     ==\n        and\n        or\n        \n## 循环\n    1. while 循环\t在条件为 true 时，让程序重复地执行某些语句。执行语句前会先检查条件是否为 true。\n        while(condition)\n        do\n           statements\n        end\n        var 从 exp1 变化到 exp2，每次变化以 exp3 为步长递增 var，并执行一次 \"执行体\"。exp3 是可选的，如果不指定，默认为1。\n        \n        例子:\n            for i=1,f(x) do\n                print(i)\n            end\n             \n            for i=10,1,-1 do\n                print(i)\n            end\n    2. for 循环\t重复执行指定语句，重复次数可在 for 语句中控制。\n        (1)数值for循环\n            for var=exp1,exp2,exp3 do  \n                <执行体>  \n            end  \n        (2)泛型for循环   \n            a = {\"one\", \"two\", \"three\"}\n            for i, v in ipairs(a) do\n                print(i, v)\n            end \n    3. repeat...until\t重复执行循环，直到 指定的条件为真时为止\n        repeat\n           statements\n        until( condition )\n        \n        例子：\n            --[ 变量定义 --]\n            a = 10\n            --[ 执行循环 --]\n            repeat\n               print(\"a的值为:\", a)\n               a = a + 1\n            until( a > 15 )  \n    4. 循环嵌套\t可以在循环内嵌套一个或多个循环语句（while do ... end;for ... do ... end;repeat ... until;）\n    5. 无限循环\n        while( true )\n        do\n           print(\"循环将永远执行下去\")\n        end\n    6. break 用于退出当前循环或语句\n        例子：\n            --[ 定义变量 --]\n            a = 10\n            --[ while 循环 --]\n            while( a < 20 )\n            do\n               print(\"a 的值为:\", a)\n               a=a+1\n               if( a > 15)\n               then\n                  --[ 使用 break 语句终止循环 --]\n                  break\n               end\n            end    \n            \n## 迭代器\n    1. 泛型 for 迭代器\n        泛型 for 在自己内部保存迭代函数，实际上它保存三个值：迭代函数、状态常量、控制变量。\n        泛型 for 迭代器提供了集合的 key/value 对，语法格式如下：\n        for k, v in pairs(t) do\n            print(k, v)\n        end\n        \n        array = {\"Lua\", \"Tutorial\"}\n        \n        for key,value in ipairs(array) \n        do\n           print(key, value)\n        end\n        \n    2. 无状态的迭代器\n        无状态的迭代器是指不保留任何状态的迭代器，因此在循环中我们可以利用无状态迭代器避免创建闭包花费额外的代价。\n        每一次迭代，迭代函数都是用两个变量（状态常量和控制变量）的值作为参数被调用，一个无状态的迭代器只利用这两个值可以获取下一个元素。\n        这种无状态迭代器的典型的简单的例子是ipairs，它遍历数组的每一个元素。\n        以下实例我们使用了一个简单的函数来实现迭代器，实现 数字 n 的平方：\n        function square(iteratorMaxCount,currentNumber)\n           if currentNumber<iteratorMaxCount\n           then\n              currentNumber = currentNumber+1\n           return currentNumber, currentNumber*currentNumber\n           end\n        end\n        \n        for i,n in square,3,0\n        do\n           print(i,n)\n        end   \n        \n        简单例子:\n            function iter (a, i)\n                i = i + 1\n                local v = a[i]\n                if v then\n                   return i, v\n                end\n            end\n             \n            function ipairs (a)\n                return iter, a, 0\n            end   \n     \n    3.多状态的迭代器\n         很多情况下，迭代器需要保存多个状态信息而不是简单的状态常量和控制变量，最简单的方法是使用闭包，还有一种方法就是将所有的状态信息封装到table内，将table作为迭代器的状态常量，因为这种情况下可以将所有的信息存放在table内，所以迭代函数通常不需要第二个参数。\n         array = {\"Lua\", \"Tutorial\"}\n         \n         function elementIterator (collection)\n            local index = 0\n            local count = #collection\n            -- 闭包函数\n            return function ()\n               index = index + 1\n               if index <= count\n               then\n                  --  返回迭代器的当前元素\n                  return collection[index]\n               end\n            end\n         end\n         \n         for element in elementIterator(array)\n         do\n            print(element)\n         end\n                      \n## 流程控制\n    1.if 语句\tif 语句 由一个布尔表达式作为条件判断，其后紧跟其他语句组成。\n        if(布尔表达式)\n        then\n           --[ 在布尔表达式为 true 时执行的语句 --]\n        end\n    2.if...else 语句\tif 语句 可以与 else 语句搭配使用, 在 if 条件表达式为 false 时执行 else 语句代码。\n        格式一：\n            if(布尔表达式)\n            then\n               --[ 布尔表达式为 true 时执行该语句块 --]\n            else\n               --[ 布尔表达式为 false 时执行该语句块 --]\n            end\n        \n        格式二：\n            if( 布尔表达式 1)\n            then\n               --[ 在布尔表达式 1 为 true 时执行该语句块 --]\n            \n            elseif( 布尔表达式 2)\n            then\n               --[ 在布尔表达式 2 为 true 时执行该语句块 --]\n            \n            elseif( 布尔表达式 3)\n            then\n               --[ 在布尔表达式 3 为 true 时执行该语句块 --]\n            else \n               --[ 如果以上布尔表达式都不为 true 则执行该语句块 --]\n            end\n    3.if 嵌套语句\t你可以在if 或 else if中使用一个或多个 if 或 else if 语句 。\n        if( 布尔表达式 1)\n        then\n           --[ 布尔表达式 1 为 true 时执行该语句块 --]\n           if(布尔表达式 2)\n           then\n              --[ 布尔表达式 2 为 true 时执行该语句块 --]\n           end\n        end\n","source":"_posts/Lua脚本教程-2.md","raw":"---\ntitle: Lua脚本教程(2)--运算符,循环,迭代器与流程控制\ncatalog: true\ndate: 2018-12-17 10:42:43\nsubtitle:\nheader-img: \"Demo.png\"\ntags:\n---\n## 运算符\n    Lua提供了以下几种运算符类型:\n        算术运算符\n        关系运算符\n        逻辑运算符\n        其他运算符 (..,#)\n    \n### 算术运算符\n    操作符         描述          实例\n    +              加法          A + B 输出结果 30\n    -              减法          A - B 输出结果 -10\n    *              乘法          A * B 输出结果 200\n    /              除法          B / A w输出结果 2\n    %              取余          B % A 输出结果 0\n    ^              乘幂          A^2 输出结果 100\n    -              负号          -A 输出结果v -10\n\n### 关系运算符\n    操作符          描述\t                                                                        实例\n    ==              等于，检测两个值是否相等，相等返回 true，否则返回 false\t                    (A == B) 为 false。\n    ~=              不等于，检测两个值是否相等，相等返回 false，否则返回 true\t                    (A ~= B) 为 true。\n    >               大于，如果左边的值大于右边的值，返回 true，否则返回 false\t                    (A > B) 为 false。\n    <               小于，如果左边的值大于右边的值，返回 false，否则返回 true\t                    (A < B) 为 true。\n    >=              大于等于，如果左边的值大于等于右边的值，返回 true，否则返回 false\t            (A >= B) 返回 false。\n    <=              小于等于， 如果左边的值小于等于右边的值，返回 true，否则返回 false\t        (A <= B) 返回 true。     \n\n### 逻辑运算符\n    操作符\t        描述                                                                 实例\n    and             逻辑与操作符。 若 A 为 false，则返回 A，否则返回 B。\t                 (A and B) 为 false。\n    or              逻辑或操作符。 若 A 为 true，则返回 A，否则返回 B。\t                 (A or B) 为 true。\n    not             逻辑非操作符。与逻辑运算结果相反，如果条件为 true，逻辑非为 false。    not(A and B) 为 true。\n\n### 运算符优先级\n    从高到低的顺序：\n        ^\n        not    - (unary)\n        *      /\n        +      -\n        ..\n        <      >      <=     >=     ~=     ==\n        and\n        or\n        \n## 循环\n    1. while 循环\t在条件为 true 时，让程序重复地执行某些语句。执行语句前会先检查条件是否为 true。\n        while(condition)\n        do\n           statements\n        end\n        var 从 exp1 变化到 exp2，每次变化以 exp3 为步长递增 var，并执行一次 \"执行体\"。exp3 是可选的，如果不指定，默认为1。\n        \n        例子:\n            for i=1,f(x) do\n                print(i)\n            end\n             \n            for i=10,1,-1 do\n                print(i)\n            end\n    2. for 循环\t重复执行指定语句，重复次数可在 for 语句中控制。\n        (1)数值for循环\n            for var=exp1,exp2,exp3 do  \n                <执行体>  \n            end  \n        (2)泛型for循环   \n            a = {\"one\", \"two\", \"three\"}\n            for i, v in ipairs(a) do\n                print(i, v)\n            end \n    3. repeat...until\t重复执行循环，直到 指定的条件为真时为止\n        repeat\n           statements\n        until( condition )\n        \n        例子：\n            --[ 变量定义 --]\n            a = 10\n            --[ 执行循环 --]\n            repeat\n               print(\"a的值为:\", a)\n               a = a + 1\n            until( a > 15 )  \n    4. 循环嵌套\t可以在循环内嵌套一个或多个循环语句（while do ... end;for ... do ... end;repeat ... until;）\n    5. 无限循环\n        while( true )\n        do\n           print(\"循环将永远执行下去\")\n        end\n    6. break 用于退出当前循环或语句\n        例子：\n            --[ 定义变量 --]\n            a = 10\n            --[ while 循环 --]\n            while( a < 20 )\n            do\n               print(\"a 的值为:\", a)\n               a=a+1\n               if( a > 15)\n               then\n                  --[ 使用 break 语句终止循环 --]\n                  break\n               end\n            end    \n            \n## 迭代器\n    1. 泛型 for 迭代器\n        泛型 for 在自己内部保存迭代函数，实际上它保存三个值：迭代函数、状态常量、控制变量。\n        泛型 for 迭代器提供了集合的 key/value 对，语法格式如下：\n        for k, v in pairs(t) do\n            print(k, v)\n        end\n        \n        array = {\"Lua\", \"Tutorial\"}\n        \n        for key,value in ipairs(array) \n        do\n           print(key, value)\n        end\n        \n    2. 无状态的迭代器\n        无状态的迭代器是指不保留任何状态的迭代器，因此在循环中我们可以利用无状态迭代器避免创建闭包花费额外的代价。\n        每一次迭代，迭代函数都是用两个变量（状态常量和控制变量）的值作为参数被调用，一个无状态的迭代器只利用这两个值可以获取下一个元素。\n        这种无状态迭代器的典型的简单的例子是ipairs，它遍历数组的每一个元素。\n        以下实例我们使用了一个简单的函数来实现迭代器，实现 数字 n 的平方：\n        function square(iteratorMaxCount,currentNumber)\n           if currentNumber<iteratorMaxCount\n           then\n              currentNumber = currentNumber+1\n           return currentNumber, currentNumber*currentNumber\n           end\n        end\n        \n        for i,n in square,3,0\n        do\n           print(i,n)\n        end   \n        \n        简单例子:\n            function iter (a, i)\n                i = i + 1\n                local v = a[i]\n                if v then\n                   return i, v\n                end\n            end\n             \n            function ipairs (a)\n                return iter, a, 0\n            end   \n     \n    3.多状态的迭代器\n         很多情况下，迭代器需要保存多个状态信息而不是简单的状态常量和控制变量，最简单的方法是使用闭包，还有一种方法就是将所有的状态信息封装到table内，将table作为迭代器的状态常量，因为这种情况下可以将所有的信息存放在table内，所以迭代函数通常不需要第二个参数。\n         array = {\"Lua\", \"Tutorial\"}\n         \n         function elementIterator (collection)\n            local index = 0\n            local count = #collection\n            -- 闭包函数\n            return function ()\n               index = index + 1\n               if index <= count\n               then\n                  --  返回迭代器的当前元素\n                  return collection[index]\n               end\n            end\n         end\n         \n         for element in elementIterator(array)\n         do\n            print(element)\n         end\n                      \n## 流程控制\n    1.if 语句\tif 语句 由一个布尔表达式作为条件判断，其后紧跟其他语句组成。\n        if(布尔表达式)\n        then\n           --[ 在布尔表达式为 true 时执行的语句 --]\n        end\n    2.if...else 语句\tif 语句 可以与 else 语句搭配使用, 在 if 条件表达式为 false 时执行 else 语句代码。\n        格式一：\n            if(布尔表达式)\n            then\n               --[ 布尔表达式为 true 时执行该语句块 --]\n            else\n               --[ 布尔表达式为 false 时执行该语句块 --]\n            end\n        \n        格式二：\n            if( 布尔表达式 1)\n            then\n               --[ 在布尔表达式 1 为 true 时执行该语句块 --]\n            \n            elseif( 布尔表达式 2)\n            then\n               --[ 在布尔表达式 2 为 true 时执行该语句块 --]\n            \n            elseif( 布尔表达式 3)\n            then\n               --[ 在布尔表达式 3 为 true 时执行该语句块 --]\n            else \n               --[ 如果以上布尔表达式都不为 true 则执行该语句块 --]\n            end\n    3.if 嵌套语句\t你可以在if 或 else if中使用一个或多个 if 或 else if 语句 。\n        if( 布尔表达式 1)\n        then\n           --[ 布尔表达式 1 为 true 时执行该语句块 --]\n           if(布尔表达式 2)\n           then\n              --[ 布尔表达式 2 为 true 时执行该语句块 --]\n           end\n        end\n","slug":"Lua脚本教程-2","published":1,"updated":"2018-12-17T03:41:34.805Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpuya67y00069kuje0hha7o2","content":"<h2><span id=\"运算符\">运算符</span></h2>\n<pre><code>Lua提供了以下几种运算符类型:\n    算术运算符\n    关系运算符\n    逻辑运算符\n    其他运算符 (..,#)\n</code></pre>\n<h3><span id=\"算术运算符\">算术运算符</span></h3>\n<pre><code>操作符         描述          实例\n+              加法          A + B 输出结果 30\n-              减法          A - B 输出结果 -10\n*              乘法          A * B 输出结果 200\n/              除法          B / A w输出结果 2\n%              取余          B % A 输出结果 0\n^              乘幂          A^2 输出结果 100\n-              负号          -A 输出结果v -10\n</code></pre>\n<h3><span id=\"关系运算符\">关系运算符</span></h3>\n<pre><code>操作符          描述\t                                                                        实例\n==              等于，检测两个值是否相等，相等返回 true，否则返回 false\t                    (A == B) 为 false。\n~=              不等于，检测两个值是否相等，相等返回 false，否则返回 true\t                    (A ~= B) 为 true。\n&gt;               大于，如果左边的值大于右边的值，返回 true，否则返回 false\t                    (A &gt; B) 为 false。\n&lt;               小于，如果左边的值大于右边的值，返回 false，否则返回 true\t                    (A &lt; B) 为 true。\n&gt;=              大于等于，如果左边的值大于等于右边的值，返回 true，否则返回 false\t            (A &gt;= B) 返回 false。\n&lt;=              小于等于， 如果左边的值小于等于右边的值，返回 true，否则返回 false\t        (A &lt;= B) 返回 true。     \n</code></pre>\n<h3><span id=\"逻辑运算符\">逻辑运算符</span></h3>\n<pre><code>操作符\t        描述                                                                 实例\nand             逻辑与操作符。 若 A 为 false，则返回 A，否则返回 B。\t                 (A and B) 为 false。\nor              逻辑或操作符。 若 A 为 true，则返回 A，否则返回 B。\t                 (A or B) 为 true。\nnot             逻辑非操作符。与逻辑运算结果相反，如果条件为 true，逻辑非为 false。    not(A and B) 为 true。\n</code></pre>\n<h3><span id=\"运算符优先级\">运算符优先级</span></h3>\n<pre><code>从高到低的顺序：\n    ^\n    not    - (unary)\n    *      /\n    +      -\n    ..\n    &lt;      &gt;      &lt;=     &gt;=     ~=     ==\n    and\n    or\n</code></pre>\n<h2><span id=\"循环\">循环</span></h2>\n<pre><code>1. while 循环\t在条件为 true 时，让程序重复地执行某些语句。执行语句前会先检查条件是否为 true。\n    while(condition)\n    do\n       statements\n    end\n    var 从 exp1 变化到 exp2，每次变化以 exp3 为步长递增 var，并执行一次 &quot;执行体&quot;。exp3 是可选的，如果不指定，默认为1。\n    \n    例子:\n        for i=1,f(x) do\n            print(i)\n        end\n         \n        for i=10,1,-1 do\n            print(i)\n        end\n2. for 循环\t重复执行指定语句，重复次数可在 for 语句中控制。\n    (1)数值for循环\n        for var=exp1,exp2,exp3 do  \n            &lt;执行体&gt;  \n        end  \n    (2)泛型for循环   \n        a = {&quot;one&quot;, &quot;two&quot;, &quot;three&quot;}\n        for i, v in ipairs(a) do\n            print(i, v)\n        end \n3. repeat...until\t重复执行循环，直到 指定的条件为真时为止\n    repeat\n       statements\n    until( condition )\n    \n    例子：\n        --[ 变量定义 --]\n        a = 10\n        --[ 执行循环 --]\n        repeat\n           print(&quot;a的值为:&quot;, a)\n           a = a + 1\n        until( a &gt; 15 )  \n4. 循环嵌套\t可以在循环内嵌套一个或多个循环语句（while do ... end;for ... do ... end;repeat ... until;）\n5. 无限循环\n    while( true )\n    do\n       print(&quot;循环将永远执行下去&quot;)\n    end\n6. break 用于退出当前循环或语句\n    例子：\n        --[ 定义变量 --]\n        a = 10\n        --[ while 循环 --]\n        while( a &lt; 20 )\n        do\n           print(&quot;a 的值为:&quot;, a)\n           a=a+1\n           if( a &gt; 15)\n           then\n              --[ 使用 break 语句终止循环 --]\n              break\n           end\n        end    \n</code></pre>\n<h2><span id=\"迭代器\">迭代器</span></h2>\n<pre><code>1. 泛型 for 迭代器\n    泛型 for 在自己内部保存迭代函数，实际上它保存三个值：迭代函数、状态常量、控制变量。\n    泛型 for 迭代器提供了集合的 key/value 对，语法格式如下：\n    for k, v in pairs(t) do\n        print(k, v)\n    end\n    \n    array = {&quot;Lua&quot;, &quot;Tutorial&quot;}\n    \n    for key,value in ipairs(array) \n    do\n       print(key, value)\n    end\n    \n2. 无状态的迭代器\n    无状态的迭代器是指不保留任何状态的迭代器，因此在循环中我们可以利用无状态迭代器避免创建闭包花费额外的代价。\n    每一次迭代，迭代函数都是用两个变量（状态常量和控制变量）的值作为参数被调用，一个无状态的迭代器只利用这两个值可以获取下一个元素。\n    这种无状态迭代器的典型的简单的例子是ipairs，它遍历数组的每一个元素。\n    以下实例我们使用了一个简单的函数来实现迭代器，实现 数字 n 的平方：\n    function square(iteratorMaxCount,currentNumber)\n       if currentNumber&lt;iteratorMaxCount\n       then\n          currentNumber = currentNumber+1\n       return currentNumber, currentNumber*currentNumber\n       end\n    end\n    \n    for i,n in square,3,0\n    do\n       print(i,n)\n    end   \n    \n    简单例子:\n        function iter (a, i)\n            i = i + 1\n            local v = a[i]\n            if v then\n               return i, v\n            end\n        end\n         \n        function ipairs (a)\n            return iter, a, 0\n        end   \n \n3.多状态的迭代器\n     很多情况下，迭代器需要保存多个状态信息而不是简单的状态常量和控制变量，最简单的方法是使用闭包，还有一种方法就是将所有的状态信息封装到table内，将table作为迭代器的状态常量，因为这种情况下可以将所有的信息存放在table内，所以迭代函数通常不需要第二个参数。\n     array = {&quot;Lua&quot;, &quot;Tutorial&quot;}\n     \n     function elementIterator (collection)\n        local index = 0\n        local count = #collection\n        -- 闭包函数\n        return function ()\n           index = index + 1\n           if index &lt;= count\n           then\n              --  返回迭代器的当前元素\n              return collection[index]\n           end\n        end\n     end\n     \n     for element in elementIterator(array)\n     do\n        print(element)\n     end\n</code></pre>\n<h2><span id=\"流程控制\">流程控制</span></h2>\n<pre><code>1.if 语句\tif 语句 由一个布尔表达式作为条件判断，其后紧跟其他语句组成。\n    if(布尔表达式)\n    then\n       --[ 在布尔表达式为 true 时执行的语句 --]\n    end\n2.if...else 语句\tif 语句 可以与 else 语句搭配使用, 在 if 条件表达式为 false 时执行 else 语句代码。\n    格式一：\n        if(布尔表达式)\n        then\n           --[ 布尔表达式为 true 时执行该语句块 --]\n        else\n           --[ 布尔表达式为 false 时执行该语句块 --]\n        end\n    \n    格式二：\n        if( 布尔表达式 1)\n        then\n           --[ 在布尔表达式 1 为 true 时执行该语句块 --]\n        \n        elseif( 布尔表达式 2)\n        then\n           --[ 在布尔表达式 2 为 true 时执行该语句块 --]\n        \n        elseif( 布尔表达式 3)\n        then\n           --[ 在布尔表达式 3 为 true 时执行该语句块 --]\n        else \n           --[ 如果以上布尔表达式都不为 true 则执行该语句块 --]\n        end\n3.if 嵌套语句\t你可以在if 或 else if中使用一个或多个 if 或 else if 语句 。\n    if( 布尔表达式 1)\n    then\n       --[ 布尔表达式 1 为 true 时执行该语句块 --]\n       if(布尔表达式 2)\n       then\n          --[ 布尔表达式 2 为 true 时执行该语句块 --]\n       end\n    end\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2>运算符</h2>\n<pre><code>Lua提供了以下几种运算符类型:\n    算术运算符\n    关系运算符\n    逻辑运算符\n    其他运算符 (..,#)\n</code></pre>\n<h3>算术运算符</h3>\n<pre><code>操作符         描述          实例\n+              加法          A + B 输出结果 30\n-              减法          A - B 输出结果 -10\n*              乘法          A * B 输出结果 200\n/              除法          B / A w输出结果 2\n%              取余          B % A 输出结果 0\n^              乘幂          A^2 输出结果 100\n-              负号          -A 输出结果v -10\n</code></pre>\n<h3>关系运算符</h3>\n<pre><code>操作符          描述\t                                                                        实例\n==              等于，检测两个值是否相等，相等返回 true，否则返回 false\t                    (A == B) 为 false。\n~=              不等于，检测两个值是否相等，相等返回 false，否则返回 true\t                    (A ~= B) 为 true。\n&gt;               大于，如果左边的值大于右边的值，返回 true，否则返回 false\t                    (A &gt; B) 为 false。\n&lt;               小于，如果左边的值大于右边的值，返回 false，否则返回 true\t                    (A &lt; B) 为 true。\n&gt;=              大于等于，如果左边的值大于等于右边的值，返回 true，否则返回 false\t            (A &gt;= B) 返回 false。\n&lt;=              小于等于， 如果左边的值小于等于右边的值，返回 true，否则返回 false\t        (A &lt;= B) 返回 true。     \n</code></pre>\n<h3>逻辑运算符</h3>\n<pre><code>操作符\t        描述                                                                 实例\nand             逻辑与操作符。 若 A 为 false，则返回 A，否则返回 B。\t                 (A and B) 为 false。\nor              逻辑或操作符。 若 A 为 true，则返回 A，否则返回 B。\t                 (A or B) 为 true。\nnot             逻辑非操作符。与逻辑运算结果相反，如果条件为 true，逻辑非为 false。    not(A and B) 为 true。\n</code></pre>\n<h3>运算符优先级</h3>\n<pre><code>从高到低的顺序：\n    ^\n    not    - (unary)\n    *      /\n    +      -\n    ..\n    &lt;      &gt;      &lt;=     &gt;=     ~=     ==\n    and\n    or\n</code></pre>\n<h2>循环</h2>\n<pre><code>1. while 循环\t在条件为 true 时，让程序重复地执行某些语句。执行语句前会先检查条件是否为 true。\n    while(condition)\n    do\n       statements\n    end\n    var 从 exp1 变化到 exp2，每次变化以 exp3 为步长递增 var，并执行一次 &quot;执行体&quot;。exp3 是可选的，如果不指定，默认为1。\n    \n    例子:\n        for i=1,f(x) do\n            print(i)\n        end\n         \n        for i=10,1,-1 do\n            print(i)\n        end\n2. for 循环\t重复执行指定语句，重复次数可在 for 语句中控制。\n    (1)数值for循环\n        for var=exp1,exp2,exp3 do  \n            &lt;执行体&gt;  \n        end  \n    (2)泛型for循环   \n        a = {&quot;one&quot;, &quot;two&quot;, &quot;three&quot;}\n        for i, v in ipairs(a) do\n            print(i, v)\n        end \n3. repeat...until\t重复执行循环，直到 指定的条件为真时为止\n    repeat\n       statements\n    until( condition )\n    \n    例子：\n        --[ 变量定义 --]\n        a = 10\n        --[ 执行循环 --]\n        repeat\n           print(&quot;a的值为:&quot;, a)\n           a = a + 1\n        until( a &gt; 15 )  \n4. 循环嵌套\t可以在循环内嵌套一个或多个循环语句（while do ... end;for ... do ... end;repeat ... until;）\n5. 无限循环\n    while( true )\n    do\n       print(&quot;循环将永远执行下去&quot;)\n    end\n6. break 用于退出当前循环或语句\n    例子：\n        --[ 定义变量 --]\n        a = 10\n        --[ while 循环 --]\n        while( a &lt; 20 )\n        do\n           print(&quot;a 的值为:&quot;, a)\n           a=a+1\n           if( a &gt; 15)\n           then\n              --[ 使用 break 语句终止循环 --]\n              break\n           end\n        end    \n</code></pre>\n<h2>迭代器</h2>\n<pre><code>1. 泛型 for 迭代器\n    泛型 for 在自己内部保存迭代函数，实际上它保存三个值：迭代函数、状态常量、控制变量。\n    泛型 for 迭代器提供了集合的 key/value 对，语法格式如下：\n    for k, v in pairs(t) do\n        print(k, v)\n    end\n    \n    array = {&quot;Lua&quot;, &quot;Tutorial&quot;}\n    \n    for key,value in ipairs(array) \n    do\n       print(key, value)\n    end\n    \n2. 无状态的迭代器\n    无状态的迭代器是指不保留任何状态的迭代器，因此在循环中我们可以利用无状态迭代器避免创建闭包花费额外的代价。\n    每一次迭代，迭代函数都是用两个变量（状态常量和控制变量）的值作为参数被调用，一个无状态的迭代器只利用这两个值可以获取下一个元素。\n    这种无状态迭代器的典型的简单的例子是ipairs，它遍历数组的每一个元素。\n    以下实例我们使用了一个简单的函数来实现迭代器，实现 数字 n 的平方：\n    function square(iteratorMaxCount,currentNumber)\n       if currentNumber&lt;iteratorMaxCount\n       then\n          currentNumber = currentNumber+1\n       return currentNumber, currentNumber*currentNumber\n       end\n    end\n    \n    for i,n in square,3,0\n    do\n       print(i,n)\n    end   \n    \n    简单例子:\n        function iter (a, i)\n            i = i + 1\n            local v = a[i]\n            if v then\n               return i, v\n            end\n        end\n         \n        function ipairs (a)\n            return iter, a, 0\n        end   \n \n3.多状态的迭代器\n     很多情况下，迭代器需要保存多个状态信息而不是简单的状态常量和控制变量，最简单的方法是使用闭包，还有一种方法就是将所有的状态信息封装到table内，将table作为迭代器的状态常量，因为这种情况下可以将所有的信息存放在table内，所以迭代函数通常不需要第二个参数。\n     array = {&quot;Lua&quot;, &quot;Tutorial&quot;}\n     \n     function elementIterator (collection)\n        local index = 0\n        local count = #collection\n        -- 闭包函数\n        return function ()\n           index = index + 1\n           if index &lt;= count\n           then\n              --  返回迭代器的当前元素\n              return collection[index]\n           end\n        end\n     end\n     \n     for element in elementIterator(array)\n     do\n        print(element)\n     end\n</code></pre>\n<h2>流程控制</h2>\n<pre><code>1.if 语句\tif 语句 由一个布尔表达式作为条件判断，其后紧跟其他语句组成。\n    if(布尔表达式)\n    then\n       --[ 在布尔表达式为 true 时执行的语句 --]\n    end\n2.if...else 语句\tif 语句 可以与 else 语句搭配使用, 在 if 条件表达式为 false 时执行 else 语句代码。\n    格式一：\n        if(布尔表达式)\n        then\n           --[ 布尔表达式为 true 时执行该语句块 --]\n        else\n           --[ 布尔表达式为 false 时执行该语句块 --]\n        end\n    \n    格式二：\n        if( 布尔表达式 1)\n        then\n           --[ 在布尔表达式 1 为 true 时执行该语句块 --]\n        \n        elseif( 布尔表达式 2)\n        then\n           --[ 在布尔表达式 2 为 true 时执行该语句块 --]\n        \n        elseif( 布尔表达式 3)\n        then\n           --[ 在布尔表达式 3 为 true 时执行该语句块 --]\n        else \n           --[ 如果以上布尔表达式都不为 true 则执行该语句块 --]\n        end\n3.if 嵌套语句\t你可以在if 或 else if中使用一个或多个 if 或 else if 语句 。\n    if( 布尔表达式 1)\n    then\n       --[ 布尔表达式 1 为 true 时执行该语句块 --]\n       if(布尔表达式 2)\n       then\n          --[ 布尔表达式 2 为 true 时执行该语句块 --]\n       end\n    end\n</code></pre>\n"},{"title":"RabbitMQ学习(1)--概念与认识","catalog":true,"date":"2018-11-21T02:11:54.000Z","subtitle":null,"header-img":"Demo.png","catagories":["RabbitMQ"],"_content":"# RabbitMQ学习(1)--概念与认识\n\n## 消息队列\n\n### 解决了什么问题\n1.异步处理\n>以前一般写业务是串行模式，发短信是耗费时间的操作，串行有可能断开HTTP连接还没有做完\n\n![异步处理](异步处理.png)\n2.应用解耦\n>即多个子系统有关联，例如库存与订单系统，如果使用串行的模式，有可能在运行的过程中，由于系统间的通讯异常,造成数据丢失，这样会影响整个流程不能正常的走通\n\n![系统解耦](系统解耦.png)\n3.流量削锋\n>使用MQ之后,如果不满足的请求直接丢弃，这样可以把我们大量请求处理进行隔绝，保证业务不会因海量的访问而崩溃\n\n![秒杀抢购](秒杀抢购.png)\n4.日志处理\n>下面例子用于统计UV,PV等日志数据例子,一般来说，日志不会直接写入数据库，而是先写入文件，再由日志收集工具(logstash)进行统一的处理\n\n>流计算：就是实时计算，生成显示数据\n离线计算：对数据进行持久化\n\n![日志收集与处理](日志收集与处理.png)\n\n5. 等等\n\n### RabbitMQ安装 (不做详细的介绍)\n>自行参考网址: https://www.cnblogs.com/zzpblogs/p/8168763.html\n\n### RabbitMQ的简单使用\n\n#### 用户管理\n1.添加用户\n![用户管理-添加用户](用户管理-添加用户.png)\n\n#### virtual hosts管理\nvirtual hosts 相当于mysql的db(即数据库)，一般以\"/\"开头\n创建完数据库后，就要对数据库进行授权，\n![vhost](vhost.png)\n![v-host授权](v-host授权.png)\n![v-host添加](v-host添加.png)\n![v-host授权2](v-host授权2.png)\n![v-host授权后](v-host授权后.png)\n","source":"_posts/RabbitMQ学习-1-概念与认识.md","raw":"---\ntitle: \"RabbitMQ学习(1)--概念与认识\"\ncatalog: true\ndate: 2018-11-21 10:11:54\nsubtitle: \nheader-img: \"Demo.png\"\ntags:\n- RabbitMQ 消息队列\ncatagories:\n- RabbitMQ\n---\n# RabbitMQ学习(1)--概念与认识\n\n## 消息队列\n\n### 解决了什么问题\n1.异步处理\n>以前一般写业务是串行模式，发短信是耗费时间的操作，串行有可能断开HTTP连接还没有做完\n\n![异步处理](异步处理.png)\n2.应用解耦\n>即多个子系统有关联，例如库存与订单系统，如果使用串行的模式，有可能在运行的过程中，由于系统间的通讯异常,造成数据丢失，这样会影响整个流程不能正常的走通\n\n![系统解耦](系统解耦.png)\n3.流量削锋\n>使用MQ之后,如果不满足的请求直接丢弃，这样可以把我们大量请求处理进行隔绝，保证业务不会因海量的访问而崩溃\n\n![秒杀抢购](秒杀抢购.png)\n4.日志处理\n>下面例子用于统计UV,PV等日志数据例子,一般来说，日志不会直接写入数据库，而是先写入文件，再由日志收集工具(logstash)进行统一的处理\n\n>流计算：就是实时计算，生成显示数据\n离线计算：对数据进行持久化\n\n![日志收集与处理](日志收集与处理.png)\n\n5. 等等\n\n### RabbitMQ安装 (不做详细的介绍)\n>自行参考网址: https://www.cnblogs.com/zzpblogs/p/8168763.html\n\n### RabbitMQ的简单使用\n\n#### 用户管理\n1.添加用户\n![用户管理-添加用户](用户管理-添加用户.png)\n\n#### virtual hosts管理\nvirtual hosts 相当于mysql的db(即数据库)，一般以\"/\"开头\n创建完数据库后，就要对数据库进行授权，\n![vhost](vhost.png)\n![v-host授权](v-host授权.png)\n![v-host添加](v-host添加.png)\n![v-host授权2](v-host授权2.png)\n![v-host授权后](v-host授权后.png)\n","slug":"RabbitMQ学习-1-概念与认识","published":1,"updated":"2018-11-21T06:16:07.799Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpuya68100089kujcfl7l00u","content":"<h1><span id=\"rabbitmq学习1概念与认识\">RabbitMQ学习(1)–概念与认识</span></h1>\n<h2><span id=\"消息队列\">消息队列</span></h2>\n<h3><span id=\"解决了什么问题\">解决了什么问题</span></h3>\n<p>1.异步处理</p>\n<blockquote>\n<p>以前一般写业务是串行模式，发短信是耗费时间的操作，串行有可能断开HTTP连接还没有做完</p>\n</blockquote>\n<p><img src=\"%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86.png\" alt=\"异步处理\"><br>\n2.应用解耦</p>\n<blockquote>\n<p>即多个子系统有关联，例如库存与订单系统，如果使用串行的模式，有可能在运行的过程中，由于系统间的通讯异常,造成数据丢失，这样会影响整个流程不能正常的走通</p>\n</blockquote>\n<p><img src=\"%E7%B3%BB%E7%BB%9F%E8%A7%A3%E8%80%A6.png\" alt=\"系统解耦\"><br>\n3.流量削锋</p>\n<blockquote>\n<p>使用MQ之后,如果不满足的请求直接丢弃，这样可以把我们大量请求处理进行隔绝，保证业务不会因海量的访问而崩溃</p>\n</blockquote>\n<p><img src=\"%E7%A7%92%E6%9D%80%E6%8A%A2%E8%B4%AD.png\" alt=\"秒杀抢购\"><br>\n4.日志处理</p>\n<blockquote>\n<p>下面例子用于统计UV,PV等日志数据例子,一般来说，日志不会直接写入数据库，而是先写入文件，再由日志收集工具(logstash)进行统一的处理</p>\n</blockquote>\n<blockquote>\n<p>流计算：就是实时计算，生成显示数据<br>\n离线计算：对数据进行持久化</p>\n</blockquote>\n<p><img src=\"%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86%E4%B8%8E%E5%A4%84%E7%90%86.png\" alt=\"日志收集与处理\"></p>\n<ol start=\"5\">\n<li>等等</li>\n</ol>\n<h3><span id=\"rabbitmq安装-不做详细的介绍\">RabbitMQ安装 (不做详细的介绍)</span></h3>\n<blockquote>\n<p>自行参考网址: <a href=\"https://www.cnblogs.com/zzpblogs/p/8168763.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/zzpblogs/p/8168763.html</a></p>\n</blockquote>\n<h3><span id=\"rabbitmq的简单使用\">RabbitMQ的简单使用</span></h3>\n<h4><span id=\"用户管理\">用户管理</span></h4>\n<p>1.添加用户<br>\n<img src=\"%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86-%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7.png\" alt=\"用户管理-添加用户\"></p>\n<h4><span id=\"virtual-hosts管理\">virtual hosts管理</span></h4>\n<p>virtual hosts 相当于mysql的db(即数据库)，一般以&quot;/&quot;开头<br>\n创建完数据库后，就要对数据库进行授权，<br>\n<img src=\"vhost.png\" alt=\"vhost\"><br>\n<img src=\"v-host%E6%8E%88%E6%9D%83.png\" alt=\"v-host授权\"><br>\n<img src=\"v-host%E6%B7%BB%E5%8A%A0.png\" alt=\"v-host添加\"><br>\n<img src=\"v-host%E6%8E%88%E6%9D%832.png\" alt=\"v-host授权2\"><br>\n<img src=\"v-host%E6%8E%88%E6%9D%83%E5%90%8E.png\" alt=\"v-host授权后\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1>RabbitMQ学习(1)–概念与认识</h1>\n<h2>消息队列</h2>\n<h3>解决了什么问题</h3>\n<p>1.异步处理</p>\n<blockquote>\n<p>以前一般写业务是串行模式，发短信是耗费时间的操作，串行有可能断开HTTP连接还没有做完</p>\n</blockquote>\n<p><img src=\"%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86.png\" alt=\"异步处理\"><br>\n2.应用解耦</p>\n<blockquote>\n<p>即多个子系统有关联，例如库存与订单系统，如果使用串行的模式，有可能在运行的过程中，由于系统间的通讯异常,造成数据丢失，这样会影响整个流程不能正常的走通</p>\n</blockquote>\n<p><img src=\"%E7%B3%BB%E7%BB%9F%E8%A7%A3%E8%80%A6.png\" alt=\"系统解耦\"><br>\n3.流量削锋</p>\n<blockquote>\n<p>使用MQ之后,如果不满足的请求直接丢弃，这样可以把我们大量请求处理进行隔绝，保证业务不会因海量的访问而崩溃</p>\n</blockquote>\n<p><img src=\"%E7%A7%92%E6%9D%80%E6%8A%A2%E8%B4%AD.png\" alt=\"秒杀抢购\"><br>\n4.日志处理</p>\n<blockquote>\n<p>下面例子用于统计UV,PV等日志数据例子,一般来说，日志不会直接写入数据库，而是先写入文件，再由日志收集工具(logstash)进行统一的处理</p>\n</blockquote>\n<blockquote>\n<p>流计算：就是实时计算，生成显示数据<br>\n离线计算：对数据进行持久化</p>\n</blockquote>\n<p><img src=\"%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86%E4%B8%8E%E5%A4%84%E7%90%86.png\" alt=\"日志收集与处理\"></p>\n<ol start=\"5\">\n<li>等等</li>\n</ol>\n<h3>RabbitMQ安装 (不做详细的介绍)</h3>\n<blockquote>\n<p>自行参考网址: <a href=\"https://www.cnblogs.com/zzpblogs/p/8168763.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/zzpblogs/p/8168763.html</a></p>\n</blockquote>\n<h3>RabbitMQ的简单使用</h3>\n<h4>用户管理</h4>\n<p>1.添加用户<br>\n<img src=\"%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86-%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7.png\" alt=\"用户管理-添加用户\"></p>\n<h4>virtual hosts管理</h4>\n<p>virtual hosts 相当于mysql的db(即数据库)，一般以&quot;/&quot;开头<br>\n创建完数据库后，就要对数据库进行授权，<br>\n<img src=\"vhost.png\" alt=\"vhost\"><br>\n<img src=\"v-host%E6%8E%88%E6%9D%83.png\" alt=\"v-host授权\"><br>\n<img src=\"v-host%E6%B7%BB%E5%8A%A0.png\" alt=\"v-host添加\"><br>\n<img src=\"v-host%E6%8E%88%E6%9D%832.png\" alt=\"v-host授权2\"><br>\n<img src=\"v-host%E6%8E%88%E6%9D%83%E5%90%8E.png\" alt=\"v-host授权后\"></p>\n"},{"title":"RabbitMQ学习(2)--队列模型","catalog":true,"date":"2018-11-21T06:11:54.000Z","subtitle":null,"header-img":"Demo.png","catagories":["RabbitMQ"],"_content":"\n# RabbitMQ学习(1)--队列模型\n\n## 概念\nRabbitMQ存在六种模型\n>1.简单队列\n>2.工作队列\n>3.发布订阅\n>4.路由\n>5.Topic\n>6.RPC\n\n## 模型\n### 简单队列\n![简单队列](简单队列.png)\n>模型解析\nP: 消息生产者\n红色方块集合: 消息队列\nC: 消息消费者\n\n#### Golang实现简单队列\n\n官方依赖库: go get github.com/streadway/amqp\n\n向队列发送消息具体流程\n>1.获取MQ的连接\n>2.创建频道,从连接中获取通道\n>3.创建队列声明\n>4.创建消息，并发送消息\n>5.关闭连接\n\n>具体代码:\n```\npackage main\nimport (\n\t\"github.com/streadway/amqp\"\n\t\"log\"\n)\n\n// We also need an helper function to check the return value for each amqp call\nfunc failOnError(err error, msg string) {\n\tif err != nil {\n\t\tlog.Fatalf(\"%s: %s\", msg, err)\n\t}\n}\n\nfunc main() {\n\t// 连接到RabbitMQ Server\n\tconn, err := amqp.Dial(\"amqp://user_mmr:123456@localhost:5672/\")\n\tfailOnError(err, \"Failed to connect to RabbitMQ\")\n\tdefer conn.Close()\n\t// 创建channel，channel为驻留程序\n\tch, err := conn.Channel()\n\tfailOnError(err, \"Failed to Open a channel\")\n\tdefer ch.Close()\n\t// 我们需要声明发送队列，那么我们可以发送消息到这个队列上\n\t// 队列的创建时幂等的，只有当不存在，才会创建队列，且队列名是唯一的\n\tq, err := ch.QueueDeclare(\n\t\t\"hello\", // name\n\t\tfalse,   // durable\n\t\tfalse,   // delete when unused\n\t\tfalse,   // exclusive\n\t\tfalse,   // no-wait\n\t\tnil,     // arguments\n\t)\n\tfailOnError(err, \"Failed to declare a queue\")\n\tbody := \"Hello World222!\"\n\terr = ch.Publish(\n\t\t\"\",     // exchange\n\t\tq.Name, // routing key\n\t\tfalse,  // mandatory\n\t\tfalse,  // immediate\n\t\tamqp.Publishing{\n\t\t\tContentType: \"text/plain\",\n\t\t\tBody:        []byte(body),\n\t\t})\n\tfailOnError(err, \"Failed to publish a message\")\n}\n```\n\n\n从队列接收消息具体流程\n>1.获取MQ的连接\n>2.创建频道,从连接中获取通道\n>3.定义队列的监听者\n>4.监听队列(开一个协程来监听处理)\n\n>具体代码:\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"github.com/streadway/amqp\"\n\t\"log\"\n)\n\n// We also need an helper function to check the return value for each amqp call\nfunc failOnError(err error, msg string) {\n\tif err != nil {\n\t\tlog.Fatalf(\"%s: %s\", msg, err)\n\t}\n}\n\nfunc main() {\n\tconn, err := amqp.Dial(\"amqp://user_mmr:123456@localhost:5672/\")\n\tfailOnError(err, \"Failed to connect to RabbitMQ\")\n\tdefer conn.Close()\n\n\tch, err := conn.Channel()\n\tfailOnError(err, \"Failed to open a channel\")\n\tdefer ch.Close()\n\n\tq, err := ch.QueueDeclare(\n\t\t\"hello\", // name\n\t\tfalse,   // durable\n\t\tfalse,   // delete when usused\n\t\tfalse,   // exclusive\n\t\tfalse,   // no-wait\n\t\tnil,     // arguments\n\t)\n\tfailOnError(err, \"Failed to declare a queue\")\n\tmsgs, err := ch.Consume(\n\t\tq.Name, // queue\n\t\t\"\",     // consumer\n\t\ttrue,   // auto-ack\n\t\tfalse,  // exclusive\n\t\tfalse,  // no-local\n\t\tfalse,  // no-wait\n\t\tnil,    // args\n\t)\n\tfailOnError(err, \"Failed to register a consumer\")\n\tfmt.Println(\"aaaaaa\")\n\tforever := make(chan bool)\n\n\tgo func() {\n\t\tfor d := range msgs {\n\t\t\tlog.Printf(\"Received a message: %s\", d.Body)\n\t\t}\n\t}()\n\n\tlog.Printf(\" [*] Waiting for messages. To exit press CTRL+C\")\n\t<-forever\n}\n\n```\n\n#### 简单队列的不足\n耦合性高，生产者一一对应消费者(如果我想有多个消费者消费队列中的消息，这种情况就不行了)\n队列名变更，这个时候也得同时变更\n\n### 工作队列\n![工作队列](工作队列.png)\n\n####为什么会出现工作队列\nSimple 队列是一一对应的，而且我们实际开发，生产者发送消息是毫不费力的，而消费者一般是要跟业务相结合的，消费者接收到消息之后就需要处理，可能需要花费时间,即耗时操作，由于只有一个消费者，此时队列就会挤压了很多的消息等待处理，所以工作队列能够解决这个问题\n\n从上面的代码中可以发现,消费者1和消费者2处理的消息是一样的,\n消费者1: 偶数\n消费者2：奇数\n这个方式叫做轮训分发(round-robin),结果就是不管谁忙者谁清闲，都不会多给一个消息，消息任务总是你一个我一个\n\n\n\n\n\n\n\n","source":"_posts/RabbitMQ学习-2-队列模型.md","raw":"---\ntitle: \"RabbitMQ学习(2)--队列模型\"\ncatalog: true\ndate: 2018-11-21 14:11:54\nsubtitle: \nheader-img: \"Demo.png\"\ntags:\n- RabbitMQ 消息队列\ncatagories:\n- RabbitMQ\n---\n\n# RabbitMQ学习(1)--队列模型\n\n## 概念\nRabbitMQ存在六种模型\n>1.简单队列\n>2.工作队列\n>3.发布订阅\n>4.路由\n>5.Topic\n>6.RPC\n\n## 模型\n### 简单队列\n![简单队列](简单队列.png)\n>模型解析\nP: 消息生产者\n红色方块集合: 消息队列\nC: 消息消费者\n\n#### Golang实现简单队列\n\n官方依赖库: go get github.com/streadway/amqp\n\n向队列发送消息具体流程\n>1.获取MQ的连接\n>2.创建频道,从连接中获取通道\n>3.创建队列声明\n>4.创建消息，并发送消息\n>5.关闭连接\n\n>具体代码:\n```\npackage main\nimport (\n\t\"github.com/streadway/amqp\"\n\t\"log\"\n)\n\n// We also need an helper function to check the return value for each amqp call\nfunc failOnError(err error, msg string) {\n\tif err != nil {\n\t\tlog.Fatalf(\"%s: %s\", msg, err)\n\t}\n}\n\nfunc main() {\n\t// 连接到RabbitMQ Server\n\tconn, err := amqp.Dial(\"amqp://user_mmr:123456@localhost:5672/\")\n\tfailOnError(err, \"Failed to connect to RabbitMQ\")\n\tdefer conn.Close()\n\t// 创建channel，channel为驻留程序\n\tch, err := conn.Channel()\n\tfailOnError(err, \"Failed to Open a channel\")\n\tdefer ch.Close()\n\t// 我们需要声明发送队列，那么我们可以发送消息到这个队列上\n\t// 队列的创建时幂等的，只有当不存在，才会创建队列，且队列名是唯一的\n\tq, err := ch.QueueDeclare(\n\t\t\"hello\", // name\n\t\tfalse,   // durable\n\t\tfalse,   // delete when unused\n\t\tfalse,   // exclusive\n\t\tfalse,   // no-wait\n\t\tnil,     // arguments\n\t)\n\tfailOnError(err, \"Failed to declare a queue\")\n\tbody := \"Hello World222!\"\n\terr = ch.Publish(\n\t\t\"\",     // exchange\n\t\tq.Name, // routing key\n\t\tfalse,  // mandatory\n\t\tfalse,  // immediate\n\t\tamqp.Publishing{\n\t\t\tContentType: \"text/plain\",\n\t\t\tBody:        []byte(body),\n\t\t})\n\tfailOnError(err, \"Failed to publish a message\")\n}\n```\n\n\n从队列接收消息具体流程\n>1.获取MQ的连接\n>2.创建频道,从连接中获取通道\n>3.定义队列的监听者\n>4.监听队列(开一个协程来监听处理)\n\n>具体代码:\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"github.com/streadway/amqp\"\n\t\"log\"\n)\n\n// We also need an helper function to check the return value for each amqp call\nfunc failOnError(err error, msg string) {\n\tif err != nil {\n\t\tlog.Fatalf(\"%s: %s\", msg, err)\n\t}\n}\n\nfunc main() {\n\tconn, err := amqp.Dial(\"amqp://user_mmr:123456@localhost:5672/\")\n\tfailOnError(err, \"Failed to connect to RabbitMQ\")\n\tdefer conn.Close()\n\n\tch, err := conn.Channel()\n\tfailOnError(err, \"Failed to open a channel\")\n\tdefer ch.Close()\n\n\tq, err := ch.QueueDeclare(\n\t\t\"hello\", // name\n\t\tfalse,   // durable\n\t\tfalse,   // delete when usused\n\t\tfalse,   // exclusive\n\t\tfalse,   // no-wait\n\t\tnil,     // arguments\n\t)\n\tfailOnError(err, \"Failed to declare a queue\")\n\tmsgs, err := ch.Consume(\n\t\tq.Name, // queue\n\t\t\"\",     // consumer\n\t\ttrue,   // auto-ack\n\t\tfalse,  // exclusive\n\t\tfalse,  // no-local\n\t\tfalse,  // no-wait\n\t\tnil,    // args\n\t)\n\tfailOnError(err, \"Failed to register a consumer\")\n\tfmt.Println(\"aaaaaa\")\n\tforever := make(chan bool)\n\n\tgo func() {\n\t\tfor d := range msgs {\n\t\t\tlog.Printf(\"Received a message: %s\", d.Body)\n\t\t}\n\t}()\n\n\tlog.Printf(\" [*] Waiting for messages. To exit press CTRL+C\")\n\t<-forever\n}\n\n```\n\n#### 简单队列的不足\n耦合性高，生产者一一对应消费者(如果我想有多个消费者消费队列中的消息，这种情况就不行了)\n队列名变更，这个时候也得同时变更\n\n### 工作队列\n![工作队列](工作队列.png)\n\n####为什么会出现工作队列\nSimple 队列是一一对应的，而且我们实际开发，生产者发送消息是毫不费力的，而消费者一般是要跟业务相结合的，消费者接收到消息之后就需要处理，可能需要花费时间,即耗时操作，由于只有一个消费者，此时队列就会挤压了很多的消息等待处理，所以工作队列能够解决这个问题\n\n从上面的代码中可以发现,消费者1和消费者2处理的消息是一样的,\n消费者1: 偶数\n消费者2：奇数\n这个方式叫做轮训分发(round-robin),结果就是不管谁忙者谁清闲，都不会多给一个消息，消息任务总是你一个我一个\n\n\n\n\n\n\n\n","slug":"RabbitMQ学习-2-队列模型","published":1,"updated":"2018-11-25T00:34:17.568Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpuya686000a9kujm51bhhfz","content":"<h1><span id=\"rabbitmq学习1队列模型\">RabbitMQ学习(1)–队列模型</span></h1>\n<h2><span id=\"概念\">概念</span></h2>\n<p>RabbitMQ存在六种模型</p>\n<blockquote>\n<p>1.简单队列<br>\n2.工作队列<br>\n3.发布订阅<br>\n4.路由<br>\n5.Topic<br>\n6.RPC</p>\n</blockquote>\n<h2><span id=\"模型\">模型</span></h2>\n<h3><span id=\"简单队列\">简单队列</span></h3>\n<p><img src=\"%E7%AE%80%E5%8D%95%E9%98%9F%E5%88%97.png\" alt=\"简单队列\"></p>\n<blockquote>\n<p>模型解析<br>\nP: 消息生产者<br>\n红色方块集合: 消息队列<br>\nC: 消息消费者</p>\n</blockquote>\n<h4><span id=\"golang实现简单队列\">Golang实现简单队列</span></h4>\n<p>官方依赖库: go get <a href=\"http://github.com/streadway/amqp\" target=\"_blank\" rel=\"noopener\">github.com/streadway/amqp</a></p>\n<p>向队列发送消息具体流程</p>\n<blockquote>\n<p>1.获取MQ的连接<br>\n2.创建频道,从连接中获取通道<br>\n3.创建队列声明<br>\n4.创建消息，并发送消息<br>\n5.关闭连接</p>\n</blockquote>\n<blockquote>\n<p>具体代码:</p>\n</blockquote>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"github.com/streadway/amqp\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"log\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// We also need an helper function to check the return value for each amqp call</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">failOnError</span><span class=\"params\">(err error, msg <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatalf(<span class=\"string\">\"%s: %s\"</span>, msg, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 连接到RabbitMQ Server</span></span><br><span class=\"line\">\tconn, err := amqp.Dial(<span class=\"string\">\"amqp://user_mmr:123456@localhost:5672/\"</span>)</span><br><span class=\"line\">\tfailOnError(err, <span class=\"string\">\"Failed to connect to RabbitMQ\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> conn.Close()</span><br><span class=\"line\">\t<span class=\"comment\">// 创建channel，channel为驻留程序</span></span><br><span class=\"line\">\tch, err := conn.Channel()</span><br><span class=\"line\">\tfailOnError(err, <span class=\"string\">\"Failed to Open a channel\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> ch.Close()</span><br><span class=\"line\">\t<span class=\"comment\">// 我们需要声明发送队列，那么我们可以发送消息到这个队列上</span></span><br><span class=\"line\">\t<span class=\"comment\">// 队列的创建时幂等的，只有当不存在，才会创建队列，且队列名是唯一的</span></span><br><span class=\"line\">\tq, err := ch.QueueDeclare(</span><br><span class=\"line\">\t\t<span class=\"string\">\"hello\"</span>, <span class=\"comment\">// name</span></span><br><span class=\"line\">\t\t<span class=\"literal\">false</span>,   <span class=\"comment\">// durable</span></span><br><span class=\"line\">\t\t<span class=\"literal\">false</span>,   <span class=\"comment\">// delete when unused</span></span><br><span class=\"line\">\t\t<span class=\"literal\">false</span>,   <span class=\"comment\">// exclusive</span></span><br><span class=\"line\">\t\t<span class=\"literal\">false</span>,   <span class=\"comment\">// no-wait</span></span><br><span class=\"line\">\t\t<span class=\"literal\">nil</span>,     <span class=\"comment\">// arguments</span></span><br><span class=\"line\">\t)</span><br><span class=\"line\">\tfailOnError(err, <span class=\"string\">\"Failed to declare a queue\"</span>)</span><br><span class=\"line\">\tbody := <span class=\"string\">\"Hello World222!\"</span></span><br><span class=\"line\">\terr = ch.Publish(</span><br><span class=\"line\">\t\t<span class=\"string\">\"\"</span>,     <span class=\"comment\">// exchange</span></span><br><span class=\"line\">\t\tq.Name, <span class=\"comment\">// routing key</span></span><br><span class=\"line\">\t\t<span class=\"literal\">false</span>,  <span class=\"comment\">// mandatory</span></span><br><span class=\"line\">\t\t<span class=\"literal\">false</span>,  <span class=\"comment\">// immediate</span></span><br><span class=\"line\">\t\tamqp.Publishing&#123;</span><br><span class=\"line\">\t\t\tContentType: <span class=\"string\">\"text/plain\"</span>,</span><br><span class=\"line\">\t\t\tBody:        []<span class=\"keyword\">byte</span>(body),</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\tfailOnError(err, <span class=\"string\">\"Failed to publish a message\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从队列接收消息具体流程</p>\n<blockquote>\n<p>1.获取MQ的连接<br>\n2.创建频道,从连接中获取通道<br>\n3.定义队列的监听者<br>\n4.监听队列(开一个协程来监听处理)</p>\n</blockquote>\n<blockquote>\n<p>具体代码:</p>\n</blockquote>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"github.com/streadway/amqp\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"log\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// We also need an helper function to check the return value for each amqp call</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">failOnError</span><span class=\"params\">(err error, msg <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatalf(<span class=\"string\">\"%s: %s\"</span>, msg, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tconn, err := amqp.Dial(<span class=\"string\">\"amqp://user_mmr:123456@localhost:5672/\"</span>)</span><br><span class=\"line\">\tfailOnError(err, <span class=\"string\">\"Failed to connect to RabbitMQ\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> conn.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">\tch, err := conn.Channel()</span><br><span class=\"line\">\tfailOnError(err, <span class=\"string\">\"Failed to open a channel\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> ch.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">\tq, err := ch.QueueDeclare(</span><br><span class=\"line\">\t\t<span class=\"string\">\"hello\"</span>, <span class=\"comment\">// name</span></span><br><span class=\"line\">\t\t<span class=\"literal\">false</span>,   <span class=\"comment\">// durable</span></span><br><span class=\"line\">\t\t<span class=\"literal\">false</span>,   <span class=\"comment\">// delete when usused</span></span><br><span class=\"line\">\t\t<span class=\"literal\">false</span>,   <span class=\"comment\">// exclusive</span></span><br><span class=\"line\">\t\t<span class=\"literal\">false</span>,   <span class=\"comment\">// no-wait</span></span><br><span class=\"line\">\t\t<span class=\"literal\">nil</span>,     <span class=\"comment\">// arguments</span></span><br><span class=\"line\">\t)</span><br><span class=\"line\">\tfailOnError(err, <span class=\"string\">\"Failed to declare a queue\"</span>)</span><br><span class=\"line\">\tmsgs, err := ch.Consume(</span><br><span class=\"line\">\t\tq.Name, <span class=\"comment\">// queue</span></span><br><span class=\"line\">\t\t<span class=\"string\">\"\"</span>,     <span class=\"comment\">// consumer</span></span><br><span class=\"line\">\t\t<span class=\"literal\">true</span>,   <span class=\"comment\">// auto-ack</span></span><br><span class=\"line\">\t\t<span class=\"literal\">false</span>,  <span class=\"comment\">// exclusive</span></span><br><span class=\"line\">\t\t<span class=\"literal\">false</span>,  <span class=\"comment\">// no-local</span></span><br><span class=\"line\">\t\t<span class=\"literal\">false</span>,  <span class=\"comment\">// no-wait</span></span><br><span class=\"line\">\t\t<span class=\"literal\">nil</span>,    <span class=\"comment\">// args</span></span><br><span class=\"line\">\t)</span><br><span class=\"line\">\tfailOnError(err, <span class=\"string\">\"Failed to register a consumer\"</span>)</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">\"aaaaaa\"</span>)</span><br><span class=\"line\">\tforever := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">bool</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> d := <span class=\"keyword\">range</span> msgs &#123;</span><br><span class=\"line\">\t\t\tlog.Printf(<span class=\"string\">\"Received a message: %s\"</span>, d.Body)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">\tlog.Printf(<span class=\"string\">\" [*] Waiting for messages. To exit press CTRL+C\"</span>)</span><br><span class=\"line\">\t&lt;-forever</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4><span id=\"简单队列的不足\">简单队列的不足</span></h4>\n<p>耦合性高，生产者一一对应消费者(如果我想有多个消费者消费队列中的消息，这种情况就不行了)<br>\n队列名变更，这个时候也得同时变更</p>\n<h3><span id=\"工作队列\">工作队列</span></h3>\n<p><img src=\"%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97.png\" alt=\"工作队列\"></p>\n<p>####为什么会出现工作队列<br>\nSimple 队列是一一对应的，而且我们实际开发，生产者发送消息是毫不费力的，而消费者一般是要跟业务相结合的，消费者接收到消息之后就需要处理，可能需要花费时间,即耗时操作，由于只有一个消费者，此时队列就会挤压了很多的消息等待处理，所以工作队列能够解决这个问题</p>\n<p>从上面的代码中可以发现,消费者1和消费者2处理的消息是一样的,<br>\n消费者1: 偶数<br>\n消费者2：奇数<br>\n这个方式叫做轮训分发(round-robin),结果就是不管谁忙者谁清闲，都不会多给一个消息，消息任务总是你一个我一个</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>RabbitMQ学习(1)–队列模型</h1>\n<h2>概念</h2>\n<p>RabbitMQ存在六种模型</p>\n<blockquote>\n<p>1.简单队列<br>\n2.工作队列<br>\n3.发布订阅<br>\n4.路由<br>\n5.Topic<br>\n6.RPC</p>\n</blockquote>\n<h2>模型</h2>\n<h3>简单队列</h3>\n<p><img src=\"%E7%AE%80%E5%8D%95%E9%98%9F%E5%88%97.png\" alt=\"简单队列\"></p>\n<blockquote>\n<p>模型解析<br>\nP: 消息生产者<br>\n红色方块集合: 消息队列<br>\nC: 消息消费者</p>\n</blockquote>\n<h4>Golang实现简单队列</h4>\n<p>官方依赖库: go get <a href=\"http://github.com/streadway/amqp\" target=\"_blank\" rel=\"noopener\">github.com/streadway/amqp</a></p>\n<p>向队列发送消息具体流程</p>\n<blockquote>\n<p>1.获取MQ的连接<br>\n2.创建频道,从连接中获取通道<br>\n3.创建队列声明<br>\n4.创建消息，并发送消息<br>\n5.关闭连接</p>\n</blockquote>\n<blockquote>\n<p>具体代码:</p>\n</blockquote>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"github.com/streadway/amqp\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"log\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// We also need an helper function to check the return value for each amqp call</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">failOnError</span><span class=\"params\">(err error, msg <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatalf(<span class=\"string\">\"%s: %s\"</span>, msg, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 连接到RabbitMQ Server</span></span><br><span class=\"line\">\tconn, err := amqp.Dial(<span class=\"string\">\"amqp://user_mmr:123456@localhost:5672/\"</span>)</span><br><span class=\"line\">\tfailOnError(err, <span class=\"string\">\"Failed to connect to RabbitMQ\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> conn.Close()</span><br><span class=\"line\">\t<span class=\"comment\">// 创建channel，channel为驻留程序</span></span><br><span class=\"line\">\tch, err := conn.Channel()</span><br><span class=\"line\">\tfailOnError(err, <span class=\"string\">\"Failed to Open a channel\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> ch.Close()</span><br><span class=\"line\">\t<span class=\"comment\">// 我们需要声明发送队列，那么我们可以发送消息到这个队列上</span></span><br><span class=\"line\">\t<span class=\"comment\">// 队列的创建时幂等的，只有当不存在，才会创建队列，且队列名是唯一的</span></span><br><span class=\"line\">\tq, err := ch.QueueDeclare(</span><br><span class=\"line\">\t\t<span class=\"string\">\"hello\"</span>, <span class=\"comment\">// name</span></span><br><span class=\"line\">\t\t<span class=\"literal\">false</span>,   <span class=\"comment\">// durable</span></span><br><span class=\"line\">\t\t<span class=\"literal\">false</span>,   <span class=\"comment\">// delete when unused</span></span><br><span class=\"line\">\t\t<span class=\"literal\">false</span>,   <span class=\"comment\">// exclusive</span></span><br><span class=\"line\">\t\t<span class=\"literal\">false</span>,   <span class=\"comment\">// no-wait</span></span><br><span class=\"line\">\t\t<span class=\"literal\">nil</span>,     <span class=\"comment\">// arguments</span></span><br><span class=\"line\">\t)</span><br><span class=\"line\">\tfailOnError(err, <span class=\"string\">\"Failed to declare a queue\"</span>)</span><br><span class=\"line\">\tbody := <span class=\"string\">\"Hello World222!\"</span></span><br><span class=\"line\">\terr = ch.Publish(</span><br><span class=\"line\">\t\t<span class=\"string\">\"\"</span>,     <span class=\"comment\">// exchange</span></span><br><span class=\"line\">\t\tq.Name, <span class=\"comment\">// routing key</span></span><br><span class=\"line\">\t\t<span class=\"literal\">false</span>,  <span class=\"comment\">// mandatory</span></span><br><span class=\"line\">\t\t<span class=\"literal\">false</span>,  <span class=\"comment\">// immediate</span></span><br><span class=\"line\">\t\tamqp.Publishing&#123;</span><br><span class=\"line\">\t\t\tContentType: <span class=\"string\">\"text/plain\"</span>,</span><br><span class=\"line\">\t\t\tBody:        []<span class=\"keyword\">byte</span>(body),</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\tfailOnError(err, <span class=\"string\">\"Failed to publish a message\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从队列接收消息具体流程</p>\n<blockquote>\n<p>1.获取MQ的连接<br>\n2.创建频道,从连接中获取通道<br>\n3.定义队列的监听者<br>\n4.监听队列(开一个协程来监听处理)</p>\n</blockquote>\n<blockquote>\n<p>具体代码:</p>\n</blockquote>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"github.com/streadway/amqp\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"log\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// We also need an helper function to check the return value for each amqp call</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">failOnError</span><span class=\"params\">(err error, msg <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatalf(<span class=\"string\">\"%s: %s\"</span>, msg, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tconn, err := amqp.Dial(<span class=\"string\">\"amqp://user_mmr:123456@localhost:5672/\"</span>)</span><br><span class=\"line\">\tfailOnError(err, <span class=\"string\">\"Failed to connect to RabbitMQ\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> conn.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">\tch, err := conn.Channel()</span><br><span class=\"line\">\tfailOnError(err, <span class=\"string\">\"Failed to open a channel\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> ch.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">\tq, err := ch.QueueDeclare(</span><br><span class=\"line\">\t\t<span class=\"string\">\"hello\"</span>, <span class=\"comment\">// name</span></span><br><span class=\"line\">\t\t<span class=\"literal\">false</span>,   <span class=\"comment\">// durable</span></span><br><span class=\"line\">\t\t<span class=\"literal\">false</span>,   <span class=\"comment\">// delete when usused</span></span><br><span class=\"line\">\t\t<span class=\"literal\">false</span>,   <span class=\"comment\">// exclusive</span></span><br><span class=\"line\">\t\t<span class=\"literal\">false</span>,   <span class=\"comment\">// no-wait</span></span><br><span class=\"line\">\t\t<span class=\"literal\">nil</span>,     <span class=\"comment\">// arguments</span></span><br><span class=\"line\">\t)</span><br><span class=\"line\">\tfailOnError(err, <span class=\"string\">\"Failed to declare a queue\"</span>)</span><br><span class=\"line\">\tmsgs, err := ch.Consume(</span><br><span class=\"line\">\t\tq.Name, <span class=\"comment\">// queue</span></span><br><span class=\"line\">\t\t<span class=\"string\">\"\"</span>,     <span class=\"comment\">// consumer</span></span><br><span class=\"line\">\t\t<span class=\"literal\">true</span>,   <span class=\"comment\">// auto-ack</span></span><br><span class=\"line\">\t\t<span class=\"literal\">false</span>,  <span class=\"comment\">// exclusive</span></span><br><span class=\"line\">\t\t<span class=\"literal\">false</span>,  <span class=\"comment\">// no-local</span></span><br><span class=\"line\">\t\t<span class=\"literal\">false</span>,  <span class=\"comment\">// no-wait</span></span><br><span class=\"line\">\t\t<span class=\"literal\">nil</span>,    <span class=\"comment\">// args</span></span><br><span class=\"line\">\t)</span><br><span class=\"line\">\tfailOnError(err, <span class=\"string\">\"Failed to register a consumer\"</span>)</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">\"aaaaaa\"</span>)</span><br><span class=\"line\">\tforever := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">bool</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> d := <span class=\"keyword\">range</span> msgs &#123;</span><br><span class=\"line\">\t\t\tlog.Printf(<span class=\"string\">\"Received a message: %s\"</span>, d.Body)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">\tlog.Printf(<span class=\"string\">\" [*] Waiting for messages. To exit press CTRL+C\"</span>)</span><br><span class=\"line\">\t&lt;-forever</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4>简单队列的不足</h4>\n<p>耦合性高，生产者一一对应消费者(如果我想有多个消费者消费队列中的消息，这种情况就不行了)<br>\n队列名变更，这个时候也得同时变更</p>\n<h3>工作队列</h3>\n<p><img src=\"%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97.png\" alt=\"工作队列\"></p>\n<p>####为什么会出现工作队列<br>\nSimple 队列是一一对应的，而且我们实际开发，生产者发送消息是毫不费力的，而消费者一般是要跟业务相结合的，消费者接收到消息之后就需要处理，可能需要花费时间,即耗时操作，由于只有一个消费者，此时队列就会挤压了很多的消息等待处理，所以工作队列能够解决这个问题</p>\n<p>从上面的代码中可以发现,消费者1和消费者2处理的消息是一样的,<br>\n消费者1: 偶数<br>\n消费者2：奇数<br>\n这个方式叫做轮训分发(round-robin),结果就是不管谁忙者谁清闲，都不会多给一个消息，消息任务总是你一个我一个</p>\n"},{"title":"[Hexo] 主题使用教程","catalog":true,"date":"2018-11-08T16:23:00.000Z","subtitle":"This is hexo theme Demo.","header-img":"Demo.png","catagories":["Hexo"],"_content":"> Ported Theme of [Hux Blog](https://github.com/Huxpro/huxpro.github.io), Thank [Huxpro](https://github.com/Huxpro) for designing such a flawless theme.\n> \n> This BeanTech theme created by [YuHsuan](http://beantech.org) modified from the original Porter [Kaijun](http://kaijun.rocks/hexo-theme-huxblog/)\n\n# [Live Demo](http://beantech.org)\n---\n![BeanTech Desktop](http://beantech.org/img/beantech-desktop.png)\n\n# Usage\n---\nI publish the whole project for your convenience, so you can just follow the instruction down below, then you can easily customiz your own blog!\n\nLet's begin!!!\n\n## Init\n---\n```bash\ngit clone https://github.com/YenYuHsuan/hexo-theme-beantech.git ./hexo-beantech\ncd hexo-beantech\nnpm install\n```\n\n## Modify\n---\nModify `_config.yml` file with your own info.\nEspecially the section:\n### Deployment\nReplace to your own repo!\n```yml\ndeploy:\n  type: git\n  repo: https://github.com/<yourAccount>/<repo>\n  branch: <your-branch>\n```\n\n### Sidebar settings\nCopy your avatar image to `<root>/img/` and modify the `_config.yml`:\n```yml\nsidebar: true    # whether or not using Sidebar.\nsidebar-about-description: \"<your description>\"\nsidebar-avatar: img/<your avatar path>\n```\nand activate your personal widget you like\n```yml\nwidgets:         # here are widget you can use, you can comment out\n- featured-tags\n- short-about\n- recent-posts\n- friends-blog\n- archive\n- category\n```\nif you want to add sidebar widget, please add at `layout/_widget`.\n### Signature Setup\nCopy your signature image to `<root>/img/signature` and modify the `_config.yml`:\n```yml\nsignature: true   # show signature\nsignature-img: img/signature/<your-signature-ID>\n```\n### Go to top icon Setup\nMy icon is using iron man, you can change to your own icon at `css/image`.\n\n### Post tag\nYou can decide to show post tags or not.\n```yml\nhome_posts_tag: true\n```\n![home_posts_tag-true](home_posts_tag-true.png)\n```yml\nhome_posts_tag: false\n```\n![home_posts_tag-false](home_posts_tag-false.png)\n\n### Markdown render\nMy markdown render engine plugin is [hexo-renderer-markdown-it](https://github.com/celsomiranda/hexo-renderer-markdown-it).\n```yml\n# Markdown-it config\n## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wiki\nmarkdown:\n  render:\n    html: true\n    xhtmlOut: false\n    breaks: true\n    linkify: true\n    typographer: true\n    quotes: '“”‘’'\n```\nand if you want to change the header anchor 'ℬ', you can go to `layout/post.ejs` to change it.\n```javascript\nasync(\"https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js\",function(){\n        anchors.options = {\n          visible: 'hover',\n          placement: 'left',\n          icon: ℬ // this is the header anchor \"unicode\" icon\n        };\n```\n\n## Hexo Basics\n---\nSome hexo command:\n```bash\nhexo new post \"<post name>\" # you can change post to another layout if you want\nhexo clean && hexo generate # generate the static file\nhexo server # run hexo in local environment\nhexo deploy # hexo will push the static files automatically into the specific branch(gh-pages) of your repo!\n```\n\n# Have fun ^_^ \n---\n<!-- Place this tag in your head or just before your close body tag. -->\n<script async defer src=\"https://buttons.github.io/buttons.js\"></script>\n<!-- Place this tag where you want the button to render. -->\n\nPlease <a class=\"github-button\" href=\"https://github.com/YenYuHsuan/hexo-theme-beantech\" data-icon=\"octicon-star\" aria-label=\"Star YenYuHsuan/hexo-theme-beantech on GitHub\">Star</a> this Project if you like it! <a class=\"github-button\" href=\"https://github.com/YenYuHsuan\" aria-label=\"Follow @YenYuHsuan on GitHub\">Follow</a> would also be appreciated!\nPeace!\n","source":"_posts/hexo-theme-beantech.md","raw":"---\ntitle: \"[Hexo] 主题使用教程\"\ncatalog: true\ndate: 2018-11-09 00:23:00\nsubtitle: \"This is hexo theme Demo.\"\nheader-img: \"Demo.png\"\ntags:\n- Hexo\ncatagories:\n- Hexo\n---\n> Ported Theme of [Hux Blog](https://github.com/Huxpro/huxpro.github.io), Thank [Huxpro](https://github.com/Huxpro) for designing such a flawless theme.\n> \n> This BeanTech theme created by [YuHsuan](http://beantech.org) modified from the original Porter [Kaijun](http://kaijun.rocks/hexo-theme-huxblog/)\n\n# [Live Demo](http://beantech.org)\n---\n![BeanTech Desktop](http://beantech.org/img/beantech-desktop.png)\n\n# Usage\n---\nI publish the whole project for your convenience, so you can just follow the instruction down below, then you can easily customiz your own blog!\n\nLet's begin!!!\n\n## Init\n---\n```bash\ngit clone https://github.com/YenYuHsuan/hexo-theme-beantech.git ./hexo-beantech\ncd hexo-beantech\nnpm install\n```\n\n## Modify\n---\nModify `_config.yml` file with your own info.\nEspecially the section:\n### Deployment\nReplace to your own repo!\n```yml\ndeploy:\n  type: git\n  repo: https://github.com/<yourAccount>/<repo>\n  branch: <your-branch>\n```\n\n### Sidebar settings\nCopy your avatar image to `<root>/img/` and modify the `_config.yml`:\n```yml\nsidebar: true    # whether or not using Sidebar.\nsidebar-about-description: \"<your description>\"\nsidebar-avatar: img/<your avatar path>\n```\nand activate your personal widget you like\n```yml\nwidgets:         # here are widget you can use, you can comment out\n- featured-tags\n- short-about\n- recent-posts\n- friends-blog\n- archive\n- category\n```\nif you want to add sidebar widget, please add at `layout/_widget`.\n### Signature Setup\nCopy your signature image to `<root>/img/signature` and modify the `_config.yml`:\n```yml\nsignature: true   # show signature\nsignature-img: img/signature/<your-signature-ID>\n```\n### Go to top icon Setup\nMy icon is using iron man, you can change to your own icon at `css/image`.\n\n### Post tag\nYou can decide to show post tags or not.\n```yml\nhome_posts_tag: true\n```\n![home_posts_tag-true](home_posts_tag-true.png)\n```yml\nhome_posts_tag: false\n```\n![home_posts_tag-false](home_posts_tag-false.png)\n\n### Markdown render\nMy markdown render engine plugin is [hexo-renderer-markdown-it](https://github.com/celsomiranda/hexo-renderer-markdown-it).\n```yml\n# Markdown-it config\n## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wiki\nmarkdown:\n  render:\n    html: true\n    xhtmlOut: false\n    breaks: true\n    linkify: true\n    typographer: true\n    quotes: '“”‘’'\n```\nand if you want to change the header anchor 'ℬ', you can go to `layout/post.ejs` to change it.\n```javascript\nasync(\"https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js\",function(){\n        anchors.options = {\n          visible: 'hover',\n          placement: 'left',\n          icon: ℬ // this is the header anchor \"unicode\" icon\n        };\n```\n\n## Hexo Basics\n---\nSome hexo command:\n```bash\nhexo new post \"<post name>\" # you can change post to another layout if you want\nhexo clean && hexo generate # generate the static file\nhexo server # run hexo in local environment\nhexo deploy # hexo will push the static files automatically into the specific branch(gh-pages) of your repo!\n```\n\n# Have fun ^_^ \n---\n<!-- Place this tag in your head or just before your close body tag. -->\n<script async defer src=\"https://buttons.github.io/buttons.js\"></script>\n<!-- Place this tag where you want the button to render. -->\n\nPlease <a class=\"github-button\" href=\"https://github.com/YenYuHsuan/hexo-theme-beantech\" data-icon=\"octicon-star\" aria-label=\"Star YenYuHsuan/hexo-theme-beantech on GitHub\">Star</a> this Project if you like it! <a class=\"github-button\" href=\"https://github.com/YenYuHsuan\" aria-label=\"Follow @YenYuHsuan on GitHub\">Follow</a> would also be appreciated!\nPeace!\n","slug":"hexo-theme-beantech","published":1,"updated":"2018-11-09T23:53:16.362Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpuya68e000c9kujohsppdyy","content":"<blockquote>\n<p>Ported Theme of <a href=\"https://github.com/Huxpro/huxpro.github.io\" target=\"_blank\" rel=\"noopener\">Hux Blog</a>, Thank <a href=\"https://github.com/Huxpro\" target=\"_blank\" rel=\"noopener\">Huxpro</a> for designing such a flawless theme.</p>\n<p>This BeanTech theme created by <a href=\"http://beantech.org\" target=\"_blank\" rel=\"noopener\">YuHsuan</a> modified from the original Porter <a href=\"http://kaijun.rocks/hexo-theme-huxblog/\" target=\"_blank\" rel=\"noopener\">Kaijun</a></p>\n</blockquote>\n<h1><span id=\"live-demo\"></span></h1>\n<hr>\n<p><img src=\"http://beantech.org/img/beantech-desktop.png\" alt=\"BeanTech Desktop\"></p>\n<h1><span id=\"usage\">Usage</span></h1>\n<hr>\n<p>I publish the whole project for your convenience, so you can just follow the instruction down below, then you can easily customiz your own blog!</p>\n<p>Let’s begin!!!</p>\n<h2><span id=\"init\">Init</span></h2>\n<hr>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/YenYuHsuan/hexo-theme-beantech.git ./hexo-beantech</span><br><span class=\"line\"><span class=\"built_in\">cd</span> hexo-beantech</span><br><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n<h2><span id=\"modify\">Modify</span></h2>\n<hr>\n<p>Modify <code>_config.yml</code> file with your own info.<br>\nEspecially the section:</p>\n<h3><span id=\"deployment\">Deployment</span></h3>\n<p>Replace to your own repo!</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\"><span class=\"attr\">  type:</span> <span class=\"string\">git</span></span><br><span class=\"line\"><span class=\"attr\">  repo:</span> <span class=\"attr\">https://github.com/&lt;yourAccount&gt;/&lt;repo&gt;</span></span><br><span class=\"line\"><span class=\"attr\">  branch:</span> <span class=\"string\">&lt;your-branch&gt;</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"sidebar-settings\">Sidebar settings</span></h3>\n<p>Copy your avatar image to <code>&lt;root&gt;/img/</code> and modify the <code>_config.yml</code>:</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">sidebar:</span> <span class=\"literal\">true</span>    <span class=\"comment\"># whether or not using Sidebar.</span></span><br><span class=\"line\"><span class=\"attr\">sidebar-about-description:</span> <span class=\"string\">\"&lt;your description&gt;\"</span></span><br><span class=\"line\"><span class=\"attr\">sidebar-avatar:</span> <span class=\"string\">img/&lt;your</span> <span class=\"string\">avatar</span> <span class=\"string\">path&gt;</span></span><br></pre></td></tr></table></figure>\n<p>and activate your personal widget you like</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">widgets:</span>         <span class=\"comment\"># here are widget you can use, you can comment out</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">featured-tags</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">short-about</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">recent-posts</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">friends-blog</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">archive</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">category</span></span><br></pre></td></tr></table></figure>\n<p>if you want to add sidebar widget, please add at <code>layout/_widget</code>.</p>\n<h3><span id=\"signature-setup\">Signature Setup</span></h3>\n<p>Copy your signature image to <code>&lt;root&gt;/img/signature</code> and modify the <code>_config.yml</code>:</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">signature:</span> <span class=\"literal\">true</span>   <span class=\"comment\"># show signature</span></span><br><span class=\"line\"><span class=\"attr\">signature-img:</span> <span class=\"string\">img/signature/&lt;your-signature-ID&gt;</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"go-to-top-icon-setup\">Go to top icon Setup</span></h3>\n<p>My icon is using iron man, you can change to your own icon at <code>css/image</code>.</p>\n<h3><span id=\"post-tag\">Post tag</span></h3>\n<p>You can decide to show post tags or not.</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">home_posts_tag:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"home_posts_tag-true.png\" alt=\"home_posts_tag-true\"></p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">home_posts_tag:</span> <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"home_posts_tag-false.png\" alt=\"home_posts_tag-false\"></p>\n<h3><span id=\"markdown-render\">Markdown render</span></h3>\n<p>My markdown render engine plugin is <a href=\"https://github.com/celsomiranda/hexo-renderer-markdown-it\" target=\"_blank\" rel=\"noopener\">hexo-renderer-markdown-it</a>.</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Markdown-it config</span></span><br><span class=\"line\"><span class=\"comment\">## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wiki</span></span><br><span class=\"line\"><span class=\"attr\">markdown:</span></span><br><span class=\"line\"><span class=\"attr\">  render:</span></span><br><span class=\"line\"><span class=\"attr\">    html:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    xhtmlOut:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    breaks:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    linkify:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    typographer:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    quotes:</span> <span class=\"string\">'“”‘’'</span></span><br></pre></td></tr></table></figure>\n<p>and if you want to change the header anchor ‘ℬ’, you can go to <code>layout/post.ejs</code> to change it.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span>(<span class=\"string\">\"https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        anchors.options = &#123;</span><br><span class=\"line\">          visible: <span class=\"string\">'hover'</span>,</span><br><span class=\"line\">          placement: <span class=\"string\">'left'</span>,</span><br><span class=\"line\">          icon: ℬ <span class=\"comment\">// this is the header anchor \"unicode\" icon</span></span><br><span class=\"line\">        &#125;;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"hexo-basics\">Hexo Basics</span></h2>\n<hr>\n<p>Some hexo command:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new post <span class=\"string\">\"&lt;post name&gt;\"</span> <span class=\"comment\"># you can change post to another layout if you want</span></span><br><span class=\"line\">hexo clean &amp;&amp; hexo generate <span class=\"comment\"># generate the static file</span></span><br><span class=\"line\">hexo server <span class=\"comment\"># run hexo in local environment</span></span><br><span class=\"line\">hexo deploy <span class=\"comment\"># hexo will push the static files automatically into the specific branch(gh-pages) of your repo!</span></span><br></pre></td></tr></table></figure>\n<h1><span id=\"have-fun-_\">Have fun ^_^</span></h1>\n<hr>\n<!-- Place this tag in your head or just before your close body tag. -->\n<script async defer src=\"https://buttons.github.io/buttons.js\"></script>\n<!-- Place this tag where you want the button to render. -->\n<p>Please <a class=\"github-button\" href=\"https://github.com/YenYuHsuan/hexo-theme-beantech\" data-icon=\"octicon-star\" aria-label=\"Star YenYuHsuan/hexo-theme-beantech on GitHub\" target=\"_blank\" rel=\"noopener\">Star</a> this Project if you like it! <a class=\"github-button\" href=\"https://github.com/YenYuHsuan\" aria-label=\"Follow @YenYuHsuan on GitHub\" target=\"_blank\" rel=\"noopener\">Follow</a> would also be appreciated!<br>\nPeace!</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>Ported Theme of <a href=\"https://github.com/Huxpro/huxpro.github.io\" target=\"_blank\" rel=\"noopener\">Hux Blog</a>, Thank <a href=\"https://github.com/Huxpro\" target=\"_blank\" rel=\"noopener\">Huxpro</a> for designing such a flawless theme.</p>\n<p>This BeanTech theme created by <a href=\"http://beantech.org\" target=\"_blank\" rel=\"noopener\">YuHsuan</a> modified from the original Porter <a href=\"http://kaijun.rocks/hexo-theme-huxblog/\" target=\"_blank\" rel=\"noopener\">Kaijun</a></p>\n</blockquote>\n<h1><a href=\"http://beantech.org\" target=\"_blank\" rel=\"noopener\">Live Demo</a></h1>\n<hr>\n<p><img src=\"http://beantech.org/img/beantech-desktop.png\" alt=\"BeanTech Desktop\"></p>\n<h1>Usage</h1>\n<hr>\n<p>I publish the whole project for your convenience, so you can just follow the instruction down below, then you can easily customiz your own blog!</p>\n<p>Let’s begin!!!</p>\n<h2>Init</h2>\n<hr>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/YenYuHsuan/hexo-theme-beantech.git ./hexo-beantech</span><br><span class=\"line\"><span class=\"built_in\">cd</span> hexo-beantech</span><br><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n<h2>Modify</h2>\n<hr>\n<p>Modify <code>_config.yml</code> file with your own info.<br>\nEspecially the section:</p>\n<h3>Deployment</h3>\n<p>Replace to your own repo!</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\"><span class=\"attr\">  type:</span> <span class=\"string\">git</span></span><br><span class=\"line\"><span class=\"attr\">  repo:</span> <span class=\"attr\">https://github.com/&lt;yourAccount&gt;/&lt;repo&gt;</span></span><br><span class=\"line\"><span class=\"attr\">  branch:</span> <span class=\"string\">&lt;your-branch&gt;</span></span><br></pre></td></tr></table></figure>\n<h3>Sidebar settings</h3>\n<p>Copy your avatar image to <code>&lt;root&gt;/img/</code> and modify the <code>_config.yml</code>:</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">sidebar:</span> <span class=\"literal\">true</span>    <span class=\"comment\"># whether or not using Sidebar.</span></span><br><span class=\"line\"><span class=\"attr\">sidebar-about-description:</span> <span class=\"string\">\"&lt;your description&gt;\"</span></span><br><span class=\"line\"><span class=\"attr\">sidebar-avatar:</span> <span class=\"string\">img/&lt;your</span> <span class=\"string\">avatar</span> <span class=\"string\">path&gt;</span></span><br></pre></td></tr></table></figure>\n<p>and activate your personal widget you like</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">widgets:</span>         <span class=\"comment\"># here are widget you can use, you can comment out</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">featured-tags</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">short-about</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">recent-posts</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">friends-blog</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">archive</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">category</span></span><br></pre></td></tr></table></figure>\n<p>if you want to add sidebar widget, please add at <code>layout/_widget</code>.</p>\n<h3>Signature Setup</h3>\n<p>Copy your signature image to <code>&lt;root&gt;/img/signature</code> and modify the <code>_config.yml</code>:</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">signature:</span> <span class=\"literal\">true</span>   <span class=\"comment\"># show signature</span></span><br><span class=\"line\"><span class=\"attr\">signature-img:</span> <span class=\"string\">img/signature/&lt;your-signature-ID&gt;</span></span><br></pre></td></tr></table></figure>\n<h3>Go to top icon Setup</h3>\n<p>My icon is using iron man, you can change to your own icon at <code>css/image</code>.</p>\n<h3>Post tag</h3>\n<p>You can decide to show post tags or not.</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">home_posts_tag:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"home_posts_tag-true.png\" alt=\"home_posts_tag-true\"></p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">home_posts_tag:</span> <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"home_posts_tag-false.png\" alt=\"home_posts_tag-false\"></p>\n<h3>Markdown render</h3>\n<p>My markdown render engine plugin is <a href=\"https://github.com/celsomiranda/hexo-renderer-markdown-it\" target=\"_blank\" rel=\"noopener\">hexo-renderer-markdown-it</a>.</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Markdown-it config</span></span><br><span class=\"line\"><span class=\"comment\">## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wiki</span></span><br><span class=\"line\"><span class=\"attr\">markdown:</span></span><br><span class=\"line\"><span class=\"attr\">  render:</span></span><br><span class=\"line\"><span class=\"attr\">    html:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    xhtmlOut:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    breaks:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    linkify:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    typographer:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    quotes:</span> <span class=\"string\">'“”‘’'</span></span><br></pre></td></tr></table></figure>\n<p>and if you want to change the header anchor ‘ℬ’, you can go to <code>layout/post.ejs</code> to change it.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span>(<span class=\"string\">\"https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        anchors.options = &#123;</span><br><span class=\"line\">          visible: <span class=\"string\">'hover'</span>,</span><br><span class=\"line\">          placement: <span class=\"string\">'left'</span>,</span><br><span class=\"line\">          icon: ℬ <span class=\"comment\">// this is the header anchor \"unicode\" icon</span></span><br><span class=\"line\">        &#125;;</span><br></pre></td></tr></table></figure>\n<h2>Hexo Basics</h2>\n<hr>\n<p>Some hexo command:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new post <span class=\"string\">\"&lt;post name&gt;\"</span> <span class=\"comment\"># you can change post to another layout if you want</span></span><br><span class=\"line\">hexo clean &amp;&amp; hexo generate <span class=\"comment\"># generate the static file</span></span><br><span class=\"line\">hexo server <span class=\"comment\"># run hexo in local environment</span></span><br><span class=\"line\">hexo deploy <span class=\"comment\"># hexo will push the static files automatically into the specific branch(gh-pages) of your repo!</span></span><br></pre></td></tr></table></figure>\n<h1>Have fun ^_^</h1>\n<hr>\n<!-- Place this tag in your head or just before your close body tag. -->\n<script async defer src=\"https://buttons.github.io/buttons.js\"></script>\n<!-- Place this tag where you want the button to render. -->\n<p>Please <a class=\"github-button\" href=\"https://github.com/YenYuHsuan/hexo-theme-beantech\" data-icon=\"octicon-star\" aria-label=\"Star YenYuHsuan/hexo-theme-beantech on GitHub\" target=\"_blank\" rel=\"noopener\">Star</a> this Project if you like it! <a class=\"github-button\" href=\"https://github.com/YenYuHsuan\" aria-label=\"Follow @YenYuHsuan on GitHub\" target=\"_blank\" rel=\"noopener\">Follow</a> would also be appreciated!<br>\nPeace!</p>\n"},{"title":"微服务API网关框架(2)--Nginx的使用","catalog":true,"date":"2018-12-19T08:52:03.000Z","subtitle":null,"header-img":"Demo.png","catagories":["微服务API网关"],"_content":"\n# Nginx\n\n## Nginx命令\n\n### nginx启动\n    指令：nginx程序   -c   nginx配置文件\n    # /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf\n    \n### nginx重启\n    #cd /usr/local/nginx/sbin\n    ##重启\n    # ./nginx -s reload   \n    进入nginx可执行程序的目录\n    # cd /usr/local/nginx/sbin/\n    # ./nginx -s reload\n    nginx: [error] invalid PID number \"\" in \"/usr/local/nginx/logs/nginx.pid\"\n    重启是建立在nginx服务需要启动\n    \n### nginx停止\n    # ./nginx -s stop \n    # ./nginx -s quit\n    \n    quit 是一个优雅的关闭方式，Nginx在退出前完成已经接受的连接请求\n    stop 是快速关闭，不管有没有正在处理的请求。\n    \n### 重新打开日志   \n    # ./nginx -s reopen   \n    \n### nginx检查配置文件\n    检查配置文件是否正确\n    第一种\n    进入nginx可执行程序的目录\n    # cd /usr/local/nginx/sbin/\n    # ./nginx -t\n    \n    第二种\n    # /usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.conf\n\n## Nginx信号控制\n    Nginx支持2种进程模型Single和Master-Worker\n    Single是单进程，一般不适用，\n    Master-Worker是主进程和工作进程模型运行，主进程对工作进程管理。\n    Nginx允许我们通过信号来控制主进程，用信号的方式可以达到不影响现有连接的目的。 \n\n### 信号类型\n    INT，TERM\t\t快速关闭信号\n    QUIT\t\t\t从容关闭信号\n    HUP\t\t\t\t从容重启信号，一般用于修改配置文件后，重启\n    USR1\t\t\t重读日志，一般用于日志的切割\n    USR2\t\t\t平滑升级信号\n    WINCH\t\t\t从容关闭旧进程\n\n","source":"_posts/微服务API网关框架-2.md","raw":"---\ntitle: 微服务API网关框架(2)--Nginx的使用\ncatalog: true\ndate: 2018-12-19 16:52:03\nsubtitle:\nheader-img: \"Demo.png\"\ntags:\n- 微服务API网关\ncatagories:\n- 微服务API网关\n---\n\n# Nginx\n\n## Nginx命令\n\n### nginx启动\n    指令：nginx程序   -c   nginx配置文件\n    # /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf\n    \n### nginx重启\n    #cd /usr/local/nginx/sbin\n    ##重启\n    # ./nginx -s reload   \n    进入nginx可执行程序的目录\n    # cd /usr/local/nginx/sbin/\n    # ./nginx -s reload\n    nginx: [error] invalid PID number \"\" in \"/usr/local/nginx/logs/nginx.pid\"\n    重启是建立在nginx服务需要启动\n    \n### nginx停止\n    # ./nginx -s stop \n    # ./nginx -s quit\n    \n    quit 是一个优雅的关闭方式，Nginx在退出前完成已经接受的连接请求\n    stop 是快速关闭，不管有没有正在处理的请求。\n    \n### 重新打开日志   \n    # ./nginx -s reopen   \n    \n### nginx检查配置文件\n    检查配置文件是否正确\n    第一种\n    进入nginx可执行程序的目录\n    # cd /usr/local/nginx/sbin/\n    # ./nginx -t\n    \n    第二种\n    # /usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.conf\n\n## Nginx信号控制\n    Nginx支持2种进程模型Single和Master-Worker\n    Single是单进程，一般不适用，\n    Master-Worker是主进程和工作进程模型运行，主进程对工作进程管理。\n    Nginx允许我们通过信号来控制主进程，用信号的方式可以达到不影响现有连接的目的。 \n\n### 信号类型\n    INT，TERM\t\t快速关闭信号\n    QUIT\t\t\t从容关闭信号\n    HUP\t\t\t\t从容重启信号，一般用于修改配置文件后，重启\n    USR1\t\t\t重读日志，一般用于日志的切割\n    USR2\t\t\t平滑升级信号\n    WINCH\t\t\t从容关闭旧进程\n\n","slug":"微服务API网关框架-2","published":1,"updated":"2018-12-19T09:00:08.672Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpuya68j000d9kujyrnjclmd","content":"<h1><span id=\"nginx\">Nginx</span></h1>\n<h2><span id=\"nginx命令\">Nginx命令</span></h2>\n<h3><span id=\"nginx启动\">nginx启动</span></h3>\n<pre><code>指令：nginx程序   -c   nginx配置文件\n# /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf\n</code></pre>\n<h3><span id=\"nginx重启\">nginx重启</span></h3>\n<pre><code>#cd /usr/local/nginx/sbin\n##重启\n# ./nginx -s reload   \n进入nginx可执行程序的目录\n# cd /usr/local/nginx/sbin/\n# ./nginx -s reload\nnginx: [error] invalid PID number &quot;&quot; in &quot;/usr/local/nginx/logs/nginx.pid&quot;\n重启是建立在nginx服务需要启动\n</code></pre>\n<h3><span id=\"nginx停止\">nginx停止</span></h3>\n<pre><code># ./nginx -s stop \n# ./nginx -s quit\n\nquit 是一个优雅的关闭方式，Nginx在退出前完成已经接受的连接请求\nstop 是快速关闭，不管有没有正在处理的请求。\n</code></pre>\n<h3><span id=\"重新打开日志\">重新打开日志</span></h3>\n<pre><code># ./nginx -s reopen   \n</code></pre>\n<h3><span id=\"nginx检查配置文件\">nginx检查配置文件</span></h3>\n<pre><code>检查配置文件是否正确\n第一种\n进入nginx可执行程序的目录\n# cd /usr/local/nginx/sbin/\n# ./nginx -t\n\n第二种\n# /usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.conf\n</code></pre>\n<h2><span id=\"nginx信号控制\">Nginx信号控制</span></h2>\n<pre><code>Nginx支持2种进程模型Single和Master-Worker\nSingle是单进程，一般不适用，\nMaster-Worker是主进程和工作进程模型运行，主进程对工作进程管理。\nNginx允许我们通过信号来控制主进程，用信号的方式可以达到不影响现有连接的目的。 \n</code></pre>\n<h3><span id=\"信号类型\">信号类型</span></h3>\n<pre><code>INT，TERM\t\t快速关闭信号\nQUIT\t\t\t从容关闭信号\nHUP\t\t\t\t从容重启信号，一般用于修改配置文件后，重启\nUSR1\t\t\t重读日志，一般用于日志的切割\nUSR2\t\t\t平滑升级信号\nWINCH\t\t\t从容关闭旧进程\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1>Nginx</h1>\n<h2>Nginx命令</h2>\n<h3>nginx启动</h3>\n<pre><code>指令：nginx程序   -c   nginx配置文件\n# /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf\n</code></pre>\n<h3>nginx重启</h3>\n<pre><code>#cd /usr/local/nginx/sbin\n##重启\n# ./nginx -s reload   \n进入nginx可执行程序的目录\n# cd /usr/local/nginx/sbin/\n# ./nginx -s reload\nnginx: [error] invalid PID number &quot;&quot; in &quot;/usr/local/nginx/logs/nginx.pid&quot;\n重启是建立在nginx服务需要启动\n</code></pre>\n<h3>nginx停止</h3>\n<pre><code># ./nginx -s stop \n# ./nginx -s quit\n\nquit 是一个优雅的关闭方式，Nginx在退出前完成已经接受的连接请求\nstop 是快速关闭，不管有没有正在处理的请求。\n</code></pre>\n<h3>重新打开日志</h3>\n<pre><code># ./nginx -s reopen   \n</code></pre>\n<h3>nginx检查配置文件</h3>\n<pre><code>检查配置文件是否正确\n第一种\n进入nginx可执行程序的目录\n# cd /usr/local/nginx/sbin/\n# ./nginx -t\n\n第二种\n# /usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.conf\n</code></pre>\n<h2>Nginx信号控制</h2>\n<pre><code>Nginx支持2种进程模型Single和Master-Worker\nSingle是单进程，一般不适用，\nMaster-Worker是主进程和工作进程模型运行，主进程对工作进程管理。\nNginx允许我们通过信号来控制主进程，用信号的方式可以达到不影响现有连接的目的。 \n</code></pre>\n<h3>信号类型</h3>\n<pre><code>INT，TERM\t\t快速关闭信号\nQUIT\t\t\t从容关闭信号\nHUP\t\t\t\t从容重启信号，一般用于修改配置文件后，重启\nUSR1\t\t\t重读日志，一般用于日志的切割\nUSR2\t\t\t平滑升级信号\nWINCH\t\t\t从容关闭旧进程\n</code></pre>\n"},{"title":"微服务API网关框架(1)--介绍","catalog":true,"date":"2018-12-07T06:27:21.000Z","subtitle":null,"header-img":"Demo.png","catagories":["微服务API网关"],"_content":"\n# 概念介绍\n    \n### 网关作用\n    统一入口\n    安全：黑名单、权限身份认证\n    限流：实现微服务访问流量计算，基于流量计算分析进行限流，可以定义多种限流规则。\n    缓存：数据缓存\n    日志：日志记录\n    监控：记录请求响应数据，api耗时分析，性能监控\n    重试：异常重试\n    熔断：降级 (防止服务雪崩)\n    \n### API网关\n    API网关是一个服务器，是系统的唯一入口。从面向对象设计的角度看，它与外观模式类似。API网关封装了系统内部架构，为每个客户端提供一个定制的API。它可能还具有其它职责，如身份验证、监控、负载均衡、缓存、请求分片与管理、静态响应处理。\n    API网关方式的核心要点是，所有的客户端和消费端都通过统一的网关接入微服务，在网关层处理所有的非业务功能。通常，网关也是提供REST/HTTP的访问API。服务端通过API-GW注册和管理服务。\n\n### API网关种类\n1. 单节点网关\n![单节点场景网关](单节点场景网关.png)\n2.多节点网关\n![多节点场景网关](多节点场景网关.png)\n\n#### API网关网关的价值\n    网关层对外部和内部进行了隔离，保障了后台服务的安全性。 \n    对外访问控制由网络层面转换成了运维层面，减少变更的流程和错误成本 \n    减少客户端与服务的耦合，服务可以独立发展。通过网关层来做映射。 \n    通过网关层聚合，减少外部访问的频次，提升访问效率。 \n    节约后端服务开发成本，减少上线风险。 \n    为服务熔断，灰度发布，线上测试提供简单方案。\n\n## 开源微服务项目\n    Dubbo\n    Spring Cloud\n    \n## 开源网关项目\n    Tyk：Tyk是一个开放源码的API网关，它是快速、可扩展和现代的。Tyk提供了一个API管理平台，其中包括API网关、API分析、开发人员门户和API管理面板。Try 是一个基于Go实现的网关服务。\n    Kong：Kong是一个可扩展的开放源码API Layer(也称为API网关或API中间件)。Kong 在任何RESTful API的前面运行，通过插件扩展，它提供了超越核心平台的额外功能和服务。\n    Orange：和Kong类似也是基于OpenResty的一个API网关程序，是由国人开发的。\n    Netflix zuul：Zuul是一种提供动态路由、监视、弹性、安全性等功能的边缘服务。Zuul是Netflix出品的一个基于JVM路由和服务端的负载均衡器。\n    apiaxle: Nodejs 实现的一个 API 网关。\n    api-umbrella: Ruby 实现的一个 API 网关。\n\n## 网关技术选型\n    kong \n        包含功能\n        (\n            统一入口\n            安全：黑名单、权限身份认证\n            限流：实现微服务访问流量计算，基于流量计算分析进行限流，可以定义多种限流规则。\n            缓存：数据缓存\n            日志：日志记录\n            监控：记录请求响应数据，api耗时分析，性能监控\n        )\n    Zuul\n        包含功能\n        (\n            重试\n            熔断\n        )\n        \n    kong 是基于Nginx + Lua模式开发出来的，我们将要自己搭建一个属于自己的网关，所以采用Nginx + Lua，真实部署的时候可以\n    采用kong+zuul的模式进行实际部署，因为自己搭建的需要考虑的问题有很多，当然自己构建的话，灵活性和个性化设置也是可以控制的，\n    这个需要看看团队的实际需要，客观进行评估.\n       \n### 架构实现图\n![架构](架构.png)\n![架构2](架构2.png)\n![架构3](架构3.png)\n\n### 项目运行环境\n    CentOS\n\n### Nginx安装\n    1、Nginx下载：nginx-1.13.0.tar.gz，下载到：/opt/softwares/\n        $ wget http://nginx.org/download/nginx-1.13.0.tar.gz\n    2、Nginx解压安装：\n        $ tar -zxvf nginx-1.13.0.tar.gz -C ./\n    3、预先安装(nginx所需要的运行库)\n        $ yum -y install gcc gcc-c++ ncurses-devel perl pcre pcre-devel zlib gzip zlib-devel\n    4、Nginx编译\n        $ ./configure --prefix=/usr/local/nginx\n    5、安装Nginx：\n        安装命令：make & make install\n    6、查看安装路径\n        $ cd /usr/local/nginx\n        $ ll\n        \n        // 文件夹路径解读\n        conf 存放配置文件\n        html 网页文件\n        logs 存放日志\n        sbin   shell启动、停止等脚本\n    7、启动nginx\n        $ cd sbin\n        $ ./nginx\n    8、浏览器，访问ip地址，默认80端口\n        http://127.0.0.1\n    9、停止nginx\n        // 查询nginx的状态\n        $ ps -ef | grep nginx\n        执行命令：$ kill –INT 进程号\n        $ kill -INT 3844\n    \n        $ ./nginx -s stop\n    \n    10、重新读取配置文件\n        $ nginx -s reload\n    \n    11、检查配置文件是否正确\n    $ ./nginx -t\n    \n    问题报错：[error] invalid PID number \"\" in \"/usr/local/nginx/logs/nginx.pid\"\n    \n    解决方案:\n    // 注意: -c 带的文件路径必须是绝对路径，相对路径是不行的\n    # /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf\n        -c的命令是指定配置文件位置\n\n## 代理\n\n### 正向代理\n    用户要访问服务器C，但因为网络原因无法访问，但是服务器A可以访问服务器C，这样可以把服务器A设置为正向代理服务器\n    由服务器A去请求服务器C，然后服务器A把数据返回给客户\n![正向代理](正向代理.png)\n\n### 反向代理\n    用户需要访问一些服务器应用，但对方不想把服务器应用地址暴露给用户，这样可以确保安全。那客户如果访问，可以通过反向代理\n    服务器，用户只需要知道反向代理服务器地址就可以了，最后反向代理服务器去访问服务器的应用\n![反向代理](反向代理.png)    \n\n### 总结: 正向代理与反向代理的区别\n    (1)正向代理是需要在用户的电脑上，配置正向服务代理器的；而反向代理则不需要，因为用户是直接访问反向代理器的\n    (2)正向代理的应用场景是用户是知道目标服务器地址，如:http://www.baidu.com,但是不能直接的访问，那么就需要在电脑配置一个正向\n    代理服务器，用户再次访问的地址就是www.google.com\n      而反向代理的应用场景是，用户本来就是不知道目标服务器的地址，而是由平台方提供一个反向代理服务器的地址，用户直接访问反向代理服务器的地址就行了，www.a.com\n      不管目标服务器有多少，用户是不需要关心的，只要访问反向代理服务器就OK，由反向代理服务器去解析访问目标服务器\n    (3)反向代理，极大的保护了应用的安全性，而且此结构能够很好的搭建负载均衡  \n\n","source":"_posts/微服务API网关框架-1.md","raw":"---\ntitle: 微服务API网关框架(1)--介绍\ncatalog: true\ndate: 2018-12-07 14:27:21\nsubtitle:\nheader-img: \"Demo.png\"\ntags:\n- 微服务API网关\ncatagories:\n- 微服务API网关\n---\n\n# 概念介绍\n    \n### 网关作用\n    统一入口\n    安全：黑名单、权限身份认证\n    限流：实现微服务访问流量计算，基于流量计算分析进行限流，可以定义多种限流规则。\n    缓存：数据缓存\n    日志：日志记录\n    监控：记录请求响应数据，api耗时分析，性能监控\n    重试：异常重试\n    熔断：降级 (防止服务雪崩)\n    \n### API网关\n    API网关是一个服务器，是系统的唯一入口。从面向对象设计的角度看，它与外观模式类似。API网关封装了系统内部架构，为每个客户端提供一个定制的API。它可能还具有其它职责，如身份验证、监控、负载均衡、缓存、请求分片与管理、静态响应处理。\n    API网关方式的核心要点是，所有的客户端和消费端都通过统一的网关接入微服务，在网关层处理所有的非业务功能。通常，网关也是提供REST/HTTP的访问API。服务端通过API-GW注册和管理服务。\n\n### API网关种类\n1. 单节点网关\n![单节点场景网关](单节点场景网关.png)\n2.多节点网关\n![多节点场景网关](多节点场景网关.png)\n\n#### API网关网关的价值\n    网关层对外部和内部进行了隔离，保障了后台服务的安全性。 \n    对外访问控制由网络层面转换成了运维层面，减少变更的流程和错误成本 \n    减少客户端与服务的耦合，服务可以独立发展。通过网关层来做映射。 \n    通过网关层聚合，减少外部访问的频次，提升访问效率。 \n    节约后端服务开发成本，减少上线风险。 \n    为服务熔断，灰度发布，线上测试提供简单方案。\n\n## 开源微服务项目\n    Dubbo\n    Spring Cloud\n    \n## 开源网关项目\n    Tyk：Tyk是一个开放源码的API网关，它是快速、可扩展和现代的。Tyk提供了一个API管理平台，其中包括API网关、API分析、开发人员门户和API管理面板。Try 是一个基于Go实现的网关服务。\n    Kong：Kong是一个可扩展的开放源码API Layer(也称为API网关或API中间件)。Kong 在任何RESTful API的前面运行，通过插件扩展，它提供了超越核心平台的额外功能和服务。\n    Orange：和Kong类似也是基于OpenResty的一个API网关程序，是由国人开发的。\n    Netflix zuul：Zuul是一种提供动态路由、监视、弹性、安全性等功能的边缘服务。Zuul是Netflix出品的一个基于JVM路由和服务端的负载均衡器。\n    apiaxle: Nodejs 实现的一个 API 网关。\n    api-umbrella: Ruby 实现的一个 API 网关。\n\n## 网关技术选型\n    kong \n        包含功能\n        (\n            统一入口\n            安全：黑名单、权限身份认证\n            限流：实现微服务访问流量计算，基于流量计算分析进行限流，可以定义多种限流规则。\n            缓存：数据缓存\n            日志：日志记录\n            监控：记录请求响应数据，api耗时分析，性能监控\n        )\n    Zuul\n        包含功能\n        (\n            重试\n            熔断\n        )\n        \n    kong 是基于Nginx + Lua模式开发出来的，我们将要自己搭建一个属于自己的网关，所以采用Nginx + Lua，真实部署的时候可以\n    采用kong+zuul的模式进行实际部署，因为自己搭建的需要考虑的问题有很多，当然自己构建的话，灵活性和个性化设置也是可以控制的，\n    这个需要看看团队的实际需要，客观进行评估.\n       \n### 架构实现图\n![架构](架构.png)\n![架构2](架构2.png)\n![架构3](架构3.png)\n\n### 项目运行环境\n    CentOS\n\n### Nginx安装\n    1、Nginx下载：nginx-1.13.0.tar.gz，下载到：/opt/softwares/\n        $ wget http://nginx.org/download/nginx-1.13.0.tar.gz\n    2、Nginx解压安装：\n        $ tar -zxvf nginx-1.13.0.tar.gz -C ./\n    3、预先安装(nginx所需要的运行库)\n        $ yum -y install gcc gcc-c++ ncurses-devel perl pcre pcre-devel zlib gzip zlib-devel\n    4、Nginx编译\n        $ ./configure --prefix=/usr/local/nginx\n    5、安装Nginx：\n        安装命令：make & make install\n    6、查看安装路径\n        $ cd /usr/local/nginx\n        $ ll\n        \n        // 文件夹路径解读\n        conf 存放配置文件\n        html 网页文件\n        logs 存放日志\n        sbin   shell启动、停止等脚本\n    7、启动nginx\n        $ cd sbin\n        $ ./nginx\n    8、浏览器，访问ip地址，默认80端口\n        http://127.0.0.1\n    9、停止nginx\n        // 查询nginx的状态\n        $ ps -ef | grep nginx\n        执行命令：$ kill –INT 进程号\n        $ kill -INT 3844\n    \n        $ ./nginx -s stop\n    \n    10、重新读取配置文件\n        $ nginx -s reload\n    \n    11、检查配置文件是否正确\n    $ ./nginx -t\n    \n    问题报错：[error] invalid PID number \"\" in \"/usr/local/nginx/logs/nginx.pid\"\n    \n    解决方案:\n    // 注意: -c 带的文件路径必须是绝对路径，相对路径是不行的\n    # /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf\n        -c的命令是指定配置文件位置\n\n## 代理\n\n### 正向代理\n    用户要访问服务器C，但因为网络原因无法访问，但是服务器A可以访问服务器C，这样可以把服务器A设置为正向代理服务器\n    由服务器A去请求服务器C，然后服务器A把数据返回给客户\n![正向代理](正向代理.png)\n\n### 反向代理\n    用户需要访问一些服务器应用，但对方不想把服务器应用地址暴露给用户，这样可以确保安全。那客户如果访问，可以通过反向代理\n    服务器，用户只需要知道反向代理服务器地址就可以了，最后反向代理服务器去访问服务器的应用\n![反向代理](反向代理.png)    \n\n### 总结: 正向代理与反向代理的区别\n    (1)正向代理是需要在用户的电脑上，配置正向服务代理器的；而反向代理则不需要，因为用户是直接访问反向代理器的\n    (2)正向代理的应用场景是用户是知道目标服务器地址，如:http://www.baidu.com,但是不能直接的访问，那么就需要在电脑配置一个正向\n    代理服务器，用户再次访问的地址就是www.google.com\n      而反向代理的应用场景是，用户本来就是不知道目标服务器的地址，而是由平台方提供一个反向代理服务器的地址，用户直接访问反向代理服务器的地址就行了，www.a.com\n      不管目标服务器有多少，用户是不需要关心的，只要访问反向代理服务器就OK，由反向代理服务器去解析访问目标服务器\n    (3)反向代理，极大的保护了应用的安全性，而且此结构能够很好的搭建负载均衡  \n\n","slug":"微服务API网关框架-1","published":1,"updated":"2018-12-19T08:45:39.151Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpuya68m000e9kuj0wb0cbu4","content":"<h1><span id=\"概念介绍\">概念介绍</span></h1>\n<h3><span id=\"网关作用\">网关作用</span></h3>\n<pre><code>统一入口\n安全：黑名单、权限身份认证\n限流：实现微服务访问流量计算，基于流量计算分析进行限流，可以定义多种限流规则。\n缓存：数据缓存\n日志：日志记录\n监控：记录请求响应数据，api耗时分析，性能监控\n重试：异常重试\n熔断：降级 (防止服务雪崩)\n</code></pre>\n<h3><span id=\"api网关\">API网关</span></h3>\n<pre><code>API网关是一个服务器，是系统的唯一入口。从面向对象设计的角度看，它与外观模式类似。API网关封装了系统内部架构，为每个客户端提供一个定制的API。它可能还具有其它职责，如身份验证、监控、负载均衡、缓存、请求分片与管理、静态响应处理。\nAPI网关方式的核心要点是，所有的客户端和消费端都通过统一的网关接入微服务，在网关层处理所有的非业务功能。通常，网关也是提供REST/HTTP的访问API。服务端通过API-GW注册和管理服务。\n</code></pre>\n<h3><span id=\"api网关种类\">API网关种类</span></h3>\n<ol>\n<li>单节点网关<br>\n<img src=\"%E5%8D%95%E8%8A%82%E7%82%B9%E5%9C%BA%E6%99%AF%E7%BD%91%E5%85%B3.png\" alt=\"单节点场景网关\"><br>\n2.多节点网关<br>\n<img src=\"%E5%A4%9A%E8%8A%82%E7%82%B9%E5%9C%BA%E6%99%AF%E7%BD%91%E5%85%B3.png\" alt=\"多节点场景网关\"></li>\n</ol>\n<h4><span id=\"api网关网关的价值\">API网关网关的价值</span></h4>\n<pre><code>网关层对外部和内部进行了隔离，保障了后台服务的安全性。 \n对外访问控制由网络层面转换成了运维层面，减少变更的流程和错误成本 \n减少客户端与服务的耦合，服务可以独立发展。通过网关层来做映射。 \n通过网关层聚合，减少外部访问的频次，提升访问效率。 \n节约后端服务开发成本，减少上线风险。 \n为服务熔断，灰度发布，线上测试提供简单方案。\n</code></pre>\n<h2><span id=\"开源微服务项目\">开源微服务项目</span></h2>\n<pre><code>Dubbo\nSpring Cloud\n</code></pre>\n<h2><span id=\"开源网关项目\">开源网关项目</span></h2>\n<pre><code>Tyk：Tyk是一个开放源码的API网关，它是快速、可扩展和现代的。Tyk提供了一个API管理平台，其中包括API网关、API分析、开发人员门户和API管理面板。Try 是一个基于Go实现的网关服务。\nKong：Kong是一个可扩展的开放源码API Layer(也称为API网关或API中间件)。Kong 在任何RESTful API的前面运行，通过插件扩展，它提供了超越核心平台的额外功能和服务。\nOrange：和Kong类似也是基于OpenResty的一个API网关程序，是由国人开发的。\nNetflix zuul：Zuul是一种提供动态路由、监视、弹性、安全性等功能的边缘服务。Zuul是Netflix出品的一个基于JVM路由和服务端的负载均衡器。\napiaxle: Nodejs 实现的一个 API 网关。\napi-umbrella: Ruby 实现的一个 API 网关。\n</code></pre>\n<h2><span id=\"网关技术选型\">网关技术选型</span></h2>\n<pre><code>kong \n    包含功能\n    (\n        统一入口\n        安全：黑名单、权限身份认证\n        限流：实现微服务访问流量计算，基于流量计算分析进行限流，可以定义多种限流规则。\n        缓存：数据缓存\n        日志：日志记录\n        监控：记录请求响应数据，api耗时分析，性能监控\n    )\nZuul\n    包含功能\n    (\n        重试\n        熔断\n    )\n    \nkong 是基于Nginx + Lua模式开发出来的，我们将要自己搭建一个属于自己的网关，所以采用Nginx + Lua，真实部署的时候可以\n采用kong+zuul的模式进行实际部署，因为自己搭建的需要考虑的问题有很多，当然自己构建的话，灵活性和个性化设置也是可以控制的，\n这个需要看看团队的实际需要，客观进行评估.\n</code></pre>\n<h3><span id=\"架构实现图\">架构实现图</span></h3>\n<p><img src=\"%E6%9E%B6%E6%9E%84.png\" alt=\"架构\"><br>\n<img src=\"%E6%9E%B6%E6%9E%842.png\" alt=\"架构2\"><br>\n<img src=\"%E6%9E%B6%E6%9E%843.png\" alt=\"架构3\"></p>\n<h3><span id=\"项目运行环境\">项目运行环境</span></h3>\n<pre><code>CentOS\n</code></pre>\n<h3><span id=\"nginx安装\">Nginx安装</span></h3>\n<pre><code>1、Nginx下载：nginx-1.13.0.tar.gz，下载到：/opt/softwares/\n    $ wget http://nginx.org/download/nginx-1.13.0.tar.gz\n2、Nginx解压安装：\n    $ tar -zxvf nginx-1.13.0.tar.gz -C ./\n3、预先安装(nginx所需要的运行库)\n    $ yum -y install gcc gcc-c++ ncurses-devel perl pcre pcre-devel zlib gzip zlib-devel\n4、Nginx编译\n    $ ./configure --prefix=/usr/local/nginx\n5、安装Nginx：\n    安装命令：make &amp; make install\n6、查看安装路径\n    $ cd /usr/local/nginx\n    $ ll\n    \n    // 文件夹路径解读\n    conf 存放配置文件\n    html 网页文件\n    logs 存放日志\n    sbin   shell启动、停止等脚本\n7、启动nginx\n    $ cd sbin\n    $ ./nginx\n8、浏览器，访问ip地址，默认80端口\n    http://127.0.0.1\n9、停止nginx\n    // 查询nginx的状态\n    $ ps -ef | grep nginx\n    执行命令：$ kill –INT 进程号\n    $ kill -INT 3844\n\n    $ ./nginx -s stop\n\n10、重新读取配置文件\n    $ nginx -s reload\n\n11、检查配置文件是否正确\n$ ./nginx -t\n\n问题报错：[error] invalid PID number &quot;&quot; in &quot;/usr/local/nginx/logs/nginx.pid&quot;\n\n解决方案:\n// 注意: -c 带的文件路径必须是绝对路径，相对路径是不行的\n# /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf\n    -c的命令是指定配置文件位置\n</code></pre>\n<h2><span id=\"代理\">代理</span></h2>\n<h3><span id=\"正向代理\">正向代理</span></h3>\n<pre><code>用户要访问服务器C，但因为网络原因无法访问，但是服务器A可以访问服务器C，这样可以把服务器A设置为正向代理服务器\n由服务器A去请求服务器C，然后服务器A把数据返回给客户\n</code></pre>\n<p><img src=\"%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86.png\" alt=\"正向代理\"></p>\n<h3><span id=\"反向代理\">反向代理</span></h3>\n<pre><code>用户需要访问一些服务器应用，但对方不想把服务器应用地址暴露给用户，这样可以确保安全。那客户如果访问，可以通过反向代理\n服务器，用户只需要知道反向代理服务器地址就可以了，最后反向代理服务器去访问服务器的应用\n</code></pre>\n<p><img src=\"%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86.png\" alt=\"反向代理\"></p>\n<h3><span id=\"总结-正向代理与反向代理的区别\">总结: 正向代理与反向代理的区别</span></h3>\n<pre><code>(1)正向代理是需要在用户的电脑上，配置正向服务代理器的；而反向代理则不需要，因为用户是直接访问反向代理器的\n(2)正向代理的应用场景是用户是知道目标服务器地址，如:http://www.baidu.com,但是不能直接的访问，那么就需要在电脑配置一个正向\n代理服务器，用户再次访问的地址就是www.google.com\n  而反向代理的应用场景是，用户本来就是不知道目标服务器的地址，而是由平台方提供一个反向代理服务器的地址，用户直接访问反向代理服务器的地址就行了，www.a.com\n  不管目标服务器有多少，用户是不需要关心的，只要访问反向代理服务器就OK，由反向代理服务器去解析访问目标服务器\n(3)反向代理，极大的保护了应用的安全性，而且此结构能够很好的搭建负载均衡\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1>概念介绍</h1>\n<h3>网关作用</h3>\n<pre><code>统一入口\n安全：黑名单、权限身份认证\n限流：实现微服务访问流量计算，基于流量计算分析进行限流，可以定义多种限流规则。\n缓存：数据缓存\n日志：日志记录\n监控：记录请求响应数据，api耗时分析，性能监控\n重试：异常重试\n熔断：降级 (防止服务雪崩)\n</code></pre>\n<h3>API网关</h3>\n<pre><code>API网关是一个服务器，是系统的唯一入口。从面向对象设计的角度看，它与外观模式类似。API网关封装了系统内部架构，为每个客户端提供一个定制的API。它可能还具有其它职责，如身份验证、监控、负载均衡、缓存、请求分片与管理、静态响应处理。\nAPI网关方式的核心要点是，所有的客户端和消费端都通过统一的网关接入微服务，在网关层处理所有的非业务功能。通常，网关也是提供REST/HTTP的访问API。服务端通过API-GW注册和管理服务。\n</code></pre>\n<h3>API网关种类</h3>\n<ol>\n<li>单节点网关<br>\n<img src=\"%E5%8D%95%E8%8A%82%E7%82%B9%E5%9C%BA%E6%99%AF%E7%BD%91%E5%85%B3.png\" alt=\"单节点场景网关\"><br>\n2.多节点网关<br>\n<img src=\"%E5%A4%9A%E8%8A%82%E7%82%B9%E5%9C%BA%E6%99%AF%E7%BD%91%E5%85%B3.png\" alt=\"多节点场景网关\"></li>\n</ol>\n<h4>API网关网关的价值</h4>\n<pre><code>网关层对外部和内部进行了隔离，保障了后台服务的安全性。 \n对外访问控制由网络层面转换成了运维层面，减少变更的流程和错误成本 \n减少客户端与服务的耦合，服务可以独立发展。通过网关层来做映射。 \n通过网关层聚合，减少外部访问的频次，提升访问效率。 \n节约后端服务开发成本，减少上线风险。 \n为服务熔断，灰度发布，线上测试提供简单方案。\n</code></pre>\n<h2>开源微服务项目</h2>\n<pre><code>Dubbo\nSpring Cloud\n</code></pre>\n<h2>开源网关项目</h2>\n<pre><code>Tyk：Tyk是一个开放源码的API网关，它是快速、可扩展和现代的。Tyk提供了一个API管理平台，其中包括API网关、API分析、开发人员门户和API管理面板。Try 是一个基于Go实现的网关服务。\nKong：Kong是一个可扩展的开放源码API Layer(也称为API网关或API中间件)。Kong 在任何RESTful API的前面运行，通过插件扩展，它提供了超越核心平台的额外功能和服务。\nOrange：和Kong类似也是基于OpenResty的一个API网关程序，是由国人开发的。\nNetflix zuul：Zuul是一种提供动态路由、监视、弹性、安全性等功能的边缘服务。Zuul是Netflix出品的一个基于JVM路由和服务端的负载均衡器。\napiaxle: Nodejs 实现的一个 API 网关。\napi-umbrella: Ruby 实现的一个 API 网关。\n</code></pre>\n<h2>网关技术选型</h2>\n<pre><code>kong \n    包含功能\n    (\n        统一入口\n        安全：黑名单、权限身份认证\n        限流：实现微服务访问流量计算，基于流量计算分析进行限流，可以定义多种限流规则。\n        缓存：数据缓存\n        日志：日志记录\n        监控：记录请求响应数据，api耗时分析，性能监控\n    )\nZuul\n    包含功能\n    (\n        重试\n        熔断\n    )\n    \nkong 是基于Nginx + Lua模式开发出来的，我们将要自己搭建一个属于自己的网关，所以采用Nginx + Lua，真实部署的时候可以\n采用kong+zuul的模式进行实际部署，因为自己搭建的需要考虑的问题有很多，当然自己构建的话，灵活性和个性化设置也是可以控制的，\n这个需要看看团队的实际需要，客观进行评估.\n</code></pre>\n<h3>架构实现图</h3>\n<p><img src=\"%E6%9E%B6%E6%9E%84.png\" alt=\"架构\"><br>\n<img src=\"%E6%9E%B6%E6%9E%842.png\" alt=\"架构2\"><br>\n<img src=\"%E6%9E%B6%E6%9E%843.png\" alt=\"架构3\"></p>\n<h3>项目运行环境</h3>\n<pre><code>CentOS\n</code></pre>\n<h3>Nginx安装</h3>\n<pre><code>1、Nginx下载：nginx-1.13.0.tar.gz，下载到：/opt/softwares/\n    $ wget http://nginx.org/download/nginx-1.13.0.tar.gz\n2、Nginx解压安装：\n    $ tar -zxvf nginx-1.13.0.tar.gz -C ./\n3、预先安装(nginx所需要的运行库)\n    $ yum -y install gcc gcc-c++ ncurses-devel perl pcre pcre-devel zlib gzip zlib-devel\n4、Nginx编译\n    $ ./configure --prefix=/usr/local/nginx\n5、安装Nginx：\n    安装命令：make &amp; make install\n6、查看安装路径\n    $ cd /usr/local/nginx\n    $ ll\n    \n    // 文件夹路径解读\n    conf 存放配置文件\n    html 网页文件\n    logs 存放日志\n    sbin   shell启动、停止等脚本\n7、启动nginx\n    $ cd sbin\n    $ ./nginx\n8、浏览器，访问ip地址，默认80端口\n    http://127.0.0.1\n9、停止nginx\n    // 查询nginx的状态\n    $ ps -ef | grep nginx\n    执行命令：$ kill –INT 进程号\n    $ kill -INT 3844\n\n    $ ./nginx -s stop\n\n10、重新读取配置文件\n    $ nginx -s reload\n\n11、检查配置文件是否正确\n$ ./nginx -t\n\n问题报错：[error] invalid PID number &quot;&quot; in &quot;/usr/local/nginx/logs/nginx.pid&quot;\n\n解决方案:\n// 注意: -c 带的文件路径必须是绝对路径，相对路径是不行的\n# /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf\n    -c的命令是指定配置文件位置\n</code></pre>\n<h2>代理</h2>\n<h3>正向代理</h3>\n<pre><code>用户要访问服务器C，但因为网络原因无法访问，但是服务器A可以访问服务器C，这样可以把服务器A设置为正向代理服务器\n由服务器A去请求服务器C，然后服务器A把数据返回给客户\n</code></pre>\n<p><img src=\"%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86.png\" alt=\"正向代理\"></p>\n<h3>反向代理</h3>\n<pre><code>用户需要访问一些服务器应用，但对方不想把服务器应用地址暴露给用户，这样可以确保安全。那客户如果访问，可以通过反向代理\n服务器，用户只需要知道反向代理服务器地址就可以了，最后反向代理服务器去访问服务器的应用\n</code></pre>\n<p><img src=\"%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86.png\" alt=\"反向代理\"></p>\n<h3>总结: 正向代理与反向代理的区别</h3>\n<pre><code>(1)正向代理是需要在用户的电脑上，配置正向服务代理器的；而反向代理则不需要，因为用户是直接访问反向代理器的\n(2)正向代理的应用场景是用户是知道目标服务器地址，如:http://www.baidu.com,但是不能直接的访问，那么就需要在电脑配置一个正向\n代理服务器，用户再次访问的地址就是www.google.com\n  而反向代理的应用场景是，用户本来就是不知道目标服务器的地址，而是由平台方提供一个反向代理服务器的地址，用户直接访问反向代理服务器的地址就行了，www.a.com\n  不管目标服务器有多少，用户是不需要关心的，只要访问反向代理服务器就OK，由反向代理服务器去解析访问目标服务器\n(3)反向代理，极大的保护了应用的安全性，而且此结构能够很好的搭建负载均衡\n</code></pre>\n"},{"title":"gRPC使用 -- Golang版示例","catalog":true,"date":"2018-11-12T06:00:00.000Z","subtitle":null,"header-img":null,"catagories":["Hexo"],"_content":"# RPC入门\n\n## RPC框架原理\n```\n    RPC框架的目的就是让远程服务调用更加简单,透明，RPC框架负责屏蔽底层的传输方式(TCP或者UDP),\n    序列化方式(XML/JSON/二进制)和通信细节。服务调用者可以向本地接口一样调用远程的服务提供者，\n    而不需要关心底层通信细节和调用过程.\n```\n![rpc原理图](rpc原理图.png)\n\n## gRPC\n\n### gRPC简介\n```\n    gRPC 是一个高性能、开源和通用的 RPC 框架，面向服务端和移动端,基于HTTP/2设计.\n```\n![gRPC调用示例](gRPC调用示例.png)\n\n### gRPC特点\n![gRPC特点](gRPC特点.png)\n\n### Golang gRPC 示例\n\n#### 1、安装gRPC runtime\n```\ngo get google.golang.org/grpc\n```\n\n#### 2、protocal buffer安装\n```\n从https://github.com/google/protobuf/releases下载安装包，\n例如：protobuf-cpp-3.0.0-beta-3.zip，解压后\n./configure\nmake && make install\n再添加环境变量：export LD_LIBRARY_PATH=/usr/local/lib，之后protoc命令即可运行    \n```\n\n#### 3、安装GoLang protoc 插件\n```\ngo get -a github.com/golang/protobuf/protoc-gen-go\n```\n\n#### 4、定义service\n一个RPC service就是一个能够通过参数和返回值进行远程调用的method，我们可以简单地将它理解成一个函数。因为gRPC是通过将数据编码成protocal buffer来实现传输的。因此，我们通过protocal buffers interface definitioin language(IDL)来定义service method，同时将参数和返回值也定义成protocal buffer message类型。具体实现如下所示，包含下面代码的文件叫helloworld.proto：\n```\nsyntax = \"proto3\";\n \noption java_package = \"io.grpc.examples\";\n \npackage helloworld;\n \n// The greeter service definition.\nservice Greeter {\n  // Sends a greeting\n  rpc SayHello (HelloRequest) returns (HelloReply) {}\n}\n \n// The request message containing the user's name.\nmessage HelloRequest {\n  string name = 1;\n}\n \n// The response message containing the greetings\nmessage HelloReply {\n  string message = 1;\n}\n```\n\n#### 5.生成Golang通用代码\n```\n接着，根据上述定义的service，我们可以利用protocal buffer compiler ，\n即protoc生成相应的服务器端和客户端的GoLang代码。生成的代码中包含了客户端能够进行RPC的方法以及服务器端需要进行实现的接口。\n假设现在所在的目录是$GOPATH/src/helloworld/helloworld，我们将通过如下命令生成gRPC对应的GoLang代码：\nprotoc -I ./ helloworld.proto --go_out=plugins=grpc:.\n```\n\n#### 6.生成相关的RPC的客户端和服务端\n在目录$GOPATH/src/helloworld/下创建server.go 和client.go，分别用于服务器和客户端的实现\n\n##### 服务端代码\n```\npackage main\n \n// server.go\n \nimport (\n    \"log\"\n    \"net\"\n \n    \"golang.org/x/net/context\"\n    \"google.golang.org/grpc\"\n    pb \"helloworld/helloworld\"\n)\n \nconst (\n    port = \":50051\"\n)\n \ntype server struct {}\n \nfunc (s *server) SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloReply, error) {\n    return &pb.HelloReply{Message: \"Hello \" + in.Name}, nil\n}\n \nfunc main() {\n    lis, err := net.Listen(\"tcp\", port)\n    if err != nil {\n        log.Fatal(\"failed to listen: %v\", err)\n    }\n    s := grpc.NewServer()\n    pb.RegisterGreeterServer(s, &server{})\n    s.Serve(lis)\n}\n```\n\n##### 客户端代码\n```\npackage main\n \n//client.go\n \nimport (\n    \"log\"\n    \"os\"\n \n    \"golang.org/x/net/context\"\n    \"google.golang.org/grpc\"\n    pb \"helloworld/helloworld\"\n)\n \nconst (\n    address     = \"localhost:50051\"\n    defaultName = \"world\"\n)\n \nfunc main() {\n    conn, err := grpc.Dial(address, grpc.WithInsecure())\n    if err != nil {\n        log.Fatal(\"did not connect: %v\", err)\n    }\n    defer conn.Close()\n    c := pb.NewGreeterClient(conn)\n \n    name := defaultName\n    if len(os.Args) >1 {\n        name = os.Args[1]\n    }\n    r, err := c.SayHello(context.Background(), &pb.HelloRequest{Name: name})\n    if err != nil {\n        log.Fatal(\"could not greet: %v\", err)\n    }\n    log.Printf(\"Greeting: %s\", r.Message)\n}\n```\n这里需要注意的是包pb是我们之前生成的helloworld.pb.go所在的包，\n并非必须如上述代码所示在$GOPATH/src/helloworld/helloworld目录下\n\n#### 7.运行示例\n```\ngo run server.go\ngo run client.go\n```\n","source":"_posts/基于Golang的gRPC使用笔记1.md","raw":"---\ntitle: gRPC使用 -- Golang版示例\ncatalog: true\ndate: 2018-11-12 14:00:00\nsubtitle:\nheader-img:\ntags:\n- gRPC\n- golang\ncatagories:\n- Hexo\n---\n# RPC入门\n\n## RPC框架原理\n```\n    RPC框架的目的就是让远程服务调用更加简单,透明，RPC框架负责屏蔽底层的传输方式(TCP或者UDP),\n    序列化方式(XML/JSON/二进制)和通信细节。服务调用者可以向本地接口一样调用远程的服务提供者，\n    而不需要关心底层通信细节和调用过程.\n```\n![rpc原理图](rpc原理图.png)\n\n## gRPC\n\n### gRPC简介\n```\n    gRPC 是一个高性能、开源和通用的 RPC 框架，面向服务端和移动端,基于HTTP/2设计.\n```\n![gRPC调用示例](gRPC调用示例.png)\n\n### gRPC特点\n![gRPC特点](gRPC特点.png)\n\n### Golang gRPC 示例\n\n#### 1、安装gRPC runtime\n```\ngo get google.golang.org/grpc\n```\n\n#### 2、protocal buffer安装\n```\n从https://github.com/google/protobuf/releases下载安装包，\n例如：protobuf-cpp-3.0.0-beta-3.zip，解压后\n./configure\nmake && make install\n再添加环境变量：export LD_LIBRARY_PATH=/usr/local/lib，之后protoc命令即可运行    \n```\n\n#### 3、安装GoLang protoc 插件\n```\ngo get -a github.com/golang/protobuf/protoc-gen-go\n```\n\n#### 4、定义service\n一个RPC service就是一个能够通过参数和返回值进行远程调用的method，我们可以简单地将它理解成一个函数。因为gRPC是通过将数据编码成protocal buffer来实现传输的。因此，我们通过protocal buffers interface definitioin language(IDL)来定义service method，同时将参数和返回值也定义成protocal buffer message类型。具体实现如下所示，包含下面代码的文件叫helloworld.proto：\n```\nsyntax = \"proto3\";\n \noption java_package = \"io.grpc.examples\";\n \npackage helloworld;\n \n// The greeter service definition.\nservice Greeter {\n  // Sends a greeting\n  rpc SayHello (HelloRequest) returns (HelloReply) {}\n}\n \n// The request message containing the user's name.\nmessage HelloRequest {\n  string name = 1;\n}\n \n// The response message containing the greetings\nmessage HelloReply {\n  string message = 1;\n}\n```\n\n#### 5.生成Golang通用代码\n```\n接着，根据上述定义的service，我们可以利用protocal buffer compiler ，\n即protoc生成相应的服务器端和客户端的GoLang代码。生成的代码中包含了客户端能够进行RPC的方法以及服务器端需要进行实现的接口。\n假设现在所在的目录是$GOPATH/src/helloworld/helloworld，我们将通过如下命令生成gRPC对应的GoLang代码：\nprotoc -I ./ helloworld.proto --go_out=plugins=grpc:.\n```\n\n#### 6.生成相关的RPC的客户端和服务端\n在目录$GOPATH/src/helloworld/下创建server.go 和client.go，分别用于服务器和客户端的实现\n\n##### 服务端代码\n```\npackage main\n \n// server.go\n \nimport (\n    \"log\"\n    \"net\"\n \n    \"golang.org/x/net/context\"\n    \"google.golang.org/grpc\"\n    pb \"helloworld/helloworld\"\n)\n \nconst (\n    port = \":50051\"\n)\n \ntype server struct {}\n \nfunc (s *server) SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloReply, error) {\n    return &pb.HelloReply{Message: \"Hello \" + in.Name}, nil\n}\n \nfunc main() {\n    lis, err := net.Listen(\"tcp\", port)\n    if err != nil {\n        log.Fatal(\"failed to listen: %v\", err)\n    }\n    s := grpc.NewServer()\n    pb.RegisterGreeterServer(s, &server{})\n    s.Serve(lis)\n}\n```\n\n##### 客户端代码\n```\npackage main\n \n//client.go\n \nimport (\n    \"log\"\n    \"os\"\n \n    \"golang.org/x/net/context\"\n    \"google.golang.org/grpc\"\n    pb \"helloworld/helloworld\"\n)\n \nconst (\n    address     = \"localhost:50051\"\n    defaultName = \"world\"\n)\n \nfunc main() {\n    conn, err := grpc.Dial(address, grpc.WithInsecure())\n    if err != nil {\n        log.Fatal(\"did not connect: %v\", err)\n    }\n    defer conn.Close()\n    c := pb.NewGreeterClient(conn)\n \n    name := defaultName\n    if len(os.Args) >1 {\n        name = os.Args[1]\n    }\n    r, err := c.SayHello(context.Background(), &pb.HelloRequest{Name: name})\n    if err != nil {\n        log.Fatal(\"could not greet: %v\", err)\n    }\n    log.Printf(\"Greeting: %s\", r.Message)\n}\n```\n这里需要注意的是包pb是我们之前生成的helloworld.pb.go所在的包，\n并非必须如上述代码所示在$GOPATH/src/helloworld/helloworld目录下\n\n#### 7.运行示例\n```\ngo run server.go\ngo run client.go\n```\n","slug":"基于Golang的gRPC使用笔记1","published":1,"updated":"2018-11-20T14:49:25.945Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpuya68s000h9kujt2c2sg1m","content":"<h1><span id=\"rpc入门\">RPC入门</span></h1>\n<h2><span id=\"rpc框架原理\">RPC框架原理</span></h2>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RPC框架的目的就是让远程服务调用更加简单,透明，RPC框架负责屏蔽底层的传输方式<span class=\"comment\">(TCP或者UDP)</span>,</span><br><span class=\"line\">序列化方式<span class=\"comment\">(XML/JSON/二进制)</span>和通信细节。服务调用者可以向本地接口一样调用远程的服务提供者，</span><br><span class=\"line\">而不需要关心底层通信细节和调用过程.</span><br></pre></td></tr></table></figure>\n<p><img src=\"rpc%E5%8E%9F%E7%90%86%E5%9B%BE.png\" alt=\"rpc原理图\"></p>\n<h2><span id=\"grpc\">gRPC</span></h2>\n<h3><span id=\"grpc简介\">gRPC简介</span></h3>\n<figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gRPC 是一个高性能、开源和通用的 RPC 框架，面向服务端和移动端,基于HTTP/<span class=\"number\">2</span>设计.</span><br></pre></td></tr></table></figure>\n<p><img src=\"gRPC%E8%B0%83%E7%94%A8%E7%A4%BA%E4%BE%8B.png\" alt=\"gRPC调用示例\"></p>\n<h3><span id=\"grpc特点\">gRPC特点</span></h3>\n<p><img src=\"gRPC%E7%89%B9%E7%82%B9.png\" alt=\"gRPC特点\"></p>\n<h3><span id=\"golang-grpc-示例\">Golang gRPC 示例</span></h3>\n<h4><span id=\"1-安装grpc-runtime\">1、安装gRPC runtime</span></h4>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go get google<span class=\"selector-class\">.golang</span><span class=\"selector-class\">.org</span>/grpc</span><br></pre></td></tr></table></figure>\n<h4><span id=\"2-protocal-buffer安装\">2、protocal buffer安装</span></h4>\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">从https:<span class=\"comment\">//github.com/google/protobuf/releases下载安装包，</span></span><br><span class=\"line\">例如：protobuf-cpp<span class=\"number\">-3.0</span><span class=\"number\">.0</span>-<span class=\"built_in\">beta</span><span class=\"number\">-3.</span>zip，解压后</span><br><span class=\"line\">./configure</span><br><span class=\"line\"><span class=\"built_in\">make</span> &amp;&amp; <span class=\"built_in\">make</span> install</span><br><span class=\"line\">再添加环境变量：export LD_LIBRARY_PATH=/usr/<span class=\"keyword\">local</span>/<span class=\"keyword\">lib</span>，之后protoc命令即可运行</span><br></pre></td></tr></table></figure>\n<h4><span id=\"3-安装golang-protoc-插件\">3、安装GoLang protoc 插件</span></h4>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"built_in\">get</span> -<span class=\"keyword\">a</span> github.<span class=\"keyword\">com</span>/golang/protobuf/protoc-gen-<span class=\"keyword\">go</span></span><br></pre></td></tr></table></figure>\n<h4><span id=\"4-定义service\">4、定义service</span></h4>\n<p>一个RPC service就是一个能够通过参数和返回值进行远程调用的method，我们可以简单地将它理解成一个函数。因为gRPC是通过将数据编码成protocal buffer来实现传输的。因此，我们通过protocal buffers interface definitioin language(IDL)来定义service method，同时将参数和返回值也定义成protocal buffer message类型。具体实现如下所示，包含下面代码的文件叫helloworld.proto：</p>\n<figure class=\"highlight thrift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">syntax = <span class=\"string\">\"proto3\"</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">option java_package = <span class=\"string\">\"io.grpc.examples\"</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">package helloworld;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// The greeter service definition.</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">service</span> <span class=\"title\">Greeter</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Sends a greeting</span></span><br><span class=\"line\">  rpc SayHello (HelloRequest) returns (HelloReply) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// The request message containing the user's name.</span></span><br><span class=\"line\">message HelloRequest &#123;</span><br><span class=\"line\">  <span class=\"built_in\">string</span> name = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// The response message containing the greetings</span></span><br><span class=\"line\">message HelloReply &#123;</span><br><span class=\"line\">  <span class=\"built_in\">string</span> message = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4><span id=\"5生成golang通用代码\">5.生成Golang通用代码</span></h4>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">接着，根据上述定义的service，我们可以利用protocal buffer compiler ，</span><br><span class=\"line\">即protoc生成相应的服务器端和客户端的GoLang代码。生成的代码中包含了客户端能够进行RPC的方法以及服务器端需要进行实现的接口。</span><br><span class=\"line\">假设现在所在的目录是<span class=\"variable\">$GOPATH</span>/src/helloworld/helloworld，我们将通过如下命令生成gRPC对应的GoLang代码：</span><br><span class=\"line\">protoc -I ./ helloworld.proto <span class=\"attribute\">--go_out</span>=plugins=grpc:.</span><br></pre></td></tr></table></figure>\n<h4><span id=\"6生成相关的rpc的客户端和服务端\">6.生成相关的RPC的客户端和服务端</span></h4>\n<p>在目录$GOPATH/src/helloworld/下创建server.go 和client.go，分别用于服务器和客户端的实现</p>\n<h5><span id=\"服务端代码\">服务端代码</span></h5>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// server.go</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">\"log\"</span></span><br><span class=\"line\">    <span class=\"string\">\"net\"</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"string\">\"golang.org/x/net/context\"</span></span><br><span class=\"line\">    <span class=\"string\">\"google.golang.org/grpc\"</span></span><br><span class=\"line\">    pb <span class=\"string\">\"helloworld/helloworld\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">    port = <span class=\"string\">\":50051\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">type</span> server <span class=\"keyword\">struct</span> &#123;&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *server)</span> <span class=\"title\">SayHello</span><span class=\"params\">(ctx context.Context, in *pb.HelloRequest)</span> <span class=\"params\">(*pb.HelloReply, error)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;pb.HelloReply&#123;Message: <span class=\"string\">\"Hello \"</span> + in.Name&#125;, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    lis, err := net.Listen(<span class=\"string\">\"tcp\"</span>, port)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(<span class=\"string\">\"failed to listen: %v\"</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    s := grpc.NewServer()</span><br><span class=\"line\">    pb.RegisterGreeterServer(s, &amp;server&#123;&#125;)</span><br><span class=\"line\">    s.Serve(lis)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5><span id=\"客户端代码\">客户端代码</span></h5>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//client.go</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">\"log\"</span></span><br><span class=\"line\">    <span class=\"string\">\"os\"</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"string\">\"golang.org/x/net/context\"</span></span><br><span class=\"line\">    <span class=\"string\">\"google.golang.org/grpc\"</span></span><br><span class=\"line\">    pb <span class=\"string\">\"helloworld/helloworld\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">    address     = <span class=\"string\">\"localhost:50051\"</span></span><br><span class=\"line\">    defaultName = <span class=\"string\">\"world\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    conn, err := grpc.Dial(address, grpc.WithInsecure())</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(<span class=\"string\">\"did not connect: %v\"</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> conn.Close()</span><br><span class=\"line\">    c := pb.NewGreeterClient(conn)</span><br><span class=\"line\"> </span><br><span class=\"line\">    name := defaultName</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(os.Args) &gt;<span class=\"number\">1</span> &#123;</span><br><span class=\"line\">        name = os.Args[<span class=\"number\">1</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    r, err := c.SayHello(context.Background(), &amp;pb.HelloRequest&#123;Name: name&#125;)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(<span class=\"string\">\"could not greet: %v\"</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    log.Printf(<span class=\"string\">\"Greeting: %s\"</span>, r.Message)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里需要注意的是包pb是我们之前生成的helloworld.pb.go所在的包，<br>\n并非必须如上述代码所示在$GOPATH/src/helloworld/helloworld目录下</p>\n<h4><span id=\"7运行示例\">7.运行示例</span></h4>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go <span class=\"keyword\">run</span><span class=\"bash\"> server.go</span></span><br><span class=\"line\"><span class=\"bash\">go run client.go</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1>RPC入门</h1>\n<h2>RPC框架原理</h2>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RPC框架的目的就是让远程服务调用更加简单,透明，RPC框架负责屏蔽底层的传输方式<span class=\"comment\">(TCP或者UDP)</span>,</span><br><span class=\"line\">序列化方式<span class=\"comment\">(XML/JSON/二进制)</span>和通信细节。服务调用者可以向本地接口一样调用远程的服务提供者，</span><br><span class=\"line\">而不需要关心底层通信细节和调用过程.</span><br></pre></td></tr></table></figure>\n<p><img src=\"rpc%E5%8E%9F%E7%90%86%E5%9B%BE.png\" alt=\"rpc原理图\"></p>\n<h2>gRPC</h2>\n<h3>gRPC简介</h3>\n<figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gRPC 是一个高性能、开源和通用的 RPC 框架，面向服务端和移动端,基于HTTP/<span class=\"number\">2</span>设计.</span><br></pre></td></tr></table></figure>\n<p><img src=\"gRPC%E8%B0%83%E7%94%A8%E7%A4%BA%E4%BE%8B.png\" alt=\"gRPC调用示例\"></p>\n<h3>gRPC特点</h3>\n<p><img src=\"gRPC%E7%89%B9%E7%82%B9.png\" alt=\"gRPC特点\"></p>\n<h3>Golang gRPC 示例</h3>\n<h4>1、安装gRPC runtime</h4>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go get google<span class=\"selector-class\">.golang</span><span class=\"selector-class\">.org</span>/grpc</span><br></pre></td></tr></table></figure>\n<h4>2、protocal buffer安装</h4>\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">从https:<span class=\"comment\">//github.com/google/protobuf/releases下载安装包，</span></span><br><span class=\"line\">例如：protobuf-cpp<span class=\"number\">-3.0</span><span class=\"number\">.0</span>-<span class=\"built_in\">beta</span><span class=\"number\">-3.</span>zip，解压后</span><br><span class=\"line\">./configure</span><br><span class=\"line\"><span class=\"built_in\">make</span> &amp;&amp; <span class=\"built_in\">make</span> install</span><br><span class=\"line\">再添加环境变量：export LD_LIBRARY_PATH=/usr/<span class=\"keyword\">local</span>/<span class=\"keyword\">lib</span>，之后protoc命令即可运行</span><br></pre></td></tr></table></figure>\n<h4>3、安装GoLang protoc 插件</h4>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"built_in\">get</span> -<span class=\"keyword\">a</span> github.<span class=\"keyword\">com</span>/golang/protobuf/protoc-gen-<span class=\"keyword\">go</span></span><br></pre></td></tr></table></figure>\n<h4>4、定义service</h4>\n<p>一个RPC service就是一个能够通过参数和返回值进行远程调用的method，我们可以简单地将它理解成一个函数。因为gRPC是通过将数据编码成protocal buffer来实现传输的。因此，我们通过protocal buffers interface definitioin language(IDL)来定义service method，同时将参数和返回值也定义成protocal buffer message类型。具体实现如下所示，包含下面代码的文件叫helloworld.proto：</p>\n<figure class=\"highlight thrift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">syntax = <span class=\"string\">\"proto3\"</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">option java_package = <span class=\"string\">\"io.grpc.examples\"</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">package helloworld;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// The greeter service definition.</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">service</span> <span class=\"title\">Greeter</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Sends a greeting</span></span><br><span class=\"line\">  rpc SayHello (HelloRequest) returns (HelloReply) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// The request message containing the user's name.</span></span><br><span class=\"line\">message HelloRequest &#123;</span><br><span class=\"line\">  <span class=\"built_in\">string</span> name = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// The response message containing the greetings</span></span><br><span class=\"line\">message HelloReply &#123;</span><br><span class=\"line\">  <span class=\"built_in\">string</span> message = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4>5.生成Golang通用代码</h4>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">接着，根据上述定义的service，我们可以利用protocal buffer compiler ，</span><br><span class=\"line\">即protoc生成相应的服务器端和客户端的GoLang代码。生成的代码中包含了客户端能够进行RPC的方法以及服务器端需要进行实现的接口。</span><br><span class=\"line\">假设现在所在的目录是<span class=\"variable\">$GOPATH</span>/src/helloworld/helloworld，我们将通过如下命令生成gRPC对应的GoLang代码：</span><br><span class=\"line\">protoc -I ./ helloworld.proto <span class=\"attribute\">--go_out</span>=plugins=grpc:.</span><br></pre></td></tr></table></figure>\n<h4>6.生成相关的RPC的客户端和服务端</h4>\n<p>在目录$GOPATH/src/helloworld/下创建server.go 和client.go，分别用于服务器和客户端的实现</p>\n<h5>服务端代码</h5>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// server.go</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">\"log\"</span></span><br><span class=\"line\">    <span class=\"string\">\"net\"</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"string\">\"golang.org/x/net/context\"</span></span><br><span class=\"line\">    <span class=\"string\">\"google.golang.org/grpc\"</span></span><br><span class=\"line\">    pb <span class=\"string\">\"helloworld/helloworld\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">    port = <span class=\"string\">\":50051\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">type</span> server <span class=\"keyword\">struct</span> &#123;&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *server)</span> <span class=\"title\">SayHello</span><span class=\"params\">(ctx context.Context, in *pb.HelloRequest)</span> <span class=\"params\">(*pb.HelloReply, error)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;pb.HelloReply&#123;Message: <span class=\"string\">\"Hello \"</span> + in.Name&#125;, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    lis, err := net.Listen(<span class=\"string\">\"tcp\"</span>, port)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(<span class=\"string\">\"failed to listen: %v\"</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    s := grpc.NewServer()</span><br><span class=\"line\">    pb.RegisterGreeterServer(s, &amp;server&#123;&#125;)</span><br><span class=\"line\">    s.Serve(lis)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5>客户端代码</h5>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//client.go</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">\"log\"</span></span><br><span class=\"line\">    <span class=\"string\">\"os\"</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"string\">\"golang.org/x/net/context\"</span></span><br><span class=\"line\">    <span class=\"string\">\"google.golang.org/grpc\"</span></span><br><span class=\"line\">    pb <span class=\"string\">\"helloworld/helloworld\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">    address     = <span class=\"string\">\"localhost:50051\"</span></span><br><span class=\"line\">    defaultName = <span class=\"string\">\"world\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    conn, err := grpc.Dial(address, grpc.WithInsecure())</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(<span class=\"string\">\"did not connect: %v\"</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> conn.Close()</span><br><span class=\"line\">    c := pb.NewGreeterClient(conn)</span><br><span class=\"line\"> </span><br><span class=\"line\">    name := defaultName</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(os.Args) &gt;<span class=\"number\">1</span> &#123;</span><br><span class=\"line\">        name = os.Args[<span class=\"number\">1</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    r, err := c.SayHello(context.Background(), &amp;pb.HelloRequest&#123;Name: name&#125;)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(<span class=\"string\">\"could not greet: %v\"</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    log.Printf(<span class=\"string\">\"Greeting: %s\"</span>, r.Message)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里需要注意的是包pb是我们之前生成的helloworld.pb.go所在的包，<br>\n并非必须如上述代码所示在$GOPATH/src/helloworld/helloworld目录下</p>\n<h4>7.运行示例</h4>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go <span class=\"keyword\">run</span><span class=\"bash\"> server.go</span></span><br><span class=\"line\"><span class=\"bash\">go run client.go</span></span><br></pre></td></tr></table></figure>\n"}],"PostAsset":[{"_id":"source/_posts/微服务API网关框架-1/架构3.png","slug":"架构3.png","post":"cjpuya68m000e9kuj0wb0cbu4","modified":1,"renderable":0},{"_id":"source/_posts/微服务API网关框架-1/正向代理.png","slug":"正向代理.png","post":"cjpuya68m000e9kuj0wb0cbu4","modified":1,"renderable":0},{"_id":"source/_posts/RabbitMQ学习-1-概念与认识/用户管理-添加用户.png","slug":"用户管理-添加用户.png","post":"cjpuya68100089kujcfl7l00u","modified":1,"renderable":0},{"_id":"source/_posts/hexo-theme-beantech/home_posts_tag-true.png","slug":"home_posts_tag-true.png","post":"cjpuya68e000c9kujohsppdyy","modified":1,"renderable":0},{"_id":"source/_posts/Lua脚本教程-1/Demo.png","slug":"Demo.png","post":"cjpuya66h00019kuj0g0pfq9l","modified":1,"renderable":0},{"_id":"source/_posts/Lua脚本教程-3/Demo.png","slug":"Demo.png","post":"cjpuya67u00049kuj1ssfmc7f","modified":1,"renderable":0},{"_id":"source/_posts/Lua脚本教程-2/Demo.png","slug":"Demo.png","post":"cjpuya67y00069kuje0hha7o2","modified":1,"renderable":0},{"_id":"source/_posts/微服务API网关框架-2/Demo.png","slug":"Demo.png","post":"cjpuya68j000d9kujyrnjclmd","modified":1,"renderable":0},{"_id":"source/_posts/hexo-theme-beantech/Demo.png","slug":"Demo.png","post":"cjpuya68e000c9kujohsppdyy","modified":1,"renderable":0},{"_id":"source/_posts/hexo-theme-beantech/home_posts_tag-false.png","post":"cjpuya68e000c9kujohsppdyy","slug":"home_posts_tag-false.png","modified":1,"renderable":1},{"_id":"source/_posts/RabbitMQ学习-2-队列模型/Demo.png","slug":"Demo.png","post":"cjpuya686000a9kujm51bhhfz","modified":1,"renderable":0},{"_id":"source/_posts/RabbitMQ学习-2-队列模型/工作队列.png","post":"cjpuya686000a9kujm51bhhfz","slug":"工作队列.png","modified":1,"renderable":1},{"_id":"source/_posts/RabbitMQ学习-2-队列模型/简单队列.png","post":"cjpuya686000a9kujm51bhhfz","slug":"简单队列.png","modified":1,"renderable":1},{"_id":"source/_posts/基于Golang的gRPC使用笔记1/Demo.png","slug":"Demo.png","post":"cjpuya68s000h9kujt2c2sg1m","modified":1,"renderable":0},{"_id":"source/_posts/基于Golang的gRPC使用笔记1/gRPC特点.png","post":"cjpuya68s000h9kujt2c2sg1m","slug":"gRPC特点.png","modified":1,"renderable":1},{"_id":"source/_posts/基于Golang的gRPC使用笔记1/gRPC调用示例.png","post":"cjpuya68s000h9kujt2c2sg1m","slug":"gRPC调用示例.png","modified":1,"renderable":1},{"_id":"source/_posts/基于Golang的gRPC使用笔记1/rpc原理图.png","post":"cjpuya68s000h9kujt2c2sg1m","slug":"rpc原理图.png","modified":1,"renderable":1},{"_id":"source/_posts/微服务API网关框架-1/Demo.png","slug":"Demo.png","post":"cjpuya68m000e9kuj0wb0cbu4","modified":1,"renderable":0},{"_id":"source/_posts/微服务API网关框架-1/单节点场景网关.png","post":"cjpuya68m000e9kuj0wb0cbu4","slug":"单节点场景网关.png","modified":1,"renderable":1},{"_id":"source/_posts/微服务API网关框架-1/反向代理.png","post":"cjpuya68m000e9kuj0wb0cbu4","slug":"反向代理.png","modified":1,"renderable":1},{"_id":"source/_posts/微服务API网关框架-1/多节点场景网关.png","post":"cjpuya68m000e9kuj0wb0cbu4","slug":"多节点场景网关.png","modified":1,"renderable":1},{"_id":"source/_posts/微服务API网关框架-1/新旧进程同在.png","slug":"新旧进程同在.png","post":"cjpuya68m000e9kuj0wb0cbu4","modified":1,"renderable":0},{"_id":"source/_posts/微服务API网关框架-1/架构.png","post":"cjpuya68m000e9kuj0wb0cbu4","slug":"架构.png","modified":1,"renderable":1},{"_id":"source/_posts/微服务API网关框架-1/架构2.png","post":"cjpuya68m000e9kuj0wb0cbu4","slug":"架构2.png","modified":1,"renderable":1},{"_id":"source/_posts/RabbitMQ学习-1-概念与认识/Demo.png","slug":"Demo.png","post":"cjpuya68100089kujcfl7l00u","modified":1,"renderable":0},{"_id":"source/_posts/RabbitMQ学习-1-概念与认识/v-host授权.png","post":"cjpuya68100089kujcfl7l00u","slug":"v-host授权.png","modified":1,"renderable":1},{"_id":"source/_posts/RabbitMQ学习-1-概念与认识/v-host授权2.png","post":"cjpuya68100089kujcfl7l00u","slug":"v-host授权2.png","modified":1,"renderable":1},{"_id":"source/_posts/RabbitMQ学习-1-概念与认识/v-host授权后.png","post":"cjpuya68100089kujcfl7l00u","slug":"v-host授权后.png","modified":1,"renderable":1},{"_id":"source/_posts/RabbitMQ学习-1-概念与认识/v-host添加.png","post":"cjpuya68100089kujcfl7l00u","slug":"v-host添加.png","modified":1,"renderable":1},{"_id":"source/_posts/RabbitMQ学习-1-概念与认识/vhost.png","post":"cjpuya68100089kujcfl7l00u","slug":"vhost.png","modified":1,"renderable":1},{"_id":"source/_posts/RabbitMQ学习-1-概念与认识/异步处理.png","post":"cjpuya68100089kujcfl7l00u","slug":"异步处理.png","modified":1,"renderable":1},{"_id":"source/_posts/RabbitMQ学习-1-概念与认识/日志收集与处理.png","post":"cjpuya68100089kujcfl7l00u","slug":"日志收集与处理.png","modified":1,"renderable":1},{"_id":"source/_posts/RabbitMQ学习-1-概念与认识/秒杀抢购.png","post":"cjpuya68100089kujcfl7l00u","slug":"秒杀抢购.png","modified":1,"renderable":1},{"_id":"source/_posts/RabbitMQ学习-1-概念与认识/系统解耦.png","post":"cjpuya68100089kujcfl7l00u","slug":"系统解耦.png","modified":1,"renderable":1}],"PostCategory":[],"PostTag":[{"post_id":"cjpuya66h00019kuj0g0pfq9l","tag_id":"cjpuya66m00029kujkudme0wr","_id":"cjpuya66q00039kuj8x1srw4y"},{"post_id":"cjpuya68100089kujcfl7l00u","tag_id":"cjpuya68c000b9kujyaijmfwj","_id":"cjpuya68r000g9kuj2jbha3y5"},{"post_id":"cjpuya686000a9kujm51bhhfz","tag_id":"cjpuya68c000b9kujyaijmfwj","_id":"cjpuya68z000j9kujp2ihynus"},{"post_id":"cjpuya68e000c9kujohsppdyy","tag_id":"cjpuya68x000i9kujjtw1sq6p","_id":"cjpuya691000l9kujfss7lc8e"},{"post_id":"cjpuya68j000d9kujyrnjclmd","tag_id":"cjpuya690000k9kujaxi7i8x1","_id":"cjpuya697000n9kuj7i0f6yw5"},{"post_id":"cjpuya68m000e9kuj0wb0cbu4","tag_id":"cjpuya690000k9kujaxi7i8x1","_id":"cjpuya699000p9kuj1aounfl1"},{"post_id":"cjpuya68s000h9kujt2c2sg1m","tag_id":"cjpuya698000o9kuj7a5gqd63","_id":"cjpuya69b000r9kujsckoebgg"},{"post_id":"cjpuya68s000h9kujt2c2sg1m","tag_id":"cjpuya69a000q9kujd5eqm46m","_id":"cjpuya69c000s9kujateyoecb"}],"Tag":[{"name":"Lua","_id":"cjpuya66m00029kujkudme0wr"},{"name":"RabbitMQ 消息队列","_id":"cjpuya68c000b9kujyaijmfwj"},{"name":"Hexo","_id":"cjpuya68x000i9kujjtw1sq6p"},{"name":"微服务API网关","_id":"cjpuya690000k9kujaxi7i8x1"},{"name":"gRPC","_id":"cjpuya698000o9kuj7a5gqd63"},{"name":"golang","_id":"cjpuya69a000q9kujd5eqm46m"}]}}